<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1 release (February 19th, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>User&nbsp;ManualPortable&nbsp;Object&nbsp;Compiler Version&nbsp;3.2.x</TITLE>
<META NAME="description" CONTENT="User&nbsp;ManualPortable&nbsp;Object&nbsp;Compiler Version&nbsp;3.2.x">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="manual.css">
</HEAD>
<BODY >

<P>
<H1 ALIGN="CENTER">User&nbsp;Manual
<BR>
Portable&nbsp;Object&nbsp;Compiler
<BR>
<P><P>
<BR>
Version&nbsp;3.2.x</H1>
<P ALIGN="CENTER"><STRONG>David&nbsp;Stes</STRONG></P>
<P ALIGN="CENTER"><STRONG>October 11, 2003</STRONG></P>
<P ALIGN="LEFT"></P>

<P>
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->
<UL>
<LI><A NAME="tex2html1"
 HREF="manual.html">Contents</A>
<LI><A NAME="tex2html2"
 HREF="manual.html#SECTION00200000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html3"
 HREF="manual.html#SECTION00210000000000000000">How O<SMALL>BJECTIVE-</SMALL>C differs from C</A>
<LI><A NAME="tex2html4"
 HREF="manual.html#SECTION00220000000000000000">Hello World</A>
<LI><A NAME="tex2html5"
 HREF="manual.html#SECTION00230000000000000000">More Hello World</A>
<LI><A NAME="tex2html6"
 HREF="manual.html#SECTION00240000000000000000">More information</A>
</UL>
<LI><A NAME="tex2html7"
 HREF="manual.html#SECTION00300000000000000000">Collection Classes</A>
<UL>
<LI><A NAME="tex2html8"
 HREF="manual.html#SECTION00310000000000000000">Object Pak</A>
<LI><A NAME="tex2html9"
 HREF="manual.html#SECTION00320000000000000000">Integer (BigInt)</A>
<LI><A NAME="tex2html10"
 HREF="manual.html#SECTION00330000000000000000">OrdCltn</A>
<LI><A NAME="tex2html11"
 HREF="manual.html#SECTION00340000000000000000">Set</A>
<LI><A NAME="tex2html12"
 HREF="manual.html#SECTION00350000000000000000">String</A>
<LI><A NAME="tex2html13"
 HREF="manual.html#SECTION00360000000000000000">SortCltn</A>
<LI><A NAME="tex2html14"
 HREF="manual.html#SECTION00370000000000000000">Collection Messages</A>
<UL>
<LI><A NAME="tex2html15"
 HREF="manual.html#SECTION00371000000000000000">new</A>
<LI><A NAME="tex2html16"
 HREF="manual.html#SECTION00372000000000000000">str:</A>
<LI><A NAME="tex2html17"
 HREF="manual.html#SECTION00373000000000000000">with:</A>
<LI><A NAME="tex2html18"
 HREF="manual.html#SECTION00374000000000000000">printLine</A>
<LI><A NAME="tex2html19"
 HREF="manual.html#SECTION00375000000000000000">size</A>
<LI><A NAME="tex2html20"
 HREF="manual.html#SECTION00376000000000000000">do:</A>
<LI><A NAME="tex2html21"
 HREF="manual.html#SECTION00377000000000000000">add:</A>
<LI><A NAME="tex2html22"
 HREF="manual.html#SECTION00378000000000000000">remove:</A>
<LI><A NAME="tex2html23"
 HREF="manual.html#SECTION00379000000000000000">at:</A>
<LI><A NAME="tex2html24"
 HREF="manual.html#SECTION003710000000000000000">removeAt:</A>
<LI><A NAME="tex2html25"
 HREF="manual.html#SECTION003711000000000000000">eachElement</A>
<LI><A NAME="tex2html26"
 HREF="manual.html#SECTION003712000000000000000">addAll:</A>
<LI><A NAME="tex2html27"
 HREF="manual.html#SECTION003713000000000000000">collect:</A>
</UL>
</UL>
<LI><A NAME="tex2html28"
 HREF="manual.html#SECTION00400000000000000000">Exception Handling</A>
<UL>
<LI><A NAME="tex2html29"
 HREF="manual.html#SECTION00410000000000000000">Exceptions and Blocks</A>
<UL>
<LI><A NAME="tex2html30"
 HREF="manual.html#SECTION00411000000000000000">The messages -error: and -ifError:</A>
<LI><A NAME="tex2html31"
 HREF="manual.html#SECTION00412000000000000000">Debugging Exceptions</A>
<LI><A NAME="tex2html32"
 HREF="manual.html#SECTION00413000000000000000">The message -on:do:</A>
</UL>
</UL>
<LI><A NAME="tex2html33"
 HREF="manual.html#SECTION00500000000000000000">Language Elements</A>
<UL>
<LI><A NAME="tex2html34"
 HREF="manual.html#SECTION00510000000000000000">Class Definitions</A>
<UL>
<LI><A NAME="tex2html35"
 HREF="manual.html#SECTION00511000000000000000">Old Style Definitions</A>
<LI><A NAME="tex2html36"
 HREF="manual.html#SECTION00512000000000000000">Class Variables</A>
<LI><A NAME="tex2html37"
 HREF="manual.html#SECTION00513000000000000000">Missing Interface Definitions</A>
</UL>
<LI><A NAME="tex2html38"
 HREF="manual.html#SECTION00520000000000000000">Classes</A>
<LI><A NAME="tex2html39"
 HREF="manual.html#SECTION00530000000000000000">Messages</A>
<LI><A NAME="tex2html40"
 HREF="manual.html#SECTION00540000000000000000">Blocks</A>
</UL>
<LI><A NAME="tex2html41"
 HREF="manual.html#SECTION00600000000000000000">Runtime</A>
<UL>
<LI><A NAME="tex2html42"
 HREF="manual.html#SECTION00610000000000000000">Boehm Garbage Collection</A>
<LI><A NAME="tex2html43"
 HREF="manual.html#SECTION00620000000000000000">Reference Counted Garbage Collection</A>
<LI><A NAME="tex2html44"
 HREF="manual.html#SECTION00630000000000000000">Selectors</A>
<LI><A NAME="tex2html45"
 HREF="manual.html#SECTION00640000000000000000">Sending Messages to Nil</A>
<LI><A NAME="tex2html46"
 HREF="manual.html#SECTION00650000000000000000">Message Tracing</A>
<LI><A NAME="tex2html47"
 HREF="manual.html#SECTION00660000000000000000">Initialization</A>
<UL>
<LI><A NAME="tex2html48"
 HREF="manual.html#SECTION00661000000000000000">General</A>
<LI><A NAME="tex2html49"
 HREF="manual.html#SECTION00662000000000000000">Postlink</A>
<LI><A NAME="tex2html50"
 HREF="manual.html#SECTION00663000000000000000">Automatic</A>
</UL>
<LI><A NAME="tex2html51"
 HREF="manual.html#SECTION00670000000000000000">Threads</A>
</UL>
<LI><A NAME="tex2html52"
 HREF="manual.html#SECTION00700000000000000000">Compiler</A>
<UL>
<LI><A NAME="tex2html53"
 HREF="manual.html#SECTION00710000000000000000">Testing for Portable Object Compiler</A>
<LI><A NAME="tex2html54"
 HREF="manual.html#SECTION00720000000000000000">Compiling C++</A>
<LI><A NAME="tex2html55"
 HREF="manual.html#SECTION00730000000000000000">Assignments to self</A>
<LI><A NAME="tex2html56"
 HREF="manual.html#SECTION00740000000000000000">Inline Cache</A>
<LI><A NAME="tex2html57"
 HREF="manual.html#SECTION00750000000000000000">Speeding up compiles</A>
<UL>
<LI><A NAME="tex2html58"
 HREF="manual.html#SECTION00751000000000000000">Binary driver</A>
<LI><A NAME="tex2html59"
 HREF="manual.html#SECTION00752000000000000000">Temporary Files</A>
<LI><A NAME="tex2html60"
 HREF="manual.html#SECTION00753000000000000000">C Compiler Backend</A>
</UL>
</UL>
<LI><A NAME="tex2html61"
 HREF="manual.html#SECTION00800000000000000000">Link Editor</A>
<UL>
<LI><A NAME="tex2html62"
 HREF="manual.html#SECTION00810000000000000000">Static Libraries</A>
<LI><A NAME="tex2html63"
 HREF="manual.html#SECTION00820000000000000000">O<SMALL>BJECTIVE-</SMALL>C and Dynamic Libraries</A>
<LI><A NAME="tex2html64"
 HREF="manual.html#SECTION00830000000000000000">UNIX</A>
<UL>
<LI><A NAME="tex2html65"
 HREF="manual.html#SECTION00831000000000000000">Dynamic Libraries</A>
<LI><A NAME="tex2html66"
 HREF="manual.html#SECTION00832000000000000000">Shared Libraries</A>
<LI><A NAME="tex2html67"
 HREF="manual.html#SECTION00833000000000000000">objpak_s.a and objcrt_s.a</A>
</UL>
<LI><A NAME="tex2html68"
 HREF="manual.html#SECTION00840000000000000000">Windows</A>
<UL>
<LI><A NAME="tex2html69"
 HREF="manual.html#SECTION00841000000000000000">Building a DLL</A>
<LI><A NAME="tex2html70"
 HREF="manual.html#SECTION00842000000000000000">Dynamically loading DLL's</A>
<LI><A NAME="tex2html71"
 HREF="manual.html#SECTION00843000000000000000">OBJCRT.DLL</A>
<LI><A NAME="tex2html72"
 HREF="manual.html#SECTION00844000000000000000">OBJPAK.DLL</A>
</UL>
</UL>
<LI><A NAME="tex2html73"
 HREF="manual.html#SECTION00900000000000000000">Other Development Tools</A>
<UL>
<LI><A NAME="tex2html74"
 HREF="manual.html#SECTION00910000000000000000">Editors</A>
<UL>
<LI><A NAME="tex2html75"
 HREF="manual.html#SECTION00911000000000000000">ctags</A>
<LI><A NAME="tex2html76"
 HREF="manual.html#SECTION00912000000000000000">vim</A>
<LI><A NAME="tex2html77"
 HREF="manual.html#SECTION00913000000000000000">elvis</A>
<LI><A NAME="tex2html78"
 HREF="manual.html#SECTION00914000000000000000">emacs</A>
<LI><A NAME="tex2html79"
 HREF="manual.html#SECTION00915000000000000000">indent</A>
</UL>
<LI><A NAME="tex2html80"
 HREF="manual.html#SECTION00920000000000000000">Debuggers</A>
<UL>
<LI><A NAME="tex2html81"
 HREF="manual.html#SECTION00921000000000000000">Symbolic Representation of Objects</A>
<LI><A NAME="tex2html82"
 HREF="manual.html#SECTION00922000000000000000">Message Tracing in gdb</A>
<LI><A NAME="tex2html83"
 HREF="manual.html#SECTION00923000000000000000">Setting breakpoints</A>
<LI><A NAME="tex2html84"
 HREF="manual.html#SECTION00924000000000000000">WATCOM wd and wdw</A>
</UL>
<LI><A NAME="tex2html85"
 HREF="manual.html#SECTION00930000000000000000">Integrated Development Environment</A>
<UL>
<LI><A NAME="tex2html86"
 HREF="manual.html#SECTION00931000000000000000">WATCOM IDE</A>
</UL>
<LI><A NAME="tex2html87"
 HREF="manual.html#SECTION00940000000000000000">gprof</A>
<LI><A NAME="tex2html88"
 HREF="manual.html#SECTION00950000000000000000">purify</A>
</UL>
<LI><A NAME="tex2html89"
 HREF="manual.html#SECTION001000000000000000000">Bibliography</A>
</UL>
<!--End of Table of Contents-->

<P>

<H1><A NAME="SECTION00200000000000000000">
Introduction</A>
</H1>

<P>

<H1><A NAME="SECTION00210000000000000000">
How O<SMALL>BJECTIVE-</SMALL>C differs from C</A>
</H1>

<P>
O<SMALL>BJECTIVE-</SMALL>C adds a few constructs, borrowed from Smalltalk, to the C language.  It is necessary, for using the O<SMALL>BJECTIVE-</SMALL>C constructs in a correct way, to learn some Smalltalk (as described, for instance, in [#!ST80!#]).

<P>
At least, some superficial hands on experience with a commercial Smalltalk system, or a freely available one, such as the <EM>Squeak</EM> system or such as perhaps <EM>Little Smalltalk</EM>, is an important advantage when learning O<SMALL>BJECTIVE-</SMALL>C. 

<P>

<H1><A NAME="SECTION00220000000000000000">
Hello World</A>
</H1>

<P>
Let's start by giving our version of the well-known <EM>hello world</EM> tutorial program.

<P>
We should warn the reader at once that there is no difference with regular, plain C (as defined in [#!Kernighan88!#]), for such a simple program.

<P>
Source code files in O<SMALL>BJECTIVE-</SMALL>C have a <EM>.m</EM> extension, so use a text-editor, such as <EM>vi</EM>, and create a file <EM>hello.m</EM> :

<P>
<BLOCKQUOTE>
<PRE>
#include &lt;stdio.h&gt;

int main(int argc,char **argv)
{
    printf("hello world!\n");
}
</PRE></BLOCKQUOTE>
<P>
Compile the file using the command :

<P>
<BLOCKQUOTE>
<PRE>
objc -q hello.m -o hello
</PRE></BLOCKQUOTE>
<P>
Run the program by typing <EM>hello</EM>.  The <EM>-q</EM> option of the <EM>objc</EM> compiler suppresses a copyright message.  If you'd like to always suppress this message, edit a file such as <EM>.cshrc</EM> (or <EM>.zshrc</EM> and so on) and do (the equivalent of):

<P>
<BLOCKQUOTE>
<PRE>
setenv OBJCOPT "-q"
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00230000000000000000">
More Hello World</A>
</H1>

<P>
You normally mix regular C and O<SMALL>BJECTIVE-</SMALL>C extensions.  For example, we'll extend the <EM>hello</EM> program to say hello to a <EM>Set</EM> of people.

<P>
<BLOCKQUOTE>
<PRE>
#include &lt;stdio.h&gt;
#include &lt;objpak.h&gt;

int main(int argc,char **argv)
{
    id set = [Set new];
    argv++;while (--argc) [set add:[String str:*argv++]];
    [set do:{ :each | printf("hello, %s!\n",[each str]); }];
}
</PRE></BLOCKQUOTE>
<P>
The program first <EM>includes</EM> a header file objpak.h, for defining O<SMALL>BJECTIVE-</SMALL>C datatypes.  The <EM>id</EM> type (as used in the main function) is a C type that stands for an O<SMALL>BJECTIVE-</SMALL>C object.  Message expressions are written inside square brackets (<EM>[receiver message]</EM>).  The example creates a Set instance and adds String objects to the Set.  Sets automatically remove duplicate entries, so there will be no duplicate names in the Set.  Finally, the program prints a hello message for each String object in the Set, using the Block syntax, which is just using ordinary braces, as for compound statements in C.

<P>
<BLOCKQUOTE>
<PRE>
objc -q hello.m -o hello
hello joe phil joe luke joe phil joe
</PRE></BLOCKQUOTE>
<P>
You should see something like:

<P>
<BLOCKQUOTE>
<PRE>
hello, joe!
hello, phil!
hello, luke!
</PRE></BLOCKQUOTE>
<P>
Although some names were specified more than once on the command line, the program doesn't print multiple greetings for the same name; the Set object has filtered out duplicates; it uses String hashing to find equal strings.

<P>

<H1><A NAME="SECTION00240000000000000000">
More information</A>
</H1>

<P>
On UNIX, try <EM>man objc</EM> to read the manpage of the compiler.  There are also manpages for most objects, e.g. <EM>man String</EM> or <EM>man OrdCltn</EM> will list a specification sheet for these Objects.  There is also a set of HTML specification sheets.

<P>
Also see the original book [#!Cox86!#] on the language, or later papers, such as [#!Cox91!#].   Another good book is [#!Pinson90!#].  There exists a newsgroup, <EM>comp.lang.objective-c</EM> for asking questions, or you can just send some email.

<P>

<H1><A NAME="SECTION00300000000000000000">
Collection Classes</A>
</H1>

<P>

<H1><A NAME="SECTION00310000000000000000">
Object Pak</A>
</H1>

<P>
<EM>Object Pak</EM> is a set of classes that are interface compatible with Stepstone's ICpak101 classes, which in their turn, are modelled after Collection classes that you find in Smalltalk (see [#!ST80!#]).

<P>
Collections are an important set of classes; they are classes that manage groups of objects; it is almost impossible to write O<SMALL>BJECTIVE-</SMALL>C withouth using some sort of collection.  A collection is simply a set of elements where each element is a pointer to an object.

<P>
Most collections do not care what class of object they manage.  Each element in a collection could contain a different instance (object) from a different class.  There are sometimes specific requirements, such as the fact that elements in a <EM>Set</EM> must implement the <TT>hash</TT> method.

<P>

<H1><A NAME="SECTION00320000000000000000">
Integer (BigInt)</A>
</H1>

<P>
<EM>BigInt</EM> instances represent (arbitrary length) integers.  Typically, the O<SMALL>BJECTIVE-</SMALL>C <EM>BigInt</EM> class is much more efficient than a Smalltalk large integer, because the <EM>BigInt</EM> class is implemented in C.

<P>

<H1><A NAME="SECTION00330000000000000000">
OrdCltn</A>
</H1>

<P>
OrdCltn objects are the ``work-horse'' used most often in O<SMALL>BJECTIVE-</SMALL>C programs.  They are what Smalltalk programmers call an OrderedCollection : a variable-sized collection of elements, in which the user of the collection specifies the location of each element; index keys begin at 0 and increase.  The elements in the collection can be any class of Object; duplicate objects are allowed.

<P>

<H1><A NAME="SECTION00340000000000000000">
Set</A>
</H1>

<P>
Sets do not allow duplicate objects.  A Set ignores any request that would add a duplicate to the colleciton.

<P>

<H1><A NAME="SECTION00350000000000000000">
String</A>
</H1>

<P>
Strings are objects that hold ordinary C strings.  String objects are heavily used as elements of Collection classes.

<P>

<H1><A NAME="SECTION00360000000000000000">
SortCltn</A>
</H1>

<P>
SortCltn's are what Smalltalk programmers call a SortedCollection.  Elements are stored in alphabetic order (by default, for Strings), or more generally, as specified by a block of code, called the SortBlock.  SortCltn's are used for maintaining sorted lists of elements.

<P>

<H1><A NAME="SECTION00370000000000000000">
Collection Messages</A>
</H1>

<P>

<H2><A NAME="SECTION00371000000000000000">
new</A>
</H2>

<P>
The new message allocates a collection with a default size.  It returns the new collection (empty, no elements) :

<P>
<BLOCKQUOTE>
<PRE>
aCltn = [OrdCltn new];
</PRE></BLOCKQUOTE>
<P>
When objects are added to the OrdCltn, at some point, additional space can be needed; the OrdCltn object automatically expands itself.

<P>

<H2><A NAME="SECTION00372000000000000000">
str:</A>
</H2>

<P>
The <TT>str:</TT> message creates a new instance by setting the contents of the object to the C string argument :

<P>
<BLOCKQUOTE>
<PRE>
myString = [String str:"hello world"];
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00373000000000000000">
with:</A>
</H2>

<P>
Method to create a OrdCltn to hold the specified objects.  This is an example of a method with a variable number of arguments : the first argument is the number of objects that follows.

<P>
<BLOCKQUOTE>
<PRE>
aCltn = [OrdCltn with:1,[String str:"hello"]];
</PRE></BLOCKQUOTE>
<P>
In this case, the size of this OrdCltn will equal to the number of arguments of the <TT>with:</TT> method, and the objects will be added in the same order as they are listed.   But <TT>with:</TT> can also be used with other types of collections, such as a Set.

<P>

<H2><A NAME="SECTION00374000000000000000">
printLine</A>
</H2>

<P>
Method to print an Object on the <EM>stdout</EM>, followed by a newline.

<P>
<BLOCKQUOTE>
<PRE>
[ [ BigInt str:"3141592654" ] printLine ];
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00375000000000000000">
size</A>
</H2>

<P>
Returns the number of elements currently in the collection.  It is supported by all collections.  If the collection is empty, the size is zero.

<P>
<BLOCKQUOTE>
<PRE>
int n = [aCltn size];
</PRE></BLOCKQUOTE>
<P>
If the receiver of the <TT>size</TT> method is <EM>nil</EM>, then this would set <EM>n</EM> to zero.  If you compile with <EM>-noNilRcvr</EM>, an error message will be generated.

<P>

<H2><A NAME="SECTION00376000000000000000">
do:</A>
</H2>

<P>
The <TT>do:</TT> message is for looping through each element in a collection, and for running a one-argument block of code (specified by the argument) with each element as the argument (of the block).  This message is used for side effects mostly, with no interest in the return value of <TT>do:</TT> itself.

<P>
The hello world example, of the introduction, is one example sending a <TT>do:</TT> message to print the elements of a Set.

<P>
Blocks are important for O<SMALL>BJECTIVE-</SMALL>C exception handling, but Blocks can also be used for simple purposes, such as counting the number of elements in a OrdCltn:

<P>
<BLOCKQUOTE>
<PRE>
int size = 0;
[aOrdCltn do:{ :each | size++; }]
printf("%i",size);
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00377000000000000000">
add:</A>
</H2>

<P>
The <TT>add:</TT> message adds an element to a collection, and makes it dynamically grow (if more space is needed to hold the element).  In Smalltalk, the method <TT>add:</TT> returns the element that was added.  In O<SMALL>BJECTIVE-</SMALL>C, it traditionally returns the receiver (the collection) so that multiple <TT>add:</TT> messages can be nested.

<P>
<BLOCKQUOTE>
<PRE>
[[aOrdCltn add:myObject] add:myString];
</PRE></BLOCKQUOTE>
<H2><A NAME="SECTION00378000000000000000">
remove:</A>
</H2>

<P>
The <TT>remove:</TT> message removes the argument if it is in a collection.  It returns the object that was deleted from the collection, and shrinks the size of the collection.  If the object is not found, an exception is raised, which, if you do not catch it, will stop the program and display an error message.

<P>
<BLOCKQUOTE>
<PRE>
[aOrdCltn add:myObject];
[aOrdCltn remove:myObject];
</PRE></BLOCKQUOTE>
<P>
For some collections, the identity check is an equality check.  For example, the Set class will remove by using the <TT>isEqual:</TT> as criterium.  You should consult the class documentation (specification sheet) to be sure.

<P>

<H2><A NAME="SECTION00379000000000000000">
at:</A>
</H2>

<P>
This message is implemented by <EM>OrdCltn</EM>, but not by <EM>Set</EM>.  It returns the object at the index specified by the argument.

<P>
<BLOCKQUOTE>
<PRE>
for(i=0;i&lt;[aCltn size];i++) [[aCltn at:i] foo];
</PRE></BLOCKQUOTE>
<P>
is pretty much equivalent to :

<P>
<BLOCKQUOTE>
<PRE>
[ aCltn do: { :each | [each foo]; } ];
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION003710000000000000000">
removeAt:</A>
</H2>

<P>
This message removes the object at the specified index.  This causes all succeeding elements to shift down one index position.  It returns the removed object.  It's most efficient to start with the last element and work towards the first element :

<P>
<BLOCKQUOTE>
<PRE>
i = [aCltn size]; while (--i &gt;= 0) {
    [aSet add:[aCltn removeAt:i]];
}
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION003711000000000000000">
eachElement</A>
</H2>

<P>
This message returns a <EM>Sequence</EM>, an Object that can be used to sequentially access the contents of a OrdCltn.

<P>
<BLOCKQUOTE>
<PRE>
id eachElement = [aCltn eachElement];
while (element = [eachElement next]) { [element foo]; }
</PRE></BLOCKQUOTE>
<P>
All Collections implement <TT>eachElement</TT> so it's a good Collection-independent way to process the contents of a Collection.

<P>

<H2><A NAME="SECTION003712000000000000000">
addAll:</A>
</H2>

<P>
This message is to combine two collections.  It can be used to move objects from <EM>Set</EM>'s into <EM>OrdCltn</EM>'s and vice versa.  For example, the following is a quick way to delete all the <EM>duplicates</EM> from a OrdCltn :

<P>
<BLOCKQUOTE>
<PRE>
[[OrdCltn new] addAll:[[Set new] addAll:aCltn]];
</PRE></BLOCKQUOTE>
<P>
The <EM>SortCltn</EM> class can be used in the same way, as a filter to sort the objects in a collection, to then move the objects back into an indexable ordered OrdCltn.

<P>

<H2><A NAME="SECTION003713000000000000000">
collect:</A>
</H2>

<P>
The <TT>collect:</TT> message is similar to <TT>addAll:</TT>, but allows you to specify a <EM>transformBlock</EM>.

<P>
<BLOCKQUOTE>
<PRE>
filter = [Set new];
aCltn  = [aCltn collect:{ :each | [filter addNTest:each] }];
</PRE></BLOCKQUOTE>
<P>
The <TT>collect:</TT> method creates a new OrdCltn, which consists (in the example above) of the return values of the <TT>addNTest:</TT> method, which returns <EM>nil</EM> for duplicates.  The transformBlock has as a side-effect, the creation of a Set, called ``filter'', which has the same contents. 

<P>

<H1><A NAME="SECTION00400000000000000000">
Exception Handling</A>
</H1>

<P>

<H1><A NAME="SECTION00410000000000000000">
Exceptions and Blocks</A>
</H1>

<P>
This chapter discusses exception handling for O<SMALL>BJECTIVE-</SMALL>C as outlined in [#!Cox91!#].  The messages <TT>-error:</TT> and <TT>-ifError:</TT> are similar to messages in older Smalltalk versions.  The message <TT>-on:do:</TT> is modeled after ANSI Smalltalk.  The <TT>-on:do:</TT> message is supported by version 3.2.x (or higher) of O<SMALL>BJECTIVE-</SMALL>C.

<P>

<H2><A NAME="SECTION00411000000000000000">
The messages -error: and -ifError:</A>
</H2>

<P>
The message <TT>-error:</TT> can be used in response to some abnormal program conditio.  This message can be sent to any Object.

<P>
<BLOCKQUOTE>
<PRE>
if (!h) [ anObject error:"h can't be zero" ];
</PRE></BLOCKQUOTE>
<P>
This is similar to how in Stepstone O<SMALL>BJECTIVE-</SMALL>C an error action (aborting the process) is performed.

<P>
However, in our case, the user might substitute a different Block (called <EM>exception handler</EM>) for the default handler (which aborts the process).  This is done by using the method <TT>ifError:</TT> :

<P>
<BLOCKQUOTE>
<PRE>
[ { c = [a foo]; } ifError: { :msg :rcv | printf("got an exception"); } ];
</PRE></BLOCKQUOTE>
<P>
Instead of evaluating the default handler, <TT>error:</TT> will execute the exception handler specified by <TT>ifError:</TT>.  The handler is invoked with a message object and with the receiver of the <TT>error:</TT> message. 

<P>

<H2><A NAME="SECTION00412000000000000000">
Debugging Exceptions</A>
</H2>

<P>
An <EM>uncaught</EM> exception is easy to debug with O<SMALL>BJECTIVE-</SMALL>C exceptions : because the exception handler is evaluated as subroutine of the <TT>error:</TT> method, the stack backtrace towards the function that is raising the exception, is not lost.

<P>

<H2><A NAME="SECTION00413000000000000000">
The message -on:do:</A>
</H2>

<P>
In release 3.2.x, and newer versions, Block instances respond to the message <TT>-on:do:</TT>.  This messages takes as argument the <EM>class</EM> of exceptions that should be handled, and a <EM>handler</EM>, which is a Block, taking one argument (the exception instance).

<P>
For example, to handle an exception using <TT>-on:do:</TT> :   

<P>
<BLOCKQUOTE>
<PRE>
[ { c = [a foo]; } on:OutOfMemory do: { :exc | printf("got an exception"); } ];
</PRE></BLOCKQUOTE>
<P>
The <TT>-on:do:</TT> message works together with subclasses of the Exception class.  You can subclass the Exception class to make your custom Exception classes.  An exception is signalled as follows :

<P>
<BLOCKQUOTE>
<PRE>
[[MyException new] signal];
</PRE></BLOCKQUOTE>
<P>
The instance of the exception class that is created (by sending <TT>+new</TT>), is the argument of the handler block of the <TT>-on:do:</TT> message.

<P>

<H1><A NAME="SECTION00500000000000000000">
Language Elements</A>
</H1>

<P>

<H1><A NAME="SECTION00510000000000000000">
Class Definitions</A>
</H1>

<P>
You normally define your own class by <EM>subclassing</EM> an existing class, such as the <EM>root class</EM>, Object.  A class automatically responds to all methods <EM>inherited</EM> from the superclass. 

<P>
The <EM>header file</EM>, say MyObject.h, would contain:

<P>
<BLOCKQUOTE>
<PRE>
@interface MyObject : Object { id ivar; }
+ bar;
- foo;
@end
</PRE></BLOCKQUOTE>
<P>
This prototypes a class called <EM>MyObject</EM>, which is declared to be a subclass of <EM>Object</EM>, with one <EM>instance variable</EM> (called ivar) of type ``id''.

<P>
The interface also exports two methods : a factory method (preceded by a ``+'') and an instance method (foo).  The class itself responds to factory methods; instances of the class, respond to instance methods.

<P>
The <EM>implementation file</EM>, say MyObject.m, must include the interface file, and defines the implementation of the methods.

<P>
<BLOCKQUOTE>
<PRE>
#include "MyObject.h"

@implementation MyObject 
+ bar { return [self new] };
- foo { return ivar; }
@end
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00511000000000000000">
Old Style Definitions</A>
</H2>

<P>
Prior to NeXT O<SMALL>BJECTIVE-</SMALL>C (release 3.x of the Stepstone compiler), the `=' syntax was used for defining classes.  The Portable Object Compiler supports this syntax (in addition to the '@' syntax) :

<P>
<BLOCKQUOTE>
<PRE>
= MyClass : Object { id ivar; }
+ new { self = [super new]; ivar = [String new]; return self; }
=:
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00512000000000000000">
Class Variables</A>
</H2>

<P>
The Portable Object Compiler has an experimental implementation of class variables, using the same syntax as the K.Lerman extended Stepstone compiler.

<P>
<BLOCKQUOTE>
<PRE>
= MyClass : Object { id ivar; } : { id cvar; }
- foo { cvar = [Object new]; return self; }
+ bar { return cvar; }
- boo:aString { ivar = aString; return self; }
- boo { return ivar; }
=:
</PRE></BLOCKQUOTE>
<P>
It's currently advised, and anyhow a safe thing to do, to compile with <EM>-noSelfAssign</EM> when using class variables.

<P>

<H2><A NAME="SECTION00513000000000000000">
Missing Interface Definitions</A>
</H2>

<P>
Although normally you would define a .h file containing an <EM>@interface</EM> for each class, the Portable Object Compiler allows you to use <EM>@implementation</EM> without matching <EM>@interface</EM> :

<P>
<BLOCKQUOTE>
<PRE>
@implementation MyClass : Object { id ivar; }
+ new { self = [super new]; ivar = [String new]; return self; }
@end
</PRE></BLOCKQUOTE>
<P>
The compiler is warning you if it can't find an interface declaration.  You can suppress the warning by using the <EM>-w</EM> flag.

<P>

<H1><A NAME="SECTION00520000000000000000">
Classes</A>
</H1>

<P>
Classes are implemented in the Portable Object Compiler as global variables.  There is a slight (implementation) difference in the <TT>-dynamic</TT> case, but the semantics are the same.

<P>
Unlike some other compilers, but like the original Stepstone compiler, class names are ordinary expressions.  Usually a class will be receiver of a message (a factory method), but it is possible to use classnames as arguments as well (in the Portable Object Compiler) :

<P>
<BLOCKQUOTE>
<PRE>
[[ Set inheritsFrom: Object ] ifTrue: { printf("yes"); } ];
</PRE></BLOCKQUOTE>
<P>
For writing completely portable code, that also compiles on older or less powerful O<SMALL>BJECTIVE-</SMALL>C compilers, you might want to write:

<P>
<BLOCKQUOTE>
<PRE>
[[ Set inheritsFrom:[Object self] ] ifTrue: { printf("yes"); } ];
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00530000000000000000">
Messages</A>
</H1>
(to be completed)

<P>

<H1><A NAME="SECTION00540000000000000000">
Blocks</A>
</H1>
(to be completed)

<P>

<H1><A NAME="SECTION00600000000000000000">
Runtime</A>
</H1>

<P>

<H1><A NAME="SECTION00610000000000000000">
Boehm Garbage Collection</A>
</H1>

<P>
The <EM>-boehm</EM> option option simply sets the function vectors for allocating memory to the <EM>malloc()</EM> functions of the Boehm <EM>gc</EM> package.  Except for some initialization code emitted for the <EM>main()</EM> of your program, there's no difference in code generation, so this is in fact a runtime issue.  You have to recompile however the runtime with the Boehm library.

<P>
<BLOCKQUOTE>
<PRE>
objc -boehm main.m
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00620000000000000000">
Reference Counted Garbage Collection</A>
</H1>

<P>
The <EM>-refcnt</EM> (or <EM>-gc</EM>) flag selects a different kind of garbage collection to be used : it instructs the compiler to generate reference counting code, and links a version of the runtime that supports reference counting.

<P>
<BLOCKQUOTE>
<PRE>
objc -gc main.m
</PRE></BLOCKQUOTE>
<P>
This option also causes a different runtime to be used, and it forces assignments to <EM>id variables</EM> to be translated to calls to the runtime function <EM>idassign()</EM>.  This function modifies the reference count of the objects in the assignment.

<P>
By defining a variable as <EM>volatile</EM> it is possible to prevent reference count code to be used.

<P>
<BLOCKQUOTE>
<PRE>
volatile id myObject;
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00630000000000000000">
Selectors</A>
</H1>

<P>
One mistake, when using the method <TT>perform:</TT>, is to assume that Selectors (of type SEL) are compatible with C Strings (of type STR).  This is not the case.  Selectors are <EM>uniqued</EM> strings, maintained by the runtime in a hashtable.  The messenger assumes that equal selectors are also pointer equal.

<P>
The function <EM>cvtToSel</EM> in the runtime is used to convert a string to a selector.  This function should <EM>not</EM> be used (it is static) because some other O<SMALL>BJECTIVE-</SMALL>C runtimes use a function of the same name, which might, in a mixed environment, give problems.  You can use @selector or the method <TT>findSel:</TT>.

<P>
<BLOCKQUOTE>
<PRE>
SEL aSel = [Object findSel:"foo"];
if (aSel) [myCltn makeElementsPerform:aSel];
</PRE></BLOCKQUOTE>
<P>
Note that in many cases, a clean (and much more powerful) solution is to use a Block, instead of just a selector:

<P>
<BLOCKQUOTE>
<PRE>
[myCltn do: { :each | [each foo]; }];
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00640000000000000000">
Sending Messages to Nil</A>
</H1>

<P>
The <EM>-noNilRcvr</EM> option can be used to prevent messages being sent to nil (the NULL pointer).  It is in fact a runtime option, since the only effect of this option is that, when the <EM>main()</EM> of the program is compiled with this option, a nilHandler() function will be registered that stops the process, instead of simply returning nil (as the default handler does).

<P>
<BLOCKQUOTE>
<PRE>
objc -noNilRcvr main.m
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00650000000000000000">
Message Tracing</A>
</H1>

<P>
It's possible to use the global <EM>msgFlag</EM> to turn message tracing on and off.  Trace messages are written to <EM>msgIOD</EM>, which is normally set to <EM>stderr</EM>, unless the environment variable <EM>OBJCRTMSG</EM> is set to some filename, in which case that file is used.

<P>
<BLOCKQUOTE>
<PRE>
setenv OBJCRTMSG "/tmp/trace"
</PRE></BLOCKQUOTE>
<P>
Maybe the file should be opened in append mode (currently the file just overwrites the existing file).  An easy way to prevent users to trace executables, is to set msgFlag to NO after runtime initialization (so that the OBJCRTMSG env.variable has no effect).

<P>

<H1><A NAME="SECTION00660000000000000000">
Initialization</A>
</H1>

<P>

<H2><A NAME="SECTION00661000000000000000">
General</A>
</H2>

<P>
Runtime initialization is one of the more complex aspects of O<SMALL>BJECTIVE-</SMALL>C compilers.  Whenever the program launches, or whenever a dynamical library is loaded, it is necessary to make method selectors unique and to send <TT>+initialize</TT> messages to classes.

<P>
The Portable Object Compiler, like the Stepstone compiler, guarantuees that every class receives a <TT>+initialize</TT> message at start-up, during runtime initialization, and before the user program starts sending messages.

<P>
There are two different strategies implemented for runtime initialization, <EM>postlink initialization</EM> and <EM>automatic initialization</EM>.  Whatever method is used, initialization works by processing an array <TT>objcModules</TT> which contains pointers to class structures in each module (object file).

<P>
The difference between the two methods is, how they construct the <TT>objcModules</TT> array.

<P>
A third method, which has not yet been done so far for the Portable Object Compiler, since it is totally unportable, would be to modify the link editor, or to use link editor specific features, for O<SMALL>BJECTIVE-</SMALL>C runtime initialization.

<P>

<H2><A NAME="SECTION00662000000000000000">
Postlink</A>
</H2>

<P>
The <EM>postlink</EM> method constructs the <TT>objcModules</TT> array at compile time.   A small utility program, also called <EM>postlink</EM>, is used for this.

<P>
The <EM>postlink</EM> program takes as input a link map (or the output of the UNIX <TT>nm</TT> command) and writes to the <TT>stdout</TT> a C program that defines the <TT>objcModules</TT> array.

<P>
This file, automatically generated by the compiler, is then compiled and linked into the program, using a second link.

<P>
The name <EM>postlink</EM> comes from the fact that the <TT>objcModules</TT> is generated, at compile time, after a first link.

<P>

<H2><A NAME="SECTION00663000000000000000">
Automatic</A>
</H2>

<P>
The automatic runtime initialization strategy constructs the <TT>objcModules</TT> pointer at runtime, and requires only a single link.

<P>
This strategy depends on some compiler support, where for each function that is being called in a <EM>.m</EM> source file, an <EM>OCU</EM> entry is generated (OCU stands for O<SMALL>BJECTIVE-</SMALL>C use).

<P>
At runtime, the <TT>objcModules</TT> array is constructed by traversing the tree of dependencies, starting with the <EM>OCU_main</EM> entry, for the <EM>main()</EM> function. 

<P>
Automatic runtime initialization is slightly less portable than <EM>postlink</EM>.  It is however up to 30% faster during linking of larger executables, and has little overhead in space and time compared to <EM>postlink</EM>.  Most UNIX drivers are configured for automatic runtime initialization, but allow you to use the <TT>-postlink</TT> option to change runtime initialization procedure, which is the safest strategy.

<P>

<H3><A NAME="SECTION00663100000000000000">
Note on portability</A>
</H3>

<P>
The <EM>default</EM> configuration for our compiler drivers is for <EM>automatic initialization</EM> on all UNIX platforms, on OS/2 and on Windows with the Microsoft compiler.  On other platforms (Macintosh, some non-Microsoft C compilers on Windows) the default is to use <EM>postlink initialization</EM>, because it is the only alternative.

<P>
This is because our implementation of automatic runtime initialization depends on the availability of an ANSI C compiler that follows the so-called <EM>common storage</EM> linker model (see Appendix 10.6 in [#!Kernighan88!#]).

<P>
Specifically, for the automatic runtime code to work, the C compiler is supposed to place <EM>uninitialized</EM> global variables in a segment, called the <EM>common segment</EM>, as opposed to placing them immediately, per translation unit, in the <EM>bss segment</EM> (the runtime segment of uninitialized globals).

<P>
Examples of compilers that do this by default : GNU cc, Sun acc, HP-UX cc, DEC cc, Microsoft cl, IBM icc and AIX cc.   Some compilers don't do it by default, but have an option for it, such as the SGI cc or MIPSpro cc.  And finally, examples of C compilers that provide the definition-reference model only : Metrowerks mwcc, WATCOM wcc. 

<P>
For the interesting history of this issue, see [#!Lapin87!#], a book that contains a discussion on how this C language feature was removed from the C compiler in some UNIX dialects, and how it then reappeared.

<P>
In any case, our <EM>postlink</EM> alternative, which works for <EM>both</EM> common storage <EM>and</EM> other linkage models (such as definition-reference and perhaps other models), even when it might be considerably slower for linking larger applications, is useful because it might be the only alternative for C compilers that do not provide a switch for the <EM>common storagel</EM> model. 

<P>
C<SMALL>ONCLUSION:</SMALL> the <EM>postlink</EM> approach works everywhere and is conceptually most portable; however, <EM>if</EM> your compiler supports the common storage model, it's best to configure our compiler driver to take advantage of this, and use the <EM>automatic initialization</EM> approach.

<P>

<H1><A NAME="SECTION00670000000000000000">
Threads</A>
</H1>

<P>
By default, the runtime of the Portable Object Compiler is not thread-safe.  It can be made thread-safe, however, by compiling the main() of the program with <EM>-pthreads</EM>.

<P>
<BLOCKQUOTE>
<PRE>
objc -pthreads -q main.m
</PRE></BLOCKQUOTE>
<P>
This will force the compiler to link against the <EM>libpthreads</EM> library, and use locks around the O<SMALL>BJECTIVE-</SMALL>C messenger.

<P>

<H1><A NAME="SECTION00700000000000000000">
Compiler</A>
</H1>

<P>

<H1><A NAME="SECTION00710000000000000000">
Testing for Portable Object Compiler</A>
</H1>

<P>
Sometimes, it is necessary to test for the compiler that is compiling a program.  It is much better to write O<SMALL>BJECTIVE-</SMALL>C code that works for all O<SMALL>BJECTIVE-</SMALL>C compilers, but in cases where compiler dependencies cannot be avoided, it is possible to test for the Portable Object Compiler by using the <TT>__PORTABLE_OBJC__</TT> symbol :

<P>
<BLOCKQUOTE>
<PRE>
#ifdef __PORTABLE_OBJC__
	msgFlag = YES;
#endif
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00720000000000000000">
Compiling C++</A>
</H1>

<P>
Because the Portable Object Compiler compiles O<SMALL>BJECTIVE-</SMALL>C into C, and because C++ is a C extension, C++ compilers can sometimes be used to compile the output of Portable Object Compiler.  The option <TT>-cplus</TT> can be used to use the Portable Object Compiler in C++ mode and to make it produce intermediate code that is suitable for compilation by a C++ compiler.

<P>
<BLOCKQUOTE>
<PRE>
objc -cplus foo.m
</PRE></BLOCKQUOTE>
<P>
The C++ back-end of the Portable Object Compiler is not as widely used as the C back-end, and might therefore still be incomplete.  In fact, it has only been used with GNU C++, IRIX CC and HP-UX CC up to now.  However, users have successfully compiled programs that mix the C++ <EM>STL</EM> (Standard Template Library) or C++ GUI libraries, and O<SMALL>BJECTIVE-</SMALL>C.

<P>

<H1><A NAME="SECTION00730000000000000000">
Assignments to self</A>
</H1>

<P>
The <EM>-noSelfAssign</EM> option can be used to prevent assignments to the <EM>self</EM> pointer inside method definitions.

<P>
<BLOCKQUOTE>
<PRE>
objc -c -noSelfAssign foo.m
</PRE></BLOCKQUOTE>
<P>
By default, the compiler allows you to assign values to <EM>self</EM>.

<P>

<H1><A NAME="SECTION00740000000000000000">
Inline Cache</A>
</H1>

<P>
The <EM>-inlineCache</EM> option can be used to speed up the messenger.  For each message expression, the compiler will generate a one-slot cache to store the resulting IMP pointer for the method look-up.  In many cases, subsequent method-lookups are not needed any more.

<P>
<BLOCKQUOTE>
<PRE>
objc -c -inlineCache foo.m
</PRE></BLOCKQUOTE>
<P>
This option is not the default.  It trades in speed for flexibility.  It will give, for example, incorrect results when tracing messages (with the msgFlag option).

<P>

<H1><A NAME="SECTION00750000000000000000">
Speeding up compiles</A>
</H1>

<P>

<H2><A NAME="SECTION00751000000000000000">
Binary driver</A>
</H2>

<P>
You can win a few seconds, by using the binary driver instead of the Bourne shell driver on UNIX :

<P>
<BLOCKQUOTE>
<PRE>
configure -e OBJCC=objc.exe
</PRE></BLOCKQUOTE>
<P>
This will set up Makefiles that use objc.exe instead of objc.  How much you win, depends on the quality of the /bin/sh interpreter that your system uses to interpret the <EM>objc</EM> script.  If this is a modern, fast implementation, then using the binary driver <EM>objc.exe</EM> will not be a big win.

<P>

<H2><A NAME="SECTION00752000000000000000">
Temporary Files</A>
</H2>

<P>
Compiles can be made substantially faster by using a directory for temporary files that is located on a local disk (as opposed to some NFS mounted volume).

<P>
<BLOCKQUOTE>
<PRE>
export OBJCOPT=-T/tmp/
</PRE></BLOCKQUOTE>
<P>
This will place temporary files in /tmp.  The Portable Object Compiler is ideal software for kernels that allow memory mapped files (the <EM>mfs</EM> filesystem on BSD UNIX for instance), since the temporary files generated by the compiler, are normally immediately removed after being created.

<P>

<H2><A NAME="SECTION00753000000000000000">
C Compiler Backend</A>
</H2>

<P>
Finally, consider using appropriate flags for your C compiler, since normally most time is spent in processing the <EM>output</EM> of the Portable Object Compiler (the translated sources).

<P>
<BLOCKQUOTE>
<PRE>
export CC=lcc
export CPP="lcc -E"
</PRE></BLOCKQUOTE>
<P>
It might be worthwhile to try out several compilers, some are better for producing tight, optimized executables, some compile simply faster (while producing less optimized object code).

<P>

<H1><A NAME="SECTION00800000000000000000">
Link Editor</A>
</H1>

<P>

<H1><A NAME="SECTION00810000000000000000">
Static Libraries</A>
</H1>

<P>
There's no special compiler option for building static libraries.  

<P>
Static libraries can be, regardless of whether the object files are compiled with <TT>-postlink</TT> or <TT>-noPostLink</TT>, combined with the usual tools, <EM>ld</EM>, <EM>ar</EM>, <EM>ranlib</EM> etc. 

<P>
Of course the same rules apply to static libraries as for ordinary object files; for example, a static library compiled with <TT>-postlink</TT> can later not be used with automatic runtime initialization.  The UNIX driver would issue a warning for this (the Windows driver is configured for postlink anyhow). 

<P>

<H1><A NAME="SECTION00820000000000000000">
O<SMALL>BJECTIVE-</SMALL>C and Dynamic Libraries</A>
</H1>

<P>
O<SMALL>BJECTIVE-</SMALL>C is well suited for development of dynamic libraries.  O<SMALL>BJECTIVE-</SMALL>C messages always work through a centralized message dispatcher, which means that messages are bound to implementations only at runtime.  In the case of dynamic libraries, there is no problem of <EM>undefined references</EM>, as long as you remember to resolve <EM>classnames</EM> (typically implemented as global variables) via the <TT>findClass:</TT> or <TT>findClass:</TT> methods.

<P>
<BLOCKQUOTE>
<PRE>
id aClass = [Object findClass:"MyClass"];
if (aClass) [[aClass new] doSpecificMethod];
</PRE></BLOCKQUOTE>
<P>
There will be no unresolved reference to <EM>MyClass</EM>, nor to <TT>doMyClassSpecificMethod</TT>.  

<P>
In other words, the O<SMALL>BJECTIVE-</SMALL>C syntax for working with classes and methods loaded in at runtime, is, with the exception of the use of <TT>findClass:</TT>, the same as for statically linked libraries (or for shared libraries with an import library).  There's no need to use functions such as <TT>dlsym()</TT> to obtain the methods.

<P>

<H1><A NAME="SECTION00830000000000000000">
UNIX</A>
</H1>

<P>

<H2><A NAME="SECTION00831000000000000000">
Dynamic Libraries</A>
</H2>

<P>
A dynamic library is an object file that can be loaded into a running O<SMALL>BJECTIVE-</SMALL>C program.

<P>
Dynamic libraries need to be compiled as follows :

<P>
<BLOCKQUOTE>
<PRE>
objc -c -pic foo.m
objc -c -pic bar.m
objc -dl foo.o bar.o -o pkg.so
</PRE></BLOCKQUOTE>
<P>
The <TT>-pic</TT> option indicates that we want to produce Position Independent Code.   The <TT>-dl</TT> option instructs the compiler to generate a table of modules to be initialized, to be used by the runtime when the dynamic library is loaded.

<P>
Programs that possibly load such dynamical libraries, must be compiled with <TT>-dynamic</TT>.  On some systems, the symbols of the program must be marked as exportable to the dynamic library.

<P>
<BLOCKQUOTE>
<PRE>
objc -dynamic main.m -o main
</PRE></BLOCKQUOTE>
<P>
On HP-UX,

<P>
<BLOCKQUOTE>
<PRE>
h = shl_load(path, BIND_IMMEDIATE, 0L);
if (!h) [Object error:strerror(errno)];
</PRE></BLOCKQUOTE>
<P>
On SunOS or Linux,

<P>
<BLOCKQUOTE>
<PRE>
h = dlopen(path, 1);
if (!h) [Object error:dlerror()];
</PRE></BLOCKQUOTE>
<P>
Once the package is loaded, classes (defined in the dynamic library) can be found by the usual methods :

<P>
<BLOCKQUOTE>
<PRE>
aClass = [Object findClass:"MyClass"];
anObject = [aClass new];
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00832000000000000000">
Shared Libraries</A>
</H2>

<P>
Since release 1.7.5 of the compiler, shared libraries are dealt with in the same way as dynamically loaded libraries.  

<P>
There's no difference in building a shared library or a dynamically loaded library :

<P>
<BLOCKQUOTE>
<PRE>
objc -c -pic foo.m
objc -c -pic bar.m
objc -dl foo.o bar.o -o pkg.so
</PRE></BLOCKQUOTE>
<P>
The only difference is that shared libraries are specified on the command line, rather than explicitely being loaded by the program:

<P>
<BLOCKQUOTE>
<PRE>
objc -dynamic main.m pkg.so -o myprogram
</PRE></BLOCKQUOTE>
<P>
Note that programs that possibly load such dynamical libraries, must be compiled with <TT>-dynamic</TT>.  On some systems, the symbols of the program must be marked as exportable to the dynamic library.

<P>
The <TT>-static</TT> option can be used to prevent linking against shared libraries.

<P>
Prior to 1.7.5, the strategy was to use some sort of <EM>import library</EM>, which was, on UNIX, simply the same library, built as a static library.

<P>
Import libraries are still supported for systems that do not support initializers in shared objects using the <TT>-stubLib</TT> and <TT>-realLib</TT> options, but the disadvantage of that approach is that whenever the shared library is updated, the stub library needs to be updated too, and the program that links against the shared library should be recompiled.   

<P>

<H2><A NAME="SECTION00833000000000000000">
objpak_s.a and objcrt_s.a</A>
</H2>

<P>
The shared library versions of the libraries <TT>objcrt.a</TT> and <TT>objpak.a</TT> can be named <EM>objpak_s.a</EM> and <EM>objcrt_s.a</EM> and the driver will automatically select these libraries, when given the <EM>-dynamic</EM> flag.

<P>
To build the libraries, simply go to the source directory of those libraries, and type (for example, for <TT>objpak.a</TT>) :

<P>
<BLOCKQUOTE>
<PRE>
cd src/objpak
setenv OBJCOPT -pic
make
objc -dl *.o -o objpak_s.a
</PRE></BLOCKQUOTE>
<P>
If you now install this version of <TT>objpak_s.a</TT>, the compiler driver will link against a shared library when given the <EM>-dynamic</EM> flag.  

<P>
The procedure for objcrt_s.a is identical; it's possible to switch between static objcrt.a and shared objcrt_s.a.

<P>

<H1><A NAME="SECTION00840000000000000000">
Windows</A>
</H1>

<P>

<H2><A NAME="SECTION00841000000000000000">
Building a DLL</A>
</H2>

<P>
Building a DLL (for WIN32) is similar as for shared libraries on UNIX, but there is an extra step involved.

<P>
You need to build a Windows <EM>import library</EM> (to use the DLL).  This is a <TT>.lib</TT> library that references the <TT>.dll</TT>.  The import library, not the .dll itself, is specified on the command line, when linking against the .dll.

<P>
Compile the DLL as follows.  The PIC flag translates to <TT>-bd -br</TT> using the WATCOM driver, and also adds a <TT>-dllexport</TT> flag, to emit <TT>dllexport</TT> directives in front of generated O<SMALL>BJECTIVE-</SMALL>C BIND functions, to export them from the DLL.

<P>
<BLOCKQUOTE>
<PRE>
objc -c -pic foo.m
objc -c -pic bar.m
objc -dl foo.obj bar.obj -o pkg.dll
</PRE></BLOCKQUOTE>
<P>
The <EM>-dl</EM> option adds an approriate <EM>LibMain()</EM> function.  It's <EM>essential</EM> that this function is in the DLL, since it initializes the O<SMALL>BJECTIVE-</SMALL>C classes in the archive.

<P>
Now, install pkg.dll somewhere on the <TT>PATH</TT>, e.g. in <TT>C:&#92;OBJC&#92;BIN</TT>. 

<P>
Next, build a (Windows) <EM>import library</EM> for the DLL.   This is done as for a regular C DLL :

<P>
For WATCOM:,

<P>
<BLOCKQUOTE>
<PRE>
wlib -n pkg.lib +pkg.dll
</PRE></BLOCKQUOTE>
<P>
For lcc-win32:,

<P>
<BLOCKQUOTE>
<PRE>
buildlib pkg.lib pkg.exp pkg.dll
</PRE></BLOCKQUOTE>
<P>
Finally, to use the DLL, just specify the import library and use -dynamic.  If you do not specify -dynamic, you will get undefined references.

<P>
<BLOCKQUOTE>
<PRE>
objc -dynamic main.m pkg.lib -o main.exe
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00842000000000000000">
Dynamically loading DLL's</A>
</H2>

<P>
It is also possible to use the <EM>LoadLibrary</EM> function call to load in an O<SMALL>BJECTIVE-</SMALL>C DLL.  The DLL will automatically initialize the classes that it contains.

<P>
To avoid including windows.h, you can have a .c file with a dlopen() definition:

<P>
<BLOCKQUOTE>
<PRE>
int dlopen(char *name,int x) { return LoadLibrary(name) &lt; 32; }
</PRE></BLOCKQUOTE>
<P>
And in O<SMALL>BJECTIVE-</SMALL>C you simply do:

<P>
<BLOCKQUOTE>
<PRE>
if (!dlopen("foo.dll",1)) [Object error:"can't load foo.dll"];

[[Object findClass:"FooClass"] new];
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00843000000000000000">
OBJCRT.DLL</A>
</H2>

<P>
There is a prebuilt binary available of the DLL at the website.  The import library can be called <EM>objcrt_s.lib</EM> and the driver will select this library when given the <EM>-dynamic</EM> option.

<P>
The flags to correctly build the DLL, are:

<P>
<BLOCKQUOTE>
<PRE>
set OBJCOPT=-pic -DOBJCRTDLL
</PRE></BLOCKQUOTE>
<P>
The .dll needs to be built with:

<P>
For Watcom:

<P>
<BLOCKQUOTE>
<PRE>
wmake -u -c
objc -dl objcrt.obj Object.obj Block.obj -o objcrt.dll
wlib -n objcrt_s.lib +objcrt.dll
</PRE></BLOCKQUOTE>
<P>
For lcc-win32:

<P>
Edit the Makefile as follows: <BLOCKQUOTE>
<PRE>
MFLAGS=$(DLL_MFLAGS)
ALL : $(DLL)
</PRE></BLOCKQUOTE>
<P>
Then run make.

<P>

<H2><A NAME="SECTION00844000000000000000">
OBJPAK.DLL</A>
</H2>

<P>
There is a prebuilt binary available of the DLL at the website.  The import library can be called <EM>objpak_s.lib</EM> and the driver will select this library when given the <EM>-dynamic</EM> option.

<P>
The flags to correctly build the DLL, are:

<P>
<BLOCKQUOTE>
<PRE>
set OBJCOPT=-pic
</PRE></BLOCKQUOTE>
<P>
The .dll needs to be built with:

<P>
<BLOCKQUOTE>
<PRE>
wmake -u -c
objc -dl @objpak.lnk
wlib -n objpak +objpak.dll
</PRE></BLOCKQUOTE>
<P>
where objpak.lnk is a file containing the commands:

<P>
<BLOCKQUOTE>
<PRE>
ascfiler.obj assoc.obj
cltn.obj cltnseq.obj 
dictnary.obj keyseq.obj 
ocstring.obj point.obj 
rectangl.obj sequence.obj 
set.obj setseq.obj tree.obj 
treeseq.obj valueseq.obj -o objpak.dll
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00900000000000000000">
Other Development Tools</A>
</H1>

<P>

<H1><A NAME="SECTION00910000000000000000">
Editors</A>
</H1>

<P>

<H2><A NAME="SECTION00911000000000000000">
ctags</A>
</H2>

<P>
ctags is a utility to generate a <EM>tags</EM> file, used by editors such as <EM>vi</EM> or <EM>vim</EM>, for their tag feature.  The command <EM>:ta</EM> jumps to the line (and file) that defines the given tag.

<P>
ctags.awk is a version of an AWK implementation of ctags, that was modified to deal with O<SMALL>BJECTIVE-</SMALL>C.   It works with <EM>nawk</EM>, <EM>mawk</EM> and <EM>gawk</EM>.  If you use <EM>gawk</EM>, it's recommended to place the file in some location that is in the AWKPATH (so that gawk will find the file).

<P>
<BLOCKQUOTE>
<PRE>
gawk -f ctags.awk file.m &gt; tags
</PRE></BLOCKQUOTE>
<P>
For each O<SMALL>BJECTIVE-</SMALL>C class implementation, a tag of the same name is generated.

<P>
<BLOCKQUOTE>
<PRE>
:ta String
</PRE></BLOCKQUOTE>
<P>
for instance, will jump to the file that defines the String class.

<P>
For each method implementation, two tags are generated : one which is simply the first keyword of the selector, and also a tag which is the full selector name.

<P>
<BLOCKQUOTE>
<PRE>
:ta -remove:ifAbsent:
</PRE></BLOCKQUOTE>
<P>
would jump for instance to the instance method of the same name.  The tag which consists of just the first keyword, is so that the <EM>Control-]</EM> and <EM>Control-t</EM> mechanism of <EM>vi</EM> also works for methods.

<P>

<H2><A NAME="SECTION00912000000000000000">
vim</A>
</H2>

<P>
vim is a popular <EM>vi</EM> clone.  For editing O<SMALL>BJECTIVE-</SMALL>C code, it's possible to add `[' to `cinwords' in the <EM>.vimrc</EM> file; indeed, when `[' is followed by a `{', you are most likely editing a Block expression.

<P>
<BLOCKQUOTE>
<PRE>
set smartindent
set cinwords=if,else,while,do,for,switch,[
set showmatch
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00913000000000000000">
elvis</A>
</H2>

<P>
ELVIS is a <EM>vi</EM> clone with extensive support for tags.  The <EM>ctags.awk</EM> program that comes with the Portable Object Compiler, supports ELVIS hints, which makes it possible to browse through all classes that implement a certain method :

<P>
<BLOCKQUOTE>
<PRE>
:browse -reject:ifNone:
</PRE></BLOCKQUOTE>
<P>
would show, for example, a list of all classes that implement <TT>-reject:ifNone:</TT>, so that it's possible to select (from a table that ELVIS shows) the implementation that you want to see.

<P>
It's also possible to jump in ELVIS immediately to a method of a specific class, like in:

<P>
<BLOCKQUOTE>
<PRE>
:tag +new class@MyClass
</PRE></BLOCKQUOTE>
<P>
which would bring you to the implementation of <TT>+new</TT> in <EM>MyClass</EM>.

<P>
ELVIS has an O<SMALL>BJECTIVE-</SMALL>C language mode (for syntax highlighting) and recognizes files with a <EM>.m</EM> extension.

<P>

<H2><A NAME="SECTION00914000000000000000">
emacs</A>
</H2>

<P>
I've never used the following package, but I know that there exists an Objective-C mode for <EM>emacs</EM>.  Available at, for example, <TT>ftp.uni-mainz.de</TT> in the directory <TT>/pub/gnu/elisp-archive/modes/objective-C-mode.el.gz</TT>.

<P>

<H2><A NAME="SECTION00915000000000000000">
indent</A>
</H2>

<P>
There is a patch available (included with the compiler) for GNU indent 1.9.1, so that it works with O<SMALL>BJECTIVE-</SMALL>C.  This can be used to format O<SMALL>BJECTIVE-</SMALL>C programs using the various, commonly used indentation styles.  The compiler sources are indented with the following settings :

<P>
<BLOCKQUOTE>
<PRE>
-kr -psl -i2 -bad -Tid -TBOOL -TSEL -TSTR
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00920000000000000000">
Debuggers</A>
</H1>

<P>

<H2><A NAME="SECTION00921000000000000000">
Symbolic Representation of Objects</A>
</H2>

<P>
To print an ASCII representation of an (arbitrary) Object, do something like :

<P>
<BLOCKQUOTE>
<PRE>
call __showOn(cltn,0)
</PRE></BLOCKQUOTE>
<P>
This uses the AsciiFiler class, to dump the instance variables of some object <EM>cltn</EM> to the stderr.

<P>
For example, for a collection containing one String instance, you'd get:

<P>
<BLOCKQUOTE>
<PRE>
(gdb) call __showOn(cltn,0)
#AsciiFiler i144 
1 #OrdCltn i1 @2 
2 #String i11 i12 *11"hello world 
$1 = 86080
</PRE></BLOCKQUOTE>
<P>
The first column is a number, then follows the classname, then (for a OrdCltn) the number of elements, then pointers towards the Objects that the collection contains.  In this case, the collection contains a String of 11 characters.

<P>

<H2><A NAME="SECTION00922000000000000000">
Message Tracing in gdb</A>
</H2>

<P>
For message tracing from withing the debugger, it's useful to have the following definitions in a <EM>.gdbinit</EM> file:

<P>
<BLOCKQUOTE>
<PRE>
# message tracing

document showmsg
turn on Objective-C message tracing
end

document stopmsg
turn off Objective-C message tracing
end

define stopmsg
set var msgFlag = 0
end

define showmsg
set var msgFlag = 1
end
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00923000000000000000">
Setting breakpoints</A>
</H2>

<P>
One way to set break-points on an O<SMALL>BJECTIVE-</SMALL>C method, which should work by the way with any C debugger (not just gdb), is to ``fabricate'' the name of the translated function yourself:

<P>
<BLOCKQUOTE>
<PRE>
(gdb) br c_String_new
Breakpoint 1 at 0x6eac
</PRE></BLOCKQUOTE>
<P>
would set a breakpoint on the (class) method ``new'' of the class ``String''.  For instance methods, the prefix is ``i'' instead of ``c''.

<P>
This might also be useful, as some means of sending a message from within an ordinary (and arbitrary) C debugger:

<P>
<BLOCKQUOTE>
<PRE>
(gdb) p i_OrdCltn_size(cltn,0)
$1 = 1
</PRE></BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00924000000000000000">
WATCOM wd and wdw</A>
</H2>

<P>
O<SMALL>BJECTIVE-</SMALL>C source files are compatible with the <EM>wd</EM> debugger (or <EM>wdw</EM>, the windowed debugger), and it is possible to step through O<SMALL>BJECTIVE-</SMALL>C source, set breakpoints with the mouse on specific O<SMALL>BJECTIVE-</SMALL>C method implementations etc.

<P>
<BLOCKQUOTE>
<PRE>
objc -d3 -c test.m -o test.obj
objc -d3 test.obj -o test.exe
wd test.exe
</PRE></BLOCKQUOTE>
<P>
to debug a sample project.

<P>

<H1><A NAME="SECTION00930000000000000000">
Integrated Development Environment</A>
</H1>

<P>

<H2><A NAME="SECTION00931000000000000000">
WATCOM IDE</A>
</H2>

<P>
The files <EM>ide.cfg</EM> and <EM>idew32.cfg</EM> have been modified so that automatic makefile generation works for O<SMALL>BJECTIVE-</SMALL>C source files.  The IDE also offers the possibility to create an O<SMALL>BJECTIVE-</SMALL>C DLL or executable, when starting a new project.

<P>

<H1><A NAME="SECTION00940000000000000000">
gprof</A>
</H1>

<P>
The compiler driver has a <EM>-pg</EM> option to support <EM>gprof</EM> program profiles.  The driver will also attempt to link against <EM>objcrt_p.a</EM> and <EM>objpak_p.a</EM>, if it can find them, when compiling with <EM>-pg</EM>.

<P>
<BLOCKQUOTE>
<PRE>
objc -pg myprogram.m -o myprogram
myprogram
gprof myprogram gmon.out &gt; myprofile
</PRE></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00950000000000000000">
purify</A>
</H1>

<P>
The compiler was verified to work with <EM>purify</EM> on Silicon Graphics machines.  Add the command <EM>purify</EM> before the normal commands to compile, and the purify driver recognizes <EM>objc</EM> as compiler, and the <EM>-o</EM> flag for producing a <EM>.pure</EM> executable.

<P>
<BLOCKQUOTE>
<PRE>
purify objc -g myprogram.m -o myprogram
</PRE></BLOCKQUOTE>
<P>
When running the executable produced in this way, memory leak and memory allocation information is obtained as for normal C programs.

<P>
2
<BR><HR>
<ADDRESS>
<I>David Stes</I>
<BR><I>2003-10-13</I>
</ADDRESS>
</BODY>
</HTML>
