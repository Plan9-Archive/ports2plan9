#!/bin/sh
#
# Ksh variant edited to be run under the Plan9 APE "sh" (pdksh) shell
# Default compiler changed to "pcc"
# A number of checks requiring utilities or utility options not existing on Plan9 have been removed.
#
# references to dynamic linking have been removed (dlfcn.h, dlerror).
# LDFLAGS have been forced to be empty, for now....
#
# missing the function strndup in string.h leads to type conflicts ("ind const char" and "int")
# an include of bsd.h is added to get access to strdup 
# change srandom to srand make sure that stdlib.h is included
# make sure stdio.h is included 
#
# ANNOYING DEPENDENCY
# I have not found a good replacement for grep -E so now bacon depends on agrep from TRE
# in order to change to something more reasonable fast, all references to grep are replaced by the variable $GREP
# 
#  ____         ____
# | __ )  __ _ / ___|___  _ __
# |  _ \ / _` | |   / _ \| '_ \
# | |_) | (_| | |__| (_) | | | |   --= A KORN BASIC-to-C converter =--
# |____/ \__,_|\____\___/|_| |_|
#
# Peter van Eerten - March 2009/October 2011. License: GPL version 3.
#
#---------------------------------------------------------------------------------------------------------------------
# CREDITS:
#   - James C. Fuller for endless testing and patiently pointing to many issues
#   - John Spikowksi for giving some hints to improve the language
#   - Vovchik for providing ideas, programs and hints
#
#---------------------------------------------------------------------------------------------------------------------
# GLOBAL INITIALIZATIONS
#---------------------------------------------------------------------------------------------------------------------

# global grep alias for "grep -E" dependent greps
GREP="agrep"

# Version of BACON
typeset -x g_VERSION="1.0 build 24"


# Link flags
g_LDFLAGS=" "

# Global constant for miniparsing
typeset -x g_PARSEVAR=`print "\001"`

# Global to define '$'-replacement
typeset -x g_STRINGSIGN="__b2c__string_var"

# Global to define '"'-symbol
typeset -x g_DQUOTESIGN=`print "\042"`

# Global to define '''-symbol
typeset -x g_SQUOTESIGN=`print "\047"`

#-----------------------------------------------------------

function Print_Element
{
    typeset TARGET CHECK VAR

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    # Check on string by reference variable
    VAR=`print -r ${1%%\(*}`
    CHECK=`$GREP -E "char \*${VAR} = NULL;" ${TARGET} 2>/dev/null`

    # Check if var is string var
    if [[ "${1%%\(*}" = +(*${g_STRINGSIGN}*) || "${1%%\(*}" = +(*${g_DQUOTESIGN}*) || "${1%%\(*}" = +(*gettext*|*ngettext*) || -n ${CHECK} ]]
    then
	print -r "__b2c__assign = ${1}; if(__b2c__assign != NULL) fprintf(stdout, \"%s\", __b2c__assign);" >> $g_CFILE
    else
	print -r "fprintf(stdout, \"%s\", STR${g_STRINGSIGN}(${1}));" >> $g_CFILE
    fi
}

#-----------------------------------------------------------

function Handle_Print
{
    typeset FORMAT EXP LEN TOKEN LINE IN_STRING IN_FUNC CHAR ESCAPED

    IN_FUNC=0

    # If no argument, do nothing
    if [[ "$1" != "PRINT" ]]
    then

	# Get expression without ;
	if [[ -z ${1##*;} ]]
	then
	    let LEN="${#1}"-1
	    typeset -L$LEN EXP="$1"
	else
	    EXP="${1}"
	fi

	# If there is FORMAT/format argument
	if [[ "$EXP" = +(* FORMAT *) ]]
	then
	    FORMAT=${EXP##* FORMAT}
	    print -r "fprintf(stdout, ${FORMAT%%;*}, ${EXP%%FORMAT *});" >> $g_CFILE
	else
	    # Start miniparser, convert spaces
	    LINE=`print -r "${EXP}" | tr " " "\001"`
	    TOKEN=
	    LEN=${#LINE}

	    # Get the characters
	    until [[ $LEN -eq 0 ]]
	    do
		typeset -L1 CHAR="${LINE}"
		case $CHAR in
		    ",")
			if [[ $IN_STRING -eq 0 && $IN_FUNC -eq 0 ]]
			then
			    Print_Element "${TOKEN}"
			    typeset -L0 CHAR=""
			    TOKEN=
			    ESCAPED=0
			fi;;
		    "\\")
			ESCAPED=1;;
		    "\"")
			if [[ $ESCAPED -eq 0 ]]
			then
			    if [[ $IN_STRING -eq 0 ]]
			    then
				IN_STRING=1
			    else
				IN_STRING=0
			    fi
			fi
			ESCAPED=0;;
		    "(")
			if [[ $IN_STRING -eq 0 ]]
			then
			    ((IN_FUNC=$IN_FUNC+1))
			fi
			ESCAPED=0;;
		    ")")
			if [[ $IN_STRING -eq 0 ]]
			then
			    ((IN_FUNC=$IN_FUNC-1))
			fi
			ESCAPED=0;;
		    *)
			ESCAPED=0;;
		esac
		# Convert back to space
		if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
		then
		    TOKEN="${TOKEN} "
		else
		    TOKEN="${TOKEN}${CHAR}"
		fi
		let LEN=${#LINE}-1
		typeset -R$LEN LINE="${LINE}"
	    done
	    Print_Element "${TOKEN}"

	    # If line ends with ';' then skip newline
	    if [[ -n ${1##*;} ]]
	    then
		print -r "fprintf(stdout, \"\n\");" >> $g_CFILE
	    fi
	fi
    else
	print -r "fprintf(stdout, \"\n\");" >> $g_CFILE
    fi

    # Flush buffer
    print -r "fflush(stdout);" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Input
{
    # Local variables
    typeset CHECK VAR TARGET STR LINE LEN IN_STRING IN_FUNC CHAR ESCAPED

    IN_FUNC=0

    # Check if we have an argument at all
    if [[ "$1" = "INPUT" ]]
    then
	print "\nERROR: empty INPUT at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Start miniparser to see if we need to print something, convert spaces
    LINE=`print -r "${1}" | tr " " "\001"`
    VAR=
    LEN=${#LINE}

    # Get the characters
    until [[ $LEN -eq 0 ]]
    do
	typeset -L1 CHAR="${LINE}"
	case $CHAR in
	    ",")
		if [[ $IN_STRING -eq 0 && $IN_FUNC -eq 0 ]]
		then
		    Print_Element "${VAR}"
		    typeset -L0 CHAR=""
		    ESCAPED=0
		    VAR=
		fi;;
	    "\\")
		ESCAPED=1;;
	    "\"")
		if [[ $ESCAPED -eq 0 ]]
		then
		    if [[ $IN_STRING -eq 0 ]]
		    then
			IN_STRING=1
		    else
			IN_STRING=0
		    fi
		fi
		ESCAPED=0;;
	    "(")
		if [[ $IN_STRING -eq 0 ]]
		then
		    ((IN_FUNC=$IN_FUNC+1))
		fi
		ESCAPED=0;;
	    ")")
		if [[ $IN_STRING -eq 0 ]]
		then
		    ((IN_FUNC=$IN_FUNC-1))
		fi
		ESCAPED=0;;
	    *)
		ESCAPED=0;;
	esac
	# Convert back to space
	if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	then
	    VAR="${VAR} "
	else
	    VAR="${VAR}${CHAR}"
	fi
	let LEN=${#LINE}-1
	typeset -R$LEN LINE="${LINE}"
    done

    # Remove spaces in variable
    VAR=`print ${VAR}`

    # Check type of var, string?
    if [[ "${VAR}" = +(*${g_STRINGSIGN}*) ]]
    then
	if [[ ${VAR} != +(*\[*\]*) ]]
	then
	    STR=${VAR%${g_STRINGSIGN}*}
	    CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
	    if [[ -z $CHECK ]]
	    then
		print -r "char *$VAR = NULL;" >> $g_HFILE
	    fi
	fi

	# Translate function to C function
	print -r "__b2c__counter = 1; do{ memset(__b2c__input__buffer, '\0', $g_BUFFER_SIZE);" >> $g_CFILE
	print -r "__b2c__assign = fgets(__b2c__input__buffer, $g_BUFFER_SIZE, stdin);" >> $g_CFILE

	# Make sure internal var is copied to var of program
	print -r "$VAR = (char*)realloc($VAR, ($g_BUFFER_SIZE+1)*__b2c__counter*sizeof(char));" >> $g_CFILE
	print -r "if(__b2c__counter == 1) strncpy($VAR, __b2c__input__buffer, $g_BUFFER_SIZE);" >> $g_CFILE
	print -r "else strncat($VAR, __b2c__input__buffer, $g_BUFFER_SIZE); __b2c__counter++;" >> $g_CFILE
	print -r "} while (!strstr(__b2c__input__buffer, \"\n\") && strlen(__b2c__input__buffer));" >> $g_CFILE
	# Cut off last newline
	print -r "if (strlen(__b2c__input__buffer)) $VAR[strlen($VAR)-1]='\0';" >> $g_CFILE
    # Var is numeric or stringarray
    else
	# Variable may not be array, these should be defined with DECLARE
	if [[ "${VAR}" != +(*\[*\]*) && "${VAR}" != +(*.*) ]]
	then
	    # Not declared? Assume long
	    CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $VAR,| $VAR;|,$VAR,|,$VAR;| $VAR=" | grep -v " noparse "`
	    if [[ -z $CHECK ]]
	    then
		print -r "long $VAR;" >> $g_HFILE
		CHECK="long "
	    fi
	else
	    CHECK=`$GREP -E "DIR |FILE |int |long |float |double |char |void |STRING |NUMBER |FLOATING " $TARGET | $GREP -E " ${VAR%%\[*}" | grep -v " noparse "`
	fi

	# Translate function to C function
	print -r "memset(__b2c__input__buffer, '\0', $g_BUFFER_SIZE); __b2c__assign = fgets(__b2c__input__buffer, $g_BUFFER_SIZE, stdin);" >> $g_CFILE

	# Make sure internal var is copied to var of program
	if [[ "$CHECK" = +(*double *) || "$CHECK" = +(*float *) || "$CHECK" = +(*FLOATING *) ]]
	then
	    print -r "$VAR = atof(__b2c__input__buffer);" >> $g_CFILE
	elif [[ "$CHECK" = +(*long *) || "$CHECK" = +(*NUMBER *) ]]
	then
	    print -r "$VAR = atol(__b2c__input__buffer);" >> $g_CFILE
	else
	    print -r "$VAR = atoi(__b2c__input__buffer);" >> $g_CFILE
	fi
    fi
}

#-----------------------------------------------------------

function Handle_For
{
    # Local variables
    typeset FROM TO TMP VAR STEP CHECK TARGET

    # Get the variablename without (surrounding) spaces
    VAR=`print -r "${1%%=*}" | tr -d "\040"`; TMP=`print -r "${1#*=}"`

    # Do we have a STRING var?
    if [[ "${VAR}" = +(*${g_STRINGSIGN}*) ]]
    then
	print "\nERROR: variable in FOR statement at line $g_COUNTER in file '$g_CURFILE' cannot be string!"
	exit 1
    fi

    # Check if TO is available
    if [[ "$TMP" != +(* TO *) ]]
    then
	print "\nERROR: missing TO in FOR statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the starting and ending value
    FROM=`print -r "${TMP%% TO *}"`
    TO=`print -r "${TMP##* TO }"`

    # Check if there is a STEP
    if [[ "$TO" = +(* STEP *) ]]
    then
	STEP="${TO##* STEP }"
	TO="${TO%% STEP *}"
    else
	STEP=1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Variable may not be array, these should be defined with DECLARE
    if [[ "$VAR" != +(*\[*\]*) && "$VAR" != +(*.*) ]]
    then
	# Declare variable if not done yet, assuming long
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $VAR,| $VAR;|,$VAR,|,$VAR;| $VAR=| ${VAR%%\[*}\[|,${VAR%%\[*}\[" | grep -v " noparse "`
	if [[ -z $CHECK ]]
	then
	    print -r "long $VAR;" >> $g_HFILE
	fi
    fi

    # Translate function to C function
    if [[ "${STEP}" = +(*-*) ]]
    then
	print -r "for($VAR=$FROM; $VAR >= $TO; $VAR+=$STEP){" >> $g_CFILE
    else
	print -r "for($VAR=$FROM; $VAR <= $TO; $VAR+=$STEP){" >> $g_CFILE
    fi
}

#-----------------------------------------------------------

function Handle_While
{
    # Check if DO is available
    if [[ "$1" != +(* DO) ]]
    then
        Parse_Equation "${1}"
    else
        Parse_Equation "${1% *}"
    fi
    print -r "while(${g_EQUATION}){" >> $g_CFILE
}

#-----------------------------------------------------------
# $1: name of ASSOC variable
# $2: name of index
# $3: actual value to assign
# $4: recursion level

function Relate_Recurse
{
    typeset CTR REL LVL

    # Check endless recursion
    LVL=$4; ((LVL+=1))
    if [[ $LVL -gt $g_RELATE_CTR ]]
    then
	print "\nERROR: Endless recursion in RELATE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Now add relation
    CTR=0

    while [[ $CTR -lt $g_RELATE_CTR ]]
    do
	if [[ ${g_RELATE[${CTR}]} = +(${1}*) ]]
	then
	    REL=${g_RELATE[${CTR}]##* }
	    print -r "if(__b2c__${REL}_exist(${2} == NULL)  __b2c__${REL}__add(${2};" >> $g_CFILE
	    if [[ "${REL}" = +(*${g_STRINGSIGN}*) ]]
	    then
		print -r "__b2c__${REL}_exist(${2}->value = realloc(__b2c__${REL}_exist(${2}->value, (strlen($3)+1)*sizeof(char));" >> $g_CFILE
		print -r "strcpy(__b2c__${REL}_exist(${2}->value, $3);" >> $g_CFILE
	    else
		print -r "__b2c__${REL}_exist(${2}->value = $3;" >> $g_CFILE
	    fi
	    Relate_Recurse ${REL} ${2} ${3} ${LVL}
	fi
	((CTR+=1))
    done
}

#-----------------------------------------------------------

function Handle_Let
{
    # Local variables
    typeset VAR CHECK TMP TARGET LEN STR CTR REL PTR

    # Check if there is an asignment at all, if not exit
    if [[ "$1" != +(*=*) ]]
    then
	print "\nERROR: could not parse line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Get the variablename without surrounding spaces
    VAR=`print ${1%%=*}`; TMP=${1#*=}

    # Check if var is string var, exclude RECORD elements
    if [[ "${VAR}" = +(*${g_STRINGSIGN}) && "$VAR" != +(*.*) ]]
    then
	STR=${VAR%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
	if [[ -z $CHECK && $g_PROTOTYPE != +(* ${STR}${g_STRINGSIGN}[ ,\)]*) ]]
	then
	    print -r "char *$VAR = NULL;" >> $g_HFILE
	fi
    # Assume number, exclude RECORD elements
    elif [[ "$VAR" != +(*\[*\]*) && "$VAR" != +(*.*) && "$VAR" != "ERROR" && "$VAR" != +(*\(*\)*) ]]
    then
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $VAR,| $VAR;|\*$VAR |,$VAR,|,$VAR;| $VAR=| ${VAR%%\[*}\[|,${VAR%%\[*}\[|\*$VAR\)" | grep -v " noparse "`
	if [[ -z $CHECK && $g_PROTOTYPE != +(* ${VAR}[ ,\)]*) ]]
	then
	    if [[ "$TMP" = +(*.*) && "$TMP" != +(*$g_DQUOTESIGN*) ]]
	    then
		print -r "double $VAR;" >> $g_HFILE
	    else
		print -r "long $VAR;" >> $g_HFILE
	    fi
	fi
    fi

    # Check if there is associative array assignment
    if [[ "${VAR}" = +(*\(*\)) ]]
    then
	STR=${VAR#*\(}
	print -r "if(__b2c__${VAR%%\(*}_exist(${STR} == NULL) __b2c__${VAR%%\(*}__add(${STR};" >> $g_CFILE
	if [[ "${VAR%%\(*}" = +(*${g_STRINGSIGN}*) ]]
	then
	    print -r "__b2c__${VAR%%\(*}_exist(${STR}->value = realloc(__b2c__${VAR%%\(*}_exist(${STR}->value, (strlen($TMP)+1)*sizeof(char));" >> $g_CFILE
	    print -r "strcpy(__b2c__${VAR%%\(*}_exist(${STR}->value, ${TMP});" >> $g_CFILE
	else
	    print -r "__b2c__${VAR%%\(*}_exist(${STR}->value = ${TMP};" >> $g_CFILE
	fi
	# Check for relations
	Relate_Recurse "${VAR%%\(*}" "${STR}" "${TMP}" "-1"

    # Do we have a STRING variable or STRING array?
    elif [[ "${VAR}" = +(*${g_STRINGSIGN}*) && "${VAR}" != +(*\[*${g_STRINGSIGN}*\]*) ]]
    then
	print -r "__b2c__assign = (char*) strdup ($TMP); ${g_WITHVAR}${VAR} = (char*)realloc(${g_WITHVAR}${VAR}, (strlen(__b2c__assign)+1)*sizeof(char));" >> $g_CFILE
	print -r " strcpy(${g_WITHVAR}${VAR}, __b2c__assign); free(__b2c__assign);" >> $g_CFILE
	# Also check if string var already is used for IMPORT, if so, perform dlopen again
	PTR=`print $VAR | tr -d [:punct:]`
	CHECK=`grep -i "void\* __b2c__dlopen__pointer_$PTR;" $g_CFILE`
	if [[ -n $CHECK ]]
	then
	    print -r "__b2c__dlopen__pointer_$PTR = dlopen($VAR, RTLD_LAZY);" >> $g_CFILE
	fi
    else
	print -r "${g_WITHVAR}${1};" >> $g_CFILE
    fi
}

#-----------------------------------------------------------

function Handle_Open
{
    # Local variables
    typeset FILE MODE HANDLE TMP CHECK TARGET LABEL

    # Check if FOR is available
    if [[ "$1" != +(* FOR *) ]]
    then
	print "\nERROR: Missing FOR in OPEN statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if AS is available
    if [[ "$1" != +(* AS *) ]]
    then
	print "\nERROR: Missing AS in OPEN statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the file, mode and handle
    FILE=`print "${1%% FOR *}"`
    TMP=`print "${1##* FOR }"`

    MODE=`print "${TMP%% AS *}"`
    HANDLE=`print "${TMP##* AS }"`

    # Check if var is string var
    if [[ "${HANDLE}" = +(*${g_STRINGSIGN}) && $MODE != "MEMORY" ]]
    then
	print "\nERROR: Variable for OPEN at line $g_COUNTER in file '$g_CURFILE' cannot be string!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Check if variable was declared
    if [[ "$HANDLE" != +(*.*) ]]
    then
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $HANDLE,| $HANDLE;|,$HANDLE,|,$HANDLE;| $HANDLE=| ${HANDLE%%\[*}\[|,${HANDLE%%\[*}\[" | grep -v " noparse "`
    fi

    # File or dir?
    if [[ $MODE = "DIRECTORY" ]]
    then
	if [[ -z $CHECK ]]
	then
	    print -r "DIR* $HANDLE;" >> $g_HFILE
	fi
    elif [[ $MODE = "MEMORY" ]]
    then
	CHECK=`$GREP -E "char \*${HANDLE}" ${TARGET}`
	if [[ -z $CHECK ]]
	then
	    print -r "char *$HANDLE;" >> $g_CFILE
	fi
	CHECK=`$GREP -E "long" $TARGET | grep "__b2c_mem_$HANDLE;" | grep -v " noparse "`
	if [[ -z $CHECK ]]
	then
	    print -r "long __b2c_mem_$HANDLE;" >> $g_HFILE
	fi
    elif [[ $MODE = "NETWORK" || $MODE = "SERVER" ]]
    then
	if [[ -z $CHECK ]]
	then
	    print -r "int $HANDLE;" >> $g_HFILE
	fi
    else
	if [[ -z $CHECK ]]
	then
	    print -r "FILE* $HANDLE;" >> $g_HFILE
	fi
    fi

    # Convert to C syntax
    case $MODE in
	@(READING) )
	    print -r "$HANDLE = fopen($FILE, \"r\");" >> $g_CFILE
	    print -r "if($HANDLE == NULL){if(!__b2c__trap){ERROR = 2; if(!__b2c__catch_set) {fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE;;
	@(WRITING) )
	    print -r "$HANDLE = fopen($FILE, \"w\");" >> $g_CFILE
	    print -r "if($HANDLE == NULL){if(!__b2c__trap){ERROR = 2; if(!__b2c__catch_set) {fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE;;
	@(APPENDING) )
	    print -r "$HANDLE = fopen($FILE, \"a\");" >> $g_CFILE
	    print -r "if($HANDLE == NULL){if(!__b2c__trap){ERROR = 2; if(!__b2c__catch_set) {fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE;;
	@(READWRITE) )
	    print -r "$HANDLE = fopen($FILE, \"r+\");" >> $g_CFILE
	    print -r "if($HANDLE == NULL){if(!__b2c__trap){ERROR = 2; if(!__b2c__catch_set) {fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE;;
	@(DIRECTORY) )
	    print -r "$HANDLE = opendir($FILE);" >> $g_CFILE
	    print -r "if($HANDLE == NULL){if(!__b2c__trap){ERROR = 2; if(!__b2c__catch_set) {fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE;;
	@(MEMORY) )
	    print -r "$HANDLE = (char*)$FILE; __b2c_mem_$HANDLE = $FILE;" >> $g_CFILE
	    print -r "if(!__b2c__trap){if(__b2c__memory__check($HANDLE)) {ERROR=1; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE;;
	@(NETWORK) )
	    # Network code
	    print -r "if (strstr($FILE, \":\") == NULL) {ERROR = 10; fprintf(stderr, \"ERROR: %s: '%s'\n\", ERR${g_STRINGSIGN}(ERROR), ${FILE}); exit(ERROR);}" >> $g_CFILE
	    print -r "strncpy(__b2c__data_client, $FILE, $g_BUFFER_SIZE); __b2c__host = strtok(__b2c__data_client, \":\"); __b2c__port = strtok(NULL, \":\"); __b2c__he = gethostbyname(__b2c__host);" >> $g_CFILE
	    print -r "if (__b2c__he == NULL || __b2c__he->h_addr == NULL) {if(!__b2c__trap){ERROR = 11;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
	    print -r "$HANDLE = socket(AF_INET, ${g_SOCKTYPE}, 0);" >> $g_CFILE
	    print -r "if ($HANDLE == -1) {if(!__b2c__trap){ERROR = 12;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
	    print -r "__b2c__to.tv_sec = $g_OPTION_SOCKET; __b2c__to.tv_usec = 0; setsockopt($HANDLE, SOL_SOCKET, SO_SNDTIMEO, &__b2c__to, sizeof(struct timeval));" >> $g_CFILE
            if [[ ${g_NETWORKTYPE} = "BROADCAST" ]]
	    then
		print -r "setsockopt($HANDLE, SOL_SOCKET, SO_BROADCAST, &__b2c__yes, sizeof(int));" >> $g_CFILE
	    elif [[ ${g_NETWORKTYPE} = "MULTICAST" ]]
	    then
		print -r "setsockopt($HANDLE, IPPROTO_IP, IP_MULTICAST_LOOP, &__b2c__yes, sizeof(int));" >> $g_CFILE
		print -r "__b2c__ttl=${g_MULTICAST_TTL}; setsockopt($HANDLE, IPPROTO_IP, IP_MULTICAST_TTL, &__b2c__ttl, sizeof(unsigned char));" >> $g_CFILE
	    fi
	    print -r "setsockopt($HANDLE, SOL_SOCKET, SO_REUSEADDR, &__b2c__yes, sizeof(int)); __b2c__addr.sin_family = AF_INET; __b2c__addr.sin_port = htons((long)atol(__b2c__port));" >> $g_CFILE
	    print -r "__b2c__addr.sin_addr = *((struct in_addr *)__b2c__he->h_addr); memset(&(__b2c__addr.sin_zero), '\0', sizeof(__b2c__addr.sin_zero));" >> $g_CFILE
	    print -r "__b2c__result = connect($HANDLE, (struct sockaddr *)&__b2c__addr, sizeof(struct sockaddr));" >> $g_CFILE
	    print -r "if(__b2c__result == -1) {if(!__b2c__trap){ERROR = 13;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE;;
	@(SERVER) )
	    # Network code
	    print -r "if (strstr($FILE, \":\") == NULL) {ERROR = 10; fprintf(stderr, \"ERROR: %s: '%s'\n\", ERR${g_STRINGSIGN}(ERROR), ${FILE}); exit(ERROR);}" >> $g_CFILE
	    print -r "if(strcmp(__b2c__data_server, $FILE)) {strncpy(__b2c__data_server, $FILE, $g_BUFFER_SIZE); __b2c__host = strtok(__b2c__data_server, \":\"); __b2c__port = strtok(NULL, \":\"); __b2c__he = gethostbyname(__b2c__host);" >> $g_CFILE
	    print -r "if (__b2c__he == NULL || __b2c__he->h_addr == NULL) {if(!__b2c__trap){ERROR = 11;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
	    print -r "__b2c__handle = socket(AF_INET, ${g_SOCKTYPE}, 0);" >> $g_CFILE
	    print -r "if (__b2c__handle == -1) {if(!__b2c__trap){ERROR = 12;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
	    print -r "__b2c__to.tv_sec = $g_OPTION_SOCKET; __b2c__to.tv_usec = 0; setsockopt(__b2c__handle, SOL_SOCKET, SO_SNDTIMEO, &__b2c__to, sizeof(struct timeval));" >> $g_CFILE
	    print -r "setsockopt(__b2c__handle, SOL_SOCKET, SO_REUSEADDR, &__b2c__yes, sizeof(int)); __b2c__addr.sin_family = AF_INET; __b2c__addr.sin_port = htons((long)atol(__b2c__port));" >> $g_CFILE
	    print -r "__b2c__addr.sin_addr = *((struct in_addr *)__b2c__he->h_addr); memset(&(__b2c__addr.sin_zero), '\0', sizeof(__b2c__addr.sin_zero));" >> $g_CFILE
	    print -r "__b2c__result = bind(__b2c__handle, (struct sockaddr *)&__b2c__addr, sizeof(struct sockaddr));" >> $g_CFILE
	    print -r "if(__b2c__result == -1){if(!__b2c__trap){ERROR = 17;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
            if [[ ${g_NETWORKTYPE} = "MULTICAST" ]]
	    then
		print -r "/* __b2c__imreq.imr_multiaddr.s_addr = inet_addr(__b2c__host); __b2c__imreq.imr_interface.s_addr = INADDR_ANY; */" >> $g_CFILE
		print -r "/* setsockopt(__b2c__handle, IPPROTO_IP, IP_ADD_MEMBERSHIP, &__b2c__imreq, sizeof(__b2c__imreq)); */" >> $g_CFILE
	    fi
            if [[ ${g_NETWORKTYPE} = "UDP" || ${g_NETWORKTYPE} = "BROADCAST" || ${g_NETWORKTYPE} = "MULTICAST" ]]
            then
	        print -r "$HANDLE = __b2c__handle; }" >> $g_CFILE
            else
	        print -r "__b2c__result = listen(__b2c__handle, $g_MAX_BACKLOG);" >> $g_CFILE
	        print -r "if(__b2c__result == -1){if(!__b2c__trap){ERROR = 18;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
	        print -r "strncpy(__b2c__data_server, $FILE, $g_BUFFER_SIZE); /* Restore data because of strtok */} __b2c__result = accept(__b2c__handle, NULL, 0);" >> $g_CFILE
	        print -r "if(__b2c__result == -1){if(!__b2c__trap){ERROR = 19;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
	        print -r "$HANDLE= __b2c__result;" >> $g_CFILE
            fi;;
    esac
}

#-----------------------------------------------------------

function Handle_Readln
{
    # Local variables
    typeset CHECK VAR FROM TARGET STR

    # Check if FROM is available
    if [[ "$1" != +(* FROM *) ]]
    then
	print "\nERROR: Missing FROM in READLN statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    VAR=`print ${1%% FROM *}`

    # Get filedescriptor
    FROM=`print ${1##* FROM }`

    # Check if var is string var
    if [[ "${VAR}" != +(*${g_STRINGSIGN}*) ]]
    then
	print "\nERROR: Variable for READLN at line $g_COUNTER in file '$g_CURFILE' must be string!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Check if variable is declared
    if [[ ${VAR} != +(*\[*\]*) ]]
    then
	STR=${VAR%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
	if [[ -z $CHECK ]]
	then
	    print -r "char *$VAR = NULL;" >> $g_HFILE
	fi
    fi

    # Translate function to C function
    print -r "__b2c__counter = 1; do{ memset(__b2c__input__buffer, '\0', $g_BUFFER_SIZE);" >> $g_CFILE
    print -r "__b2c__assign = fgets(__b2c__input__buffer, $g_BUFFER_SIZE, $FROM);" >> $g_CFILE

    # Make sure internal var is copied to var of program
    print -r "$VAR = (char*)realloc($VAR, ($g_BUFFER_SIZE+1)*__b2c__counter*sizeof(char));" >> $g_CFILE
    print -r "if(__b2c__counter == 1) strncpy($VAR, __b2c__input__buffer, $g_BUFFER_SIZE);" >> $g_CFILE
    print -r "else strncat($VAR, __b2c__input__buffer, $g_BUFFER_SIZE); __b2c__counter++;" >> $g_CFILE
    print -r "} while (!strstr(__b2c__input__buffer, \"\n\") && strlen(__b2c__input__buffer));" >> $g_CFILE
    # Cut off last newline
    print -r "if (strlen(__b2c__input__buffer)) $VAR[strlen($VAR)-1]='\0';" >> $g_CFILE
    # Cut off CR if available
    print -r "if(strlen($VAR)>0 && $VAR[strlen($VAR)-1]=='\r') $VAR[strlen($VAR)-1]='\0';" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Writeln
{
    # Local variables
    typeset VAR TO LINE LEN CHAR IN_STRING IN_FUNC ESCAPED

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in WRITELN statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get filedescriptor
    TO=`print -r ${1##* TO }`

    # Start miniparser to see if we need to print something, convert spaces
    LINE=`print -r "${1% TO *}" | tr " " "\001"`
    VAR=
    LEN=${#LINE}
    IN_STRING=0

    # Get the characters
    until [[ $LEN -eq 0 ]]
    do
	typeset -L1 CHAR="${LINE}"
	case $CHAR in
	    ",")
		if [[ $IN_STRING -eq 0 && $IN_FUNC -eq 0 ]]
		then
		    # Check if var is string var
		    if [[ "${VAR%%\(*}" = +(*${g_STRINGSIGN}*) || "${VAR%%\(*}" = +(*${g_DQUOTESIGN}*) ]]
		    then
			print -r "fprintf($TO, \"%s\", ${VAR});" >> $g_CFILE
		    else
			print -r "fprintf($TO, \"%s\", STR${g_STRINGSIGN}(${VAR}));" >> $g_CFILE
		    fi
		    typeset -L0 CHAR=""
		    ESCAPED=0
		    VAR=
		fi;;
	    "\\")
		ESCAPED=1;;
	    "\"")
		if [[ $ESCAPED -eq 0 ]]
		then
		    if [[ $IN_STRING -eq 0 ]]
		    then
			IN_STRING=1
		    else
			IN_STRING=0
		    fi
		fi
		ESCAPED=0;;
	    "(")
		if [[ $IN_STRING -eq 0 ]]
		then
		    ((IN_FUNC=$IN_FUNC+1))
		fi
		ESCAPED=0;;
	    ")")
		if [[ $IN_STRING -eq 0 ]]
		then
		    ((IN_FUNC=$IN_FUNC-1))
		fi
		ESCAPED=0;;
	    *)
		ESCAPED=0;;
	esac
	# Convert back to space
	if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	then
	    VAR="${VAR} "
	else
	    VAR="${VAR}${CHAR}"
	fi
	let LEN=${#LINE}-1
	typeset -R$LEN LINE="${LINE}"
    done

    # Write last element to file
    if [[ "${VAR%%\(*}" = +(*${g_STRINGSIGN}*) || "${VAR%%\(*}" = +(*${g_DQUOTESIGN}*) ]]
    then
	print -r "fprintf($TO, \"%s\n\", ${VAR});" >> $g_CFILE
    else
	print -r "fprintf($TO, \"%s\n\", STR${g_STRINGSIGN}(${VAR}));" >> $g_CFILE
    fi
    print -r "fflush($TO);" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Getbyte
{
    # Local variables
    typeset POS FROM SIZE TARGET CHECK

    # Check if FROM is available
    if [[ "$1" != +(* FROM *) ]]
    then
	print "\nERROR: Missing FROM in GETBYTE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    POS=`print ${1%% FROM *}`

    # Get filedescriptor
    FROM=`print ${1##* FROM }`

    SIZE=

    # Check if SIZE is available
    if [[ "$1" = +(* SIZE *) ]]
    then
	SIZE=${FROM##* SIZE }
	FROM=${FROM%% SIZE *}
    else
	SIZE=1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Declare variable if not done yet, assuming long
    if [[ "$POS" != +(*.*) ]]
    then
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $POS,| $POS;|,$POS,|,$POS;| $POS=| ${POS%%\[*}\[|,${POS%%\[*}\[" | grep -v " noparse "`
	if [[ -z $CHECK ]]
	then
	    print -r "long $POS;" >> $g_HFILE
	fi
    fi

    # Translate function to C function
    print -r "if(!__b2c__trap){if(__b2c__memory__check((char *)$POS)) {ERROR=1; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
    print -r "__b2c__counter = fread((void*)$POS, sizeof($g_OPTION_MEMTYPE), $SIZE, $FROM);" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Putbyte
{
    # Local variables
    typeset VAR TO SIZE POS

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in PUTBYTE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    POS=`print ${1%% TO *}`;

    # Get filedescriptor
    TO=`print ${1##* TO }`

    SIZE=

    # Check if SIZE is available
    if [[ "$1" = +(* SIZE *) ]]
    then
	SIZE=${TO##* SIZE }
	TO=${TO%% SIZE *}
    else
	SIZE=1
    fi

    # Translate function to C function
    print -r "if(!__b2c__trap){if(__b2c__memory__check((char *)$POS)) {ERROR=1; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
    print -r "__b2c__counter = fwrite((void*)$POS, sizeof($g_OPTION_MEMTYPE), $SIZE, $TO);" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Getfile
{
    # Local variables
    typeset VAR FROM SIZE TARGET STR

    # Check if FROM is available
    if [[ "$1" != +(* FROM *) ]]
    then
	print "\nERROR: Missing FROM in GETFILE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    VAR=`print ${1%% FROM *}`

    # Get dirdescriptor
    FROM=`print ${1##* FROM }`

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Translate function to C function
    print -r "__b2c__dir = readdir($FROM);" >> $g_CFILE

    # Check if variable is declared
    STR=${VAR%${g_STRINGSIGN}*}
    CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
    if [[ -z $CHECK && "$VAR" != +(*\[*\]*) && "$VAR" != +(*.*) ]]
    then
	print -r "char *$VAR = NULL;" >> $g_HFILE
    fi

    # Always realloc VAR to correct size, maybe it was resized somewhere else
    print -r "if(__b2c__dir != NULL) {$VAR = realloc($VAR, (strlen(__b2c__dir->d_name)+1)*sizeof(char));" >> $g_CFILE
    # Make sure internal var is copied to var of program
    print -r "strcpy($VAR, __b2c__dir->d_name); $VAR[strlen(__b2c__dir->d_name)] = '\0';}" >> $g_CFILE
    print -r "else {$VAR = realloc($VAR, sizeof(char)); $VAR[0] = '\0';}" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Receive
{
    # Local variables
    typeset CHECK VAR FROM TARGET STR CHUNK SIZE

    # Check if FROM is available
    if [[ "$1" != +(* FROM *) ]]
    then
	print "\nERROR: Missing FROM in RECEIVE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    VAR=`print ${1%% FROM *}`

    # Get filedescriptor
    FROM=`print ${1##* FROM }`

   # Check for optional chunksize
    if [[ $FROM = +(* CHUNK *) ]]
    then
	CHUNK=${FROM##* CHUNK }
	FROM=${FROM%% CHUNK *}
    else
	CHUNK=$g_BUFFER_SIZE
	SIZE=
    fi

    # Check for optional return variable
    if [[ $CHUNK = +(* SIZE *) ]]
    then
	SIZE=${CHUNK##* SIZE }
	CHUNK=${CHUNK%% SIZE *}
    else
	SIZE=
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Variable may not be array, these should be defined with DECLARE
    if [[ -n $SIZE && "$SIZE" != +(*\[*\]*) && "$SIZE" != +(*.*) ]]
    then
	# Declare variable if not done yet, assuming long
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $SIZE,| $SIZE;|,$SIZE,|,$SIZE;| $SIZE=| ${SIZE%%\[*}\[|,${SIZE%%\[*}\[" | grep -v " noparse "`
	if [[ -z $CHECK ]]
	then
	    print -r "long $SIZE;" >> $g_HFILE
	fi
    fi

    # Check if string variable, and if so, if declared
    if [[ "${VAR}" = +(*${g_STRINGSIGN}) ]]
    then
	STR=${VAR%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
	if [[ -z $CHECK ]]
	then
	    print -r "char *$VAR = NULL;" >> $g_HFILE
	fi
	print -r "$VAR = (char*)realloc($VAR, ($CHUNK+1)*sizeof(char)); memset($VAR, '\0', sizeof(char)*($CHUNK+1));" >> $g_CFILE
    fi

    # Translate function to C function
    if [[ -z $SIZE ]]
    then
	print -r "if(recv($FROM, (void*)$VAR, $CHUNK, 0) < 0) {if(!__b2c__trap){ERROR = 14;if(!__b2c__catch_set)" >> $g_CFILE
	print -r "{fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
    else
	print -r "if(($SIZE = recv($FROM, (void*)$VAR, $CHUNK, 0)) < 0) {if(!__b2c__trap){ERROR = 14;if(!__b2c__catch_set)" >> $g_CFILE
	print -r "{fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
    fi
}
#-----------------------------------------------------------

function Handle_Send
{
    # Local variables
    typeset VAR TO CHUNK

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in SEND statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    VAR=`print -r ${1%% TO *}`;

    # Get filedescriptor
    TO=`print -r ${1##* TO }`

   # Check for optional chunksize
    if [[ $TO = +(* CHUNK *) ]]
    then
	CHUNK=${TO##* CHUNK }
	TO=${TO%% CHUNK *}
    else
	CHUNK="strlen($VAR)"
    fi

    # Translate function to C function
    print -r "if(send($TO, (void*)$VAR, $CHUNK, 0) < 0) {if(!__b2c__trap){ERROR = 15; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Getline
{
    # Local variables
    typeset CHECK VAR FROM TARGET STR

    # Check if FROM is available
    if [[ "$1" != +(* FROM *) ]]
    then
	print "\nERROR: Missing FROM in GETLINE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    VAR=`print -r ${1%% FROM *}`

    # Get filedescriptor
    FROM=`print -r ${1##* FROM }`

    # Check if var is string var
    if [[ "${VAR}" != +(*${g_STRINGSIGN}*) ]]
    then
	print "\nERROR: Variable for GETLINE at line $g_COUNTER in file '$g_CURFILE' must be string!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Check if variable is declared
    if [[ ${VAR} != +(*\[*\]*) ]]
    then
	STR=${VAR%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
	if [[ -z $CHECK ]]
	then
	    print -r "char *$VAR = NULL;" >> $g_HFILE
	fi
    fi

    # Translate function to C function
    print -r "if ($FROM == NULL || *$FROM == '\0') {$VAR = (char*)realloc($VAR, 2*sizeof(char)); strcpy($VAR, \"\");}" >> $g_CFILE
    print -r "else { __b2c__assign = $FROM; while(*$FROM != '\0' && *$FROM != '\n') $FROM++;" >> $g_CFILE

    # Make sure internal var is copied to var of program
    print -r "$VAR = (char*)realloc($VAR, ($FROM-__b2c__assign+1)*sizeof(char));" >> $g_CFILE
    print -r "strncpy($VAR, __b2c__assign, $FROM-__b2c__assign);" >> $g_CFILE

    # Make sure to end the string
    print -r "$VAR[($FROM-__b2c__assign)] = '\0'; $FROM++;}" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Putline
{
    # Local variables
    typeset VAR TO LINE LEN CHAR IN_STRING IN_FUNC

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in PUTLINE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get memorydescriptor
    TO=`print -r ${1##* TO }`

    # Start miniparser to see if we need to print something, convert spaces
    LINE=`print -r "${1%% TO *}" | tr " " "\001"`
    VAR=
    LEN=${#LINE}
    IN_STRING=0

    # Get the characters
    until [[ $LEN -eq 0 ]]
    do
	typeset -L1 CHAR="${LINE}"
	case $CHAR in
	    ",")
		if [[ $IN_STRING -eq 0 && $IN_FUNC -eq 0 ]]
		then
		    # Check if var is string var
		    if [[ "${VAR%%\(*}" = +(*${g_STRINGSIGN}*) || "${VAR%%\(*}" = +(*${g_DQUOTESIGN}*) ]]
		    then
			print -r "strcat($TO, $VAR); $TO+=strlen($VAR);" >> $g_CFILE
		    else
			print -r "strcat($TO, STR${g_STRINGSIGN}($VAR)); $TO+=strlen(STR${g_STRINGSIGN}($VAR));" >> $g_CFILE
		    fi
		    typeset -L0 CHAR=""
		    ESCAPED=0
		    VAR=
		fi;;
	    "\\")
		ESCAPED=1;;
	    "\"")
		if [[ $ESCAPED -eq 0 ]]
		then
		    if [[ $IN_STRING -eq 0 ]]
		    then
			IN_STRING=1
		    else
			IN_STRING=0
		    fi
		fi
		ESCAPED=0;;
	    "(")
		if [[ $IN_STRING -eq 0 ]]
		then
		    ((IN_FUNC=$IN_FUNC+1))
		fi
		ESCAPED=0;;
	    ")")
		if [[ $IN_STRING -eq 0 ]]
		then
		    ((IN_FUNC=$IN_FUNC-1))
		fi
		ESCAPED=0;;
	    *)
		ESCAPED=0;;
	esac
	# Convert back to space
	if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	then
	    VAR="${VAR} "
	else
	    VAR="${VAR}${CHAR}"
	fi
	let LEN=${#LINE}-1
	typeset -R$LEN LINE="${LINE}"
    done

    # Check if var is string var
    if [[ "${VAR%%\(*}" = +(*${g_STRINGSIGN}*)  || "${VAR%%\(*}" = +(*${g_DQUOTESIGN}*) ]]
    then
	print -r "strcat($TO, $VAR); strcat($TO, \"\n\"); $TO+=strlen($VAR)+1;" >> $g_CFILE
    else
	print -r "strcat($TO, STR${g_STRINGSIGN}($VAR)); strcat($TO, \"\n\"); $TO+=strlen(STR${g_STRINGSIGN}($VAR))+1;" >> $g_CFILE
    fi
}

#-----------------------------------------------------------

function Handle_Import
{
    # Local variables
    typeset TMP SYM LIB CHECK TOKEN PTR TYPE ALIAS

    # Check if FROM is available
    if [[ "$1" != +(* FROM *) ]]
    then
	print "\nERROR: missing FROM in IMPORT statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the symbolname without surrounding spaces and doublequotes
    if [[ "$1" = +(*\(*) ]]
    then
	SYM=`print ${1%%\(*} | tr -d "\042"`; TMP=${1#* FROM }
	TOKEN=`print ${1%\)*}`
    else
	SYM=`print ${1%% FROM *} | tr -d "\042"`; TMP=${1#* FROM }
	TOKEN=
    fi

    # Check if TYPE is available
    if [[ "$1" != +(* TYPE *) ]]
    then
	print "\nERROR: missing TYPE in IMPORT statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get library and type
    LIB=`print ${TMP%% TYPE *}`
    TYPE=`print ${TMP##* TYPE }`

    # Check if ALIAS is there
    if [[ $TYPE = +(* ALIAS *) ]]
    then
	ALIAS=`print ${TYPE##* ALIAS } | tr -d "\042"`
	print -r "#define $ALIAS $SYM" >> $g_HFILE
	g_IMPORTED="$ALIAS $g_IMPORTED"
	TYPE=${TYPE%% ALIAS *}
    fi

    # If library is libm or libc, skip dlopen as we're linking with those anyway
    if [[ $LIB != +(*libc.so*) && $LIB != +(*libm.so*) ]]
    then
	# Create name from libname
	PTR=`print $LIB | tr -d [:punct:]`

	# Check if variable was declared
	CHECK=`grep -i "void\* __b2c__dlopen__pointer_$PTR;" $g_CFILE`
	if [[ -z $CHECK ]]
	then
	    print -r "void* __b2c__dlopen__pointer_$PTR;" >> $g_CFILE
	    print -r "__b2c__dlopen__pointer_$PTR = dlopen($LIB, RTLD_LAZY);" >> $g_CFILE
	fi
	print -r "if(__b2c__dlopen__pointer_$PTR == NULL){if(!__b2c__trap){ERROR = 3;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE

	# Check if token was declared
	CHECK=`grep -i "$TYPE (\*$SYM)" $g_HFILE`
	if [[ -z $CHECK ]]
	then
	    print -r "$TYPE (*$SYM)(${TOKEN#*\(});" >> $g_HFILE
	fi

	# Translate to C function
	print -r "*($TYPE **) (&$SYM) = dlsym(__b2c__dlopen__pointer_$PTR, \"$SYM\");" >> $g_CFILE
	print -r "if($SYM == NULL) {if(!__b2c__trap){ERROR = 4;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
    fi

    # Make symbol known to parser
    g_IMPORTED="$SYM $g_IMPORTED"
}

#-----------------------------------------------------------

function Handle_Declare
{
    # Local variables
    typeset VAR TYPE CHECK NEW VALUE OPTION

    #  Check on a GLOBAL RECORD
    if [[ "$1" = +(*RECORD *) ]]
    then
	# Translate to C typedef struct
	g_RECORDNAME="RECORD_${g_COUNTER}"
	print -r "struct $g_RECORDNAME{" >> $g_HFILE
	g_RECORDVAR=${1#* }
	# Store current function name
	if [[ -n $g_FUNCNAME ]]
	then
	    g_RECORDCACHE=$g_FUNCNAME
	    g_FUNCNAME=
	fi
    else
	# Get the variablename and type
	if [[ "$1" = +(* TYPE *) ]]
	then
	    VAR=`print ${1%% TYPE *} | tr -d " "`
	    TYPE=`print ${1##* TYPE }`
	elif [[ "$1" = +(* ASSOC *) ]]
	then
	    VAR=`print ${1%% ASSOC *} | tr -d " "`
	    TYPE=`print ${1##* ASSOC }`
	else
	    VAR=`print ${1} | tr -d " "`
	    TYPE="long"
	fi

	# Check if variable was already declared
	if [[ "$VAR" != +(*.*) ]]
	then
            VALUE=${VAR%%\[*}
	    CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $g_HFILE | egrep " $VALUE,| $VALUE;|,$VALUE,|,$VALUE;| $VALUE=| $VALUE\[|,$VALUE\[" | grep -v " noparse "`
	fi

	if [[ -n $CHECK ]]
	then
	    print "\nERROR: variable in DECLARE or GLOBAL statement at line $g_COUNTER in file '$g_CURFILE' was defined previously!"
	    exit 1
	fi

	# If array, increase dimensions when OPTION BASE is set
	if [[ $VAR = +(*\[*\]*) && $VAR != +(*=*) ]]
	then
	    NEW=
	    while [[ ${VAR} = +(*\[*\]*) ]]
	    do
		NEW="$NEW${VAR%%\[*}["
		VALUE=${VAR#*\[}
		NEW="$NEW${VALUE%%\]*}+$g_OPTION_BASE]"
		VAR=${VAR#*\]}
	    done
	    VAR="${NEW}"
	fi

	# Check for associative array
	if [[ "${1}" = +(* ASSOC *) ]]
	then
	    VAR=`print -r "$VAR" | tr "," " "`
	    for i in $VAR
	    do
		print -r "struct __b2c__${i}_type {char *key; /* noparse */ ${TYPE} value; /* noparse */ };" >> $g_HFILE
		print -r "struct __b2c__${i}_type *__b2c__${i} = { NULL }; long __b2c__${i}_idx = 0;" >> $g_HFILE

		print -r "static int __b2c__${i}_comp(const void *__b2c__m1, const void *__b2c__m2){ " >> $g_HFILE
		print -r "struct __b2c__${i}_type *__b2c__mi1 = (struct __b2c__${i}_type *) __b2c__m1;" >> $g_HFILE
		print -r "struct __b2c__${i}_type *__b2c__mi2 = (struct __b2c__${i}_type *) __b2c__m2;" >> $g_HFILE
		print -r "if(__b2c__mi1->key == NULL && __b2c__mi2->key == NULL) return 0;" >> $g_HFILE
		print -r "if(__b2c__mi1->key == NULL && __b2c__mi2->key != NULL) return -1;" >> $g_HFILE
		print -r "if(__b2c__mi1->key != NULL && __b2c__mi2->key == NULL) return 1;" >> $g_HFILE
		print -r "return strcmp(__b2c__mi1->key, __b2c__mi2->key); }" >> $g_HFILE

		print -r "struct __b2c__${i}_type * __b2c__${i}_exist(char *__b2c__index){struct __b2c__${i}_type __b2c__${i}_key, *__b2c__${i}__result;" >> $g_HFILE
		print -r "qsort(__b2c__${i}, __b2c__${i}_idx, sizeof(struct __b2c__${i}_type), __b2c__${i}_comp);" >> $g_HFILE
		print -r "__b2c__${i}_key.key = __b2c__index; __b2c__${i}__result = bsearch(&__b2c__${i}_key, __b2c__${i}," >> $g_HFILE
		print -r "__b2c__${i}_idx, sizeof(struct __b2c__${i}_type), __b2c__${i}_comp);" >> $g_HFILE
		print -r "return(__b2c__${i}__result); }" >> $g_HFILE

		print -r "void __b2c__${i}__add(char *__b2c__index){__b2c__${i}_idx++;" >> $g_HFILE
		print -r "__b2c__${i} = (struct __b2c__${i}_type *) realloc (__b2c__${i}, __b2c__${i}_idx * sizeof (struct __b2c__${i}_type));" >> $g_HFILE
		print -r "__b2c__${i}[__b2c__${i}_idx - 1].key = strdup (__b2c__index); __b2c__${i}[__b2c__${i}_idx-1].value = 0;}" >> $g_HFILE

		print -r "void __b2c__${i}__del(char *__b2c__index){struct __b2c__${i}_type *__b2c__${i}__location = __b2c__${i}_exist(__b2c__index);" >> $g_HFILE
		print -r "if(__b2c__${i}__location != NULL) {free(__b2c__${i}__location->key); __b2c__${i}__location->key = NULL;} }" >> $g_HFILE

		print -r "${TYPE} ${i}(char *__b2c__index){struct __b2c__${i}_type __b2c__${i}_key, *__b2c__${i}__result;" >> $g_HFILE
		print -r "qsort(__b2c__${i}, __b2c__${i}_idx, sizeof(struct __b2c__${i}_type), __b2c__${i}_comp);" >> $g_HFILE
		print -r "__b2c__${i}_key.key = __b2c__index; __b2c__${i}__result = bsearch(&__b2c__${i}_key, __b2c__${i}," >> $g_HFILE
		print -r "__b2c__${i}_idx, sizeof(struct __b2c__${i}_type), __b2c__${i}_comp);" >> $g_HFILE
		if [[ ${i} = +(*${g_STRINGSIGN}*) || ${TYPE} = +(*STRING*) || ${TYPE} = +(*char\**) ]]
		then
		    print -r "if(__b2c__${i}__result == NULL) return(\"\"); return __b2c__${i}__result->value;}" >> $g_HFILE
		else
		    print -r "if(__b2c__${i}__result == NULL) return(0); return __b2c__${i}__result->value;}" >> $g_HFILE
		fi
	    done

	# Check if var is string var
	elif [[ ( "${VAR}" = +(*${g_STRINGSIGN}*) || "${TYPE}" = +(*STRING*|*char\**) ) && "${VAR}" != +(*=*) ]]
	then
	    CHECK=`$GREP -E "char \*${STR} = NULL;" $g_HFILE`
	    if [[ -z $CHECK ]]
	    then
		STR=`print ${VAR} | tr ',' ' '`
		for i in $STR
		do
		    if [[ "${i}" = +(*\[*\]*) ]]
		    then
			print -r "char *$i = { NULL };" >> $g_HFILE
		    else
			print -r "char *$i = NULL;" >> $g_HFILE
			# Pointer var should not be initialized
			if [[ "${VAR}" = +(*${g_STRINGSIGN}*) ]]
			then
			    print -r "$i = calloc(1, sizeof(char));" >> $g_CFILE
			fi
		    fi
		done
	    fi
        # Var is string array assignment
	elif [[ ( "${VAR}" = +(*${g_STRINGSIGN}*) || "${TYPE}" = +(*STRING*|*char\**) ) && "${VAR}" = +(*=*) ]]
        then
            print -r "char* ${VAR%%\{*} {" >> $g_HFILE
            OPTION=$g_OPTION_BASE
            while [[ ${OPTION} -gt 0 ]]
            do
                print -r " \"\", " >> $g_HFILE
                ((OPTION-=1))
            done
	    print -r "${VAR#*\{};" >> $g_HFILE
	# Assume char assignment or number
	else
	    if [[ "$VAR" = +(*\[*\]*) && "$VAR" != +(*=*) ]]
	    then
		VAR=`print ${VAR} | tr "," " "`
		for i in $VAR
		do
		    print -r "$TYPE $i = { 0 };" >> $g_HFILE
		done
	    elif [[ "$VAR" = +(*\[*\]*) && "$VAR" = +(*=*) ]]
            then
                print -r "$TYPE ${VAR%%\{*} {" >> $g_HFILE
                OPTION=$g_OPTION_BASE
                while [[ ${OPTION} -gt 0 ]]
                do
                    print -r " 0, " >> $g_HFILE
                    ((OPTION-=1))
                done
	        print -r "${VAR#*\{};" >> $g_HFILE
	    elif [[ "$VAR" != +(*=*) && "$VAR" != +(*\(*\)*) && "${TYPE}" = +(*char*|*short*|*int*|*long*|*double*|*float*|*NUMBER*|*FLOATING*) ]]
	    then
		print -r "$TYPE $VAR;" >> $g_HFILE
		print -r "$VAR = 0;" | tr "," "=" >> $g_CFILE
	    else
		print -r "$TYPE $VAR;" >> $g_HFILE
            fi
	fi
    fi
}

#-----------------------------------------------------------

function Handle_Local
{
    # Local variables
    typeset VAR TYPE CHECK TARGET DIM NEW VALUE i OPTION

    # Get the variablename and type
    if [[ "$1" = +(* TYPE *) ]]
    then
	VAR=`print ${1%% TYPE *} | tr -d " "`
	TYPE=`print ${1##* TYPE }`
    else
	VAR=`print ${1} | tr -d " "`
	if [[ "${VAR}" = +(*${g_STRINGSIGN}*) ]]
	then
	    TYPE="char*"
	else
	    TYPE="long"
	fi
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET=$g_CFILE
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Check if variable was already declared
    if [[ "$VAR" != +(*.*) ]]
    then
        VALUE=${VAR%%\[*}
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $VALUE,| $VALUE;|,$VALUE,|,$VALUE;| $VALUE=| $VALUE\[|,$VALUE\[" | grep -v " noparse "`
    fi

    if [[ -n $CHECK ]]
    then
	print "\nERROR: variable in LOCAL statement at line $g_COUNTER in file '$g_CURFILE' was defined previously!"
	exit 1
    fi

    # If array, increase dimensions when OPTION BASE is set
    if [[ $VAR = +(*\[*\]*) && $VAR != +(*=*) ]]
    then
	NEW=
	while [[ ${VAR} = +(*\[*\]*) ]]
	do
	    NEW="$NEW${VAR%%\[*}["
	    VALUE=${VAR#*\[}
	    NEW="$NEW${VALUE%%\]*}+$g_OPTION_BASE]"
	    VAR=${VAR#*\]}
        done
	VAR="${NEW}"
    fi

    # Check if var is string var and not an argument in an array itself
    if [[ ( "${TYPE}" = +(*STRING*|*char\*) || "${VAR}" = +(*${g_STRINGSIGN}*) ) && "${VAR}" != +(*=*) && "${VAR}" != +(*\[*${g_STRINGSIGN}*\]*) ]]
    then
	STR=${VAR%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = " ${TARGET}`
	if [[ -z $CHECK ]]
	then
	    STR=`print ${VAR} | tr ',' ' '`
	    for i in $STR
	    do
		# Check on multidimensional stringarrays
		if [[ "${i}" = +(*\[*\]*\]*) ]]
		then
		    print "\nERROR: multidimensional stringarrays at line $g_COUNTER in file '$g_CURFILE' are not supported!"
		    exit 1
		fi
		# Are we in a function?
		if [[ -n $g_FUNCNAME ]]
		then
		    if [[ -n $g_RECORDNAME ]]
		    then
			if [[ "${i}" = +(*\[*\]*) ]]
			then
			    print -r "char *$i;" >> $g_CFILE
			    DIM=${i##*\[}; DIM=${DIM%%\]*}
			    g_STRINGARRAYS="$g_STRINGARRAYS for(__b2c__ctr=0; __b2c__ctr<$DIM; __b2c__ctr++)if($g_RECORDVAR.${i%%\[*}[__b2c__ctr]!=NULL){free($g_RECORDVAR.${i%%\[*}[__b2c__ctr]);}"
			else
			    print -r "char *$i; /* noparse */" >> $g_CFILE
			fi
		    else
			if [[ "${i}" = +(*\[*\]*) ]]
			then
			    print -r "char *$i = { NULL };" >> $g_CFILE
			    DIM=${i##*\[}; DIM=${DIM%%\]*}
			    g_STRINGARRAYS="$g_STRINGARRAYS for(__b2c__ctr=0; __b2c__ctr<$DIM; __b2c__ctr++)if(${i%%\[*}[__b2c__ctr]!=NULL){free(${i%%\[*}[__b2c__ctr]);}"
			else
			    print -r "char *$i = NULL;" >> $g_CFILE
			    # Pointer var should not be initialized
			    if [[ "${VAR}" = +(*${g_STRINGSIGN}*) ]]
			    then
				print -r "$i = calloc(1, sizeof(char));" >> $g_CFILE
				g_LOCALSTRINGS="$g_LOCALSTRINGS ${i}"
			    fi
			fi
		    fi
		# We are in the mainprogram
		else
		    if [[ -n $g_RECORDNAME ]]
		    then
			print -r "char *$i; /* noparse */" >> $g_HFILE
		    else
			if [[ "${i}" = +(*\[*\]*) ]]
			then
			    print -r "char *$i = { NULL };" >> $g_CFILE
			else
			    print -r "char *$i = NULL;" >> $g_HFILE
			    # Pointer var should not be initialized
			    if [[ "${VAR}" = +(*${g_STRINGSIGN}*) ]]
			    then
				print -r "$i = calloc(1, sizeof(char));" >> $g_CFILE
			    fi
			fi
		    fi
		fi
	    done
	fi
    elif [[ ( "${VAR}" = +(*${g_STRINGSIGN}*) || "${TYPE}" = +(*STRING*|*char\**) ) && "${VAR}" = +(*=*) ]]
    then
        if [[ -n $g_FUNCNAME ]]
	then
            # String array assignment
            print -r "char* ${VAR%%\{*} {" >> $g_CFILE
            OPTION=$g_OPTION_BASE
            while [[ ${OPTION} -gt 0 ]]
            do
                print -r " \"\", " >> $g_CFILE
                ((OPTION-=1))
            done
	    print -r "${VAR#*\{};" >> $g_CFILE
        else
            # String array assignment
            print -r "char* ${VAR%%\{*} {" >> $g_HFILE
            OPTION=$g_OPTION_BASE
            while [[ ${OPTION} -gt 0 ]]
            do
                print -r " \"\", " >> $g_HFILE
                ((OPTION-=1))
            done
	    print -r "${VAR#*\{};" >> $g_HFILE
        fi
    # Assume number
    else
	if [[ -n $g_FUNCNAME ]]
	then
	    if [[ -n $g_RECORDNAME ]]
	    then
		print -r "$TYPE $VAR; /* noparse */" >> $g_CFILE
	    else
		if [[ "$VAR" = +(*\[*\]*) && "$VAR" != +(*=*) ]]
		then
		    VAR=`print ${VAR} | tr "," " "`
		    for i in $VAR
		    do
			print -r "$TYPE $i = { 0 };" >> $g_CFILE
		    done
		elif [[ "$VAR" = +(*\[*\]*) && "$VAR" = +(*=*) ]]
                then
                    # Numeric array assignment
                    print -r "$TYPE ${VAR%%\{*} {" >> $g_CFILE
                    OPTION=$g_OPTION_BASE
                    while [[ ${OPTION} -gt 0 ]]
                    do
                        print -r " 0, " >> $g_CFILE
                        ((OPTION-=1))
                    done
	            print -r "${VAR#*\{};" >> $g_CFILE
		elif [[ "$VAR" != +(*=*) && "$VAR" != +(*\(*\)*) && "${TYPE}" = +(*char*|*short*|*int*|*long*|*double*|*float*|*NUMBER*|*FLOATING*) ]]
		then
		    print -r "$TYPE $VAR;" >> $g_CFILE
		    print -r "$VAR = 0;" | tr "," "=" >> $g_CFILE
		else
		    print -r "$TYPE $VAR;" >> $g_CFILE
		fi
	    fi
	else
	    if [[ -n $g_RECORDNAME ]]
	    then
		print -r "$TYPE $VAR; /* noparse */" >> $g_HFILE
	    else
		if [[ "$VAR" = +(*\[*\]*) && "$VAR" != +(*=*) ]]
		then
		    VAR=`print ${VAR} | tr "," " "`
		    for i in $VAR
		    do
			print -r "$TYPE $i = { 0 };" >> $g_HFILE
		    done
		elif [[ "$VAR" = +(*\[*\]*) && "$VAR" = +(*=*) ]]
                then
                    # Numeric array assignment
                    print -r "$TYPE ${VAR%%\{*} {" >> $g_HFILE
                    OPTION=$g_OPTION_BASE
                    while [[ ${OPTION} -gt 0 ]]
                    do
                        print -r " 0, " >> $g_HFILE
                        ((OPTION-=1))
                    done
	            print -r "${VAR#*\{};" >> $g_HFIL
                elif [[ "$VAR" != +(*=*) && "$VAR" != +(*\(*\)*) && "${TYPE}" = +(*char*|*short*|*int*|*long*|*double*|*float*|*NUMBER*|*FLOATING*) ]]
		then
		    print -r "$TYPE $VAR;" >> $g_HFILE
		    print -r "$VAR = 0;" | tr "," "=" >> $g_CFILE
		else
		    print -r "$TYPE $VAR;" >> $g_HFILE
		fi
	    fi
	fi
    fi
}

#-----------------------------------------------------------

function Handle_Read
{
    # Local variables
    typeset CHECK TARGET STR

    # Check if we have an argument at all
    if [[ "$1" = "READ" ]]
    then
	print "\nERROR: empty READ at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Check type of var, string?
    if [[ "${1}" = +(*${g_STRINGSIGN}) ]]
    then
	STR=${1%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
	if [[ -z $CHECK ]]
	then
	    print -r "char *$1 = NULL;" >> $g_HFILE
	fi
	# Convert to C
	print -r "$1 = (char*)realloc($1, (strlen(__b2c__stringarray[__b2c__stringarray_ptr])+1)*sizeof(char));" >> $g_CFILE
	print -r "strcpy($1, __b2c__stringarray[__b2c__stringarray_ptr]);" >> $g_CFILE
	print -r "__b2c__stringarray_ptr++;" >> $g_CFILE
    else
	# Variable may not be array, these should be defined with DECLARE
	if [[ "$1" != +(*\[*\]*) && "$1" != +(*.*) ]]
	then
	    # Not declared? Assume long
	    CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $1,| $1;|,$1,|,$1;| $1=| ${1%%\[*}\[|,${1%%\[*}\[" | grep -v " noparse "`
	    if [[ -z $CHECK ]]
	    then
		print -r "long $1;" >> $g_HFILE
		CHECK="long "
	    fi
	else
	    # See how var was declared
	    CHECK=`$GREP -E "DIR |FILE |int |long |float |double |char |void |STRING |NUMBER |FLOATING " $TARGET | $GREP -E " ${1%%\[*}|\*${1%%\[*}" | grep -v " noparse "`
	fi
	# Convert to C
	if [[ "$CHECK" = +(*char\* *) || "$CHECK" = +(*char \**) || "$CHECK" = +(*STRING *) ]]
	then
	    print -r "${1} = (char*)realloc($1, (strlen(__b2c__stringarray[__b2c__stringarray_ptr])+1)*sizeof(char));" >> $g_CFILE
	    print -r "strcpy(${1}, __b2c__stringarray[__b2c__stringarray_ptr]);" >> $g_CFILE
	    print -r "__b2c__stringarray_ptr++;" >> $g_CFILE
	else
	    CHECK=${CHECK##*:}
	    print -r "${1} = (${CHECK%% *})__b2c__floatarray[__b2c__floatarray_ptr];" >> $g_CFILE
	    print -r "__b2c__floatarray_ptr++;" >> $g_CFILE
	fi
    fi
}

#-----------------------------------------------------------

function Handle_Endfunction
{
    # Check if return was found
    if [[ -z $g_FUNCTYPE ]]
    then
	print "\nERROR: function '$g_FUNCNAME' was defined without returning a value or string!"
	exit 1
    fi

    # Put prototype to header file
    print -r "$g_FUNCTYPE ${g_PROTOTYPE}; /* noparse */" >> $g_HFILE
    g_PROTOTYPE=

    # Now setup function in main program
    print -r "/* Created with KSH BaCon $g_VERSION - (c) Peter van Eerten - GPL v3 */" > ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    print -r "/* noparse $g_CURFILE BACON LINE $g_COUNTER */" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    if [[ $g_ORIGFUNCNAME != +(*\(*\)*) ]]
    then
	print -r "$g_FUNCTYPE $g_ORIGFUNCNAME(void) {" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    else
	print -r "$g_FUNCTYPE $g_ORIGFUNCNAME {" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    fi

    # Add function body
    print -r "${g_STRINGARGS}" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    cat $g_CFILE >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    print -r "__B2C__PROGRAM__EXIT: ;" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h

    # Make sure the function always returns something
    if [[ $g_FUNCTYPE = +(*char\**) ]]
    then
	print -r "return (\"\");}" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    else
	print -r "return (0);}" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    fi

    # Include header file
    if [[ ${g_INCLUDE_FILES} != +(*${g_CURFILE%\.*}.$g_FUNCNAME.h*) ]]
    then
	g_INCLUDE_FILES="$g_INCLUDE_FILES ${g_CURFILE%\.*}.$g_FUNCNAME.h"
    fi

    # Add to total filelist
    g_TMP_FILES="$g_TMP_FILES ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h"

    # Delete temp funcfile
    rm $g_CFILE

    # Restore mainfile
    g_CFILE=$g_COPY_CFILE

    # Restore CATCH routine
    g_CATCHGOTO="$g_ORIGCATCHGOTO"

    # Clear function variables
    g_ORIGFUNCNAME=
    g_FUNCNAME=
    g_FUNCTYPE=
    g_LOCALSTRINGS=
    g_STRINGARRAYS=
    g_STRINGARGS=
}

#-----------------------------------------------------------

function Handle_Return
{
    # Local variables
    typeset CHECK STR ARG

    # Check if we have an argument at all, if not, we return from a GOSUB
    if [[ "$1" = "RETURN" ]]
    then
	print -r "if(__b2c__gosub_buffer_ptr >= 0) longjmp(__b2c__gosub_buffer[__b2c__gosub_buffer_ptr], 1);" >> $g_CFILE
	return
    fi

    CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $g_CFILE | $GREP -E " $1,| $1;|,$1,|,$1;| $1=| ${1%%\[*}\[|,${1%%\[*}\[" | grep -v " noparse "`

   # Check type of var, func using string but returning a value?
    if [[ "${1}" = +(*\(*) && "${1}" = +(*${g_STRINGSIGN}*) && "${1%%\(*}" != +(*${g_STRINGSIGN}*) && "${1%%\(*}" != +(*gettext*|*ngettext*) ]]
    then
	g_FUNCTYPE="double "
	ARG=${1#*\(}
	print -r "__b2c__rbuffer_ptr++; if(__b2c__rbuffer_ptr >= $g_MAX_RBUFFERS) __b2c__rbuffer_ptr=0; if(${ARG%\)*} != NULL)" >> $g_CFILE
	print -r " {__b2c__rbuffer[__b2c__rbuffer_ptr] = (char*)realloc(__b2c__rbuffer[__b2c__rbuffer_ptr], (strlen(${ARG%\)*})+1)*sizeof(char));" >> $g_CFILE
	print -r "strcpy(__b2c__rbuffer[__b2c__rbuffer_ptr], ${ARG%\)*} );}" >> $g_CFILE
	print -r "else {__b2c__rbuffer[__b2c__rbuffer_ptr] = (char*)realloc(__b2c__rbuffer[__b2c__rbuffer_ptr], 2*sizeof(char));" >> $g_CFILE
	print -r "strcpy(__b2c__rbuffer[__b2c__rbuffer_ptr], \"\");}" >> $g_CFILE
	ARG="${1%\(*}(__b2c__rbuffer[__b2c__rbuffer_ptr])${1#*\)}"

    # Check type of var, string or normal string?
    elif [[ "${1}" = +(*${g_STRINGSIGN}*) || "${1}" = +(*${g_DQUOTESIGN}*) || ${g_FUNCNAME} = +(*${g_STRINGSIGN}*) ]]
    then
	g_FUNCTYPE="char* "
	print -r "__b2c__rbuffer_ptr++; if(__b2c__rbuffer_ptr >= $g_MAX_RBUFFERS) __b2c__rbuffer_ptr=0; if($1 != NULL)" >> $g_CFILE
	print -r " {__b2c__rbuffer[__b2c__rbuffer_ptr] = (char*)realloc(__b2c__rbuffer[__b2c__rbuffer_ptr], (strlen($1)+1)*sizeof(char));" >> $g_CFILE
	print -r "strcpy(__b2c__rbuffer[__b2c__rbuffer_ptr], $1);}" >> $g_CFILE
	print -r "else {__b2c__rbuffer[__b2c__rbuffer_ptr] = (char*)realloc(__b2c__rbuffer[__b2c__rbuffer_ptr], 2*sizeof(char));" >> $g_CFILE
	print -r "strcpy(__b2c__rbuffer[__b2c__rbuffer_ptr], \"\");}" >> $g_CFILE
	ARG="__b2c__rbuffer[__b2c__rbuffer_ptr]"

    # Check if float
    elif [[ "$1" = +(*.*) ]]
    then
	g_FUNCTYPE="double "
	ARG="${1}"

    # Check if no alpha chars (then integer value)
    elif [[ "$1" = +([0-9]) ]]
    then
	g_FUNCTYPE="long "
	ARG="${1}"

    # Assume variable, check if declared before
    elif [[ -n $CHECK ]]
    then
	case $CHECK in
	    +(*DIR *) )
		g_FUNCTYPE="DIR* ";;
	    +(*FILE *) )
		g_FUNCTYPE="FILE* ";;
	    +(*int\* *) )
		g_FUNCTYPE="int* ";;
	    +(*float\* *) )
		g_FUNCTYPE="float* ";;
	    +(*double\* *) )
		g_FUNCTYPE="double* ";;
	    +(*char\* *|*STRING *) )
		g_FUNCTYPE="char* ";;
	    +(*long\* *) )
		g_FUNCTYPE="long* ";;
	    +(*void\* *) )
		g_FUNCTYPE="void* ";;
	    +(*int *) )
		g_FUNCTYPE="int ";;
	    +(*float *) )
		g_FUNCTYPE="float ";;
	    +(*double *|*FLOATING *) )
		g_FUNCTYPE="double ";;
	    +(*char *) )
		g_FUNCTYPE="char ";;
	    +(*long *|*NUMBER *) )
		g_FUNCTYPE="long ";;
	    +(*void *) )
		g_FUNCTYPE="void ";;
	esac
	ARG="${1}"

    # Not declared, assume integer variable
    else
	g_FUNCTYPE="long "
	ARG="${1}"
    fi

    # Free strings variables if there are any
    for STR in $g_LOCALSTRINGS
    do
	print -r "if($STR != NULL) free($STR);" >> $g_CFILE
    done
    print -r "${g_STRINGARRAYS}" >> $g_CFILE

    # The actual return value
    print -r "return (${ARG});" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Push
{
    # Local variables
    typeset CHECK TARGET

    # Check if we have an argument at all
    if [[ "$1" = "PUSH" ]]
    then
	print "\nERROR: empty PUSH at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    if [[ "$VAR" != +(*.*) ]]
    then
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $1,| $1;|,$1,|,$1;| $1=| ${1%%\[*}\[|,${1%%\[*}\[" | grep -v " noparse "`
    fi

    # Allocate space for type
    print -r "__b2c__typestack = (int*)realloc(__b2c__typestack, (__b2c__stackptr+1)*sizeof(int));" >> $g_CFILE

    # Check type of var, string?
    if [[ "${1}" = +(*${g_STRINGSIGN}*) ]]
    then
	print -r "__b2c__stringstack = (char**)realloc(__b2c__stringstack, (__b2c__stackptr+1)*sizeof(char*));" >> $g_CFILE
	print -r "if(__b2c__stackptr == 0){ __b2c__stringstack[__b2c__stackptr] = realloc(__b2c__stringstack[__b2c__stackptr], (strlen($1)+1)*sizeof(char));" >> $g_CFILE
	print -r "strcpy(__b2c__stringstack[__b2c__stackptr], $1);} else __b2c__stringstack[__b2c__stackptr] = strdup($1);" >> $g_CFILE
	print -r "__b2c__typestack[__b2c__stackptr] = 1;" >> $g_CFILE
    # Check if it is a normal string
    elif [[ "${1}" = +(*${g_DQUOTESIGN}*) ]]
    then
	print -r "__b2c__stringstack = (char**)realloc(__b2c__stringstack, (__b2c__stackptr+1)*sizeof(char*));" >> $g_CFILE
	print -r "if(__b2c__stackptr == 0){ __b2c__stringstack[__b2c__stackptr] = realloc(__b2c__stringstack[__b2c__stackptr], (strlen($1)+1)*sizeof(char));" >> $g_CFILE
	print -r "strcpy(__b2c__stringstack[__b2c__stackptr], $1);} else __b2c__stringstack[__b2c__stackptr] = strdup($1);" >> $g_CFILE
	print -r "__b2c__typestack[__b2c__stackptr] = 1;" >> $g_CFILE
    # Check if float
    elif [[ "$1" = +(*.*) ]]
    then
	print -r "__b2c__doublestack = (double*)realloc(__b2c__doublestack, (__b2c__stackptr+1)*sizeof(double));" >> $g_CFILE
	print -r "__b2c__doublestack[__b2c__stackptr] = $1;" >> $g_CFILE
	print -r "__b2c__typestack[__b2c__stackptr] = 2;" >> $g_CFILE
    # Check if no alpha chars (then integer value)
    elif [[ "$1" = +(![a-zA-Z]) ]]
    then
	print -r "__b2c__longstack = (long*)realloc(__b2c__longstack, (__b2c__stackptr+1)*sizeof(long));" >> $g_CFILE
	print -r "__b2c__longstack[__b2c__stackptr] = $1;" >> $g_CFILE
	print -r "__b2c__typestack[__b2c__stackptr] = 3;" >> $g_CFILE
    # Assume variable, check if declared before
    elif [[ -n $CHECK ]]
    then
	if [[ $CHECK = +(double*) ]]
	then
	    print -r "__b2c__doublestack = (double*)realloc(__b2c__doublestack, (__b2c__stackptr+1)*sizeof(double));" >> $g_CFILE
	    print -r "__b2c__doublestack[__b2c__stackptr] = $1;" >> $g_CFILE
	    print -r "__b2c__typestack[__b2c__stackptr] = 2;" >> $g_CFILE
	else
	    print -r "__b2c__longstack = (long*)realloc(__b2c__longstack, (__b2c__stackptr+1)*sizeof(long));" >> $g_CFILE
	    print -r "__b2c__longstack[__b2c__stackptr] = $1;" >> $g_CFILE
	    print -r "__b2c__typestack[__b2c__stackptr] = 3;" >> $g_CFILE
	fi
    # Not declared, assume integer variable
    else
	print -r "__b2c__longstack = (long*)realloc(__b2c__longstack, (__b2c__stackptr+1)*sizeof(long));" >> $g_CFILE
	print -r "__b2c__longstack[__b2c__stackptr] = $1;" >> $g_CFILE
	print -r "__b2c__typestack[__b2c__stackptr] = 3;" >> $g_CFILE
    fi

    # Increase stackpointer
    print -r "__b2c__stackptr++;" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Pull
{
    typeset CHECK TARGET STR

    # Check if we have an argument at all
    if [[ "$1" = "PULL" ]]
    then
	print "\nERROR: empty PULL at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Argument must be a variable
    if [[ "$1" = +(![a-zA-Z]) ]]
    then
	print "\nERROR: argument in PULL statement at line $g_COUNTER in file '$g_CURFILE' is not a variable!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Decrease stackpointer again
    print -r "__b2c__stackptr--;" >> $g_CFILE
    print -r "if(__b2c__stackptr < 0) __b2c__stackptr=0;" >> $g_CFILE

    # Get the last value from stack
    if [[ "${1}" = +(*${g_STRINGSIGN}) ]]
    then
    	STR=${1%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN} = NULL;" ${TARGET}`
	if [[ -z $CHECK ]]
	then
	    print -r "char *$1 = NULL;" >> $g_HFILE
	fi
	print -r "if(__b2c__typestack[__b2c__stackptr] == 1) {" >> $g_CFILE
	print -r "$1 = (char*)realloc($1, (strlen(__b2c__stringstack[__b2c__stackptr])+1)*sizeof(char));" >> $g_CFILE
	print -r "strcpy($1, __b2c__stringstack[__b2c__stackptr]); if(__b2c__stackptr > 0) free(__b2c__stringstack[__b2c__stackptr]);}" >> $g_CFILE
    else
	# Variable may not be array, these should be defined with DECLARE
	if [[ "$1" != +(*\[*\]*) && "$VAR" != +(*.*) ]]
	then
	    # Not declared? Assume long
	    CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $1,| $1;|,$1,|,$1;| $1=| ${1%%\[*}\[|,${1%%\[*}\[" | grep -v " noparse "`
	    if [[ -z $CHECK ]]
	    then
		print -r "long $1;" >> $g_HFILE
		CHECK="long "
	    fi
	else
	    # See how var was declared
	    CHECK=`$GREP -E "DIR |FILE |int |long |float |double |char |void |STRING |NUMBER |FLOATING " $TARGET | $GREP -E " ${1%%\[*}" | grep -v " noparse "`
	fi
	# Make sure internal var is copied to var of program
	if [[ "$CHECK" = +(*double *) || "$CHECK" = +(*float *) || "$CHECK" = +(*FLOATING *) ]]
	then
	    print -r "if(__b2c__typestack[__b2c__stackptr] == 2) $1=__b2c__doublestack[__b2c__stackptr];" >> $g_CFILE
	elif [[ "$CHECK" = +(*long *) || "$CHECK" = +(*int *) || "$CHECK" = +(*NUMBER *) ]]
	then
	    print -r "if(__b2c__typestack[__b2c__stackptr] == 3) $1=__b2c__longstack[__b2c__stackptr];" >> $g_CFILE
	else
	    print -r "if(__b2c__typestack[__b2c__stackptr] == 1) {" >> $g_CFILE
	    print -r "$1 = (char*)realloc($1, (strlen(__b2c__stringstack[__b2c__stackptr])+1)*sizeof(char));" >> $g_CFILE
	    print -r "strcpy($1, __b2c__stringstack[__b2c__stackptr]); if(__b2c__stackptr > 0) free(__b2c__stringstack[__b2c__stackptr]);}" >> $g_CFILE
	fi
    fi
}

#-----------------------------------------------------------

function Handle_SubFunc
{
    typeset ARGS TOKEN LEN CHAR DIM ARR CHECK SIZE

    # Check argument
    if [[ `print ${1}` = "SUB" || `print ${1}` = "FUNCTION" ]]
    then
	print "\nERROR: empty SUB/FUNCTION at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if we are in a sub already
    if [[ -n $g_FUNCNAME ]]
    then
	print "\nERROR: cannot define a SUB/FUNCTION within a SUB/FUNCTION at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the funcname
    g_ORIGFUNCNAME=`print ${1%%\(*}"("`
    g_PROTOTYPE=`print ${1%%\(*}"("`

    # Start miniparser to duplicate string arguments, convert spaces
    ARGS=`print -r "${1##*\(}" | tr " " "\001"`
    TOKEN=
    LEN=${#ARGS}

    # Get the characters
    until [[ $LEN -eq 0 ]]
    do
	typeset -L1 CHAR="${ARGS}"
	if [[ $CHAR = "," ]]
	then
	    if [[ ${TOKEN} = +(*STRING*) || ${TOKEN} = +(*char\**) ]]
	    then
		TOKEN=`print ${TOKEN}`
                DIM=${TOKEN##*\[}; ARR=${TOKEN##* }
                if [[ $TOKEN != +(*${g_STRINGSIGN}*) && $TOKEN = +(*\[*\]*) ]]
                then
		    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE],"
	            g_STRINGARGS="$g_STRINGARGS char** ${ARR%%\[*} = __b2c_${ARR%%\[*};"
	            g_PROTOTYPE="$g_PROTOTYPE ${TOKEN},"
                elif [[ $TOKEN != +(*${g_STRINGSIGN}*) ]]
                then
		    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${TOKEN##* },"
	            g_STRINGARGS="$g_STRINGARGS char* ${TOKEN##* } = __b2c_${TOKEN##* };"
	            g_PROTOTYPE="$g_PROTOTYPE ${TOKEN},"
	        elif [[ $TOKEN = +(*\[*\]*) ]]
		then
		    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE],"
		    if [[ -z ${DIM%%\]*} ]]
		    then
			print "\nERROR: cannot pass string array without dimension at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    fi
	            g_STRINGARGS="$g_STRINGARGS char *${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE] = { NULL };"
                    g_STRINGARGS="$g_STRINGARGS for(__b2c__ctr=0; __b2c__ctr<${DIM%%\]*}+$g_OPTION_BASE; __b2c__ctr++){if(__b2c_${ARR%%\[*}[__b2c__ctr]!=NULL) ${ARR%%\[*}[__b2c__ctr] = strdup(__b2c_${ARR%%\[*}[__b2c__ctr]);}"
	            g_STRINGARRAYS="$g_STRINGARRAYS for(__b2c__ctr=0; __b2c__ctr<${DIM%%\]*}+$g_OPTION_BASE; __b2c__ctr++)if(${ARR%%\[*}[__b2c__ctr]!=NULL){free(${ARR%%\[*}[__b2c__ctr]);}"
		    g_PROTOTYPE="$g_PROTOTYPE char *__b2c_${TOKEN##* },"
		else
		    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${TOKEN##* },"
		    g_STRINGARGS="$g_STRINGARGS char* ${TOKEN##* } = strdup(__b2c_${TOKEN##* });"
		    g_LOCALSTRINGS="$g_LOCALSTRINGS ${TOKEN##* }"
		    g_PROTOTYPE="$g_PROTOTYPE ${TOKEN},"
		fi
	    else
		TOKEN=`print ${TOKEN}`
		if [[ $TOKEN = +(*\[*\]*\]*) ]]
		then
		    print "\nERROR: cannot pass multidimensional numeric array at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		elif [[ $TOKEN = +(*\[\]*) ]]
		then
		    g_ORIGFUNCNAME="$g_ORIGFUNCNAME ${TOKEN},"
		elif [[ $TOKEN = +(*\[*\]*) ]]
		then
		    DIM=${TOKEN##*\[}; ARR=${TOKEN##* }
		    g_ORIGFUNCNAME="$g_ORIGFUNCNAME ${TOKEN%% *} __b2c_${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE],"
		    if [[ -z ${DIM%%\]*} ]]
		    then
			print "\nERROR: cannot pass numeric array without dimension at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    fi
		    g_STRINGARGS="$g_STRINGARGS ${TOKEN%% *} ${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE] = { 0 };"
		    g_STRINGARGS="$g_STRINGARGS for(__b2c__ctr=0; __b2c__ctr<${DIM%%\]*}+$g_OPTION_BASE; __b2c__ctr++){ ${ARR%%\[*}[__b2c__ctr] = __b2c_${ARR%%\[*}[__b2c__ctr];}"
		elif [[ $TOKEN = +(*VAR *) ]]
		then
		    print "\nERROR: variable argument list cannot be followed by other arguments at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    g_ORIGFUNCNAME="$g_ORIGFUNCNAME ${TOKEN},"
		fi
		g_PROTOTYPE="$g_PROTOTYPE ${TOKEN},"
	    fi
	    typeset -L0 CHAR=""
	    TOKEN=
	fi
	# Convert back to space
	if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	then
	    TOKEN="${TOKEN} "
	else
	    TOKEN="${TOKEN}${CHAR}"
	fi
	let LEN=${#ARGS}-1
	typeset -R$LEN ARGS="${ARGS}"
    done

    # Last token in the sequence of arguments
    TOKEN=${TOKEN%%\)*}
    TOKEN=`print ${TOKEN}`

    if [[ ${TOKEN} = +(*STRING*) || ${TOKEN} = +(*char\**) ]]
    then
	DIM=${TOKEN##*\[}; ARR=${TOKEN##* }
        if [[ $TOKEN != +(*${g_STRINGSIGN}*) && $TOKEN = +(*\[*\]*) ]]
        then
	    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE])"
	    g_STRINGARGS="$g_STRINGARGS char** ${ARR%%\[*} = __b2c_${ARR%%\[*};"
	    g_PROTOTYPE="$g_PROTOTYPE ${TOKEN})"
        elif [[ $TOKEN != +(*${g_STRINGSIGN}*) ]]
        then
	    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${TOKEN##* })"
	    g_STRINGARGS="$g_STRINGARGS char* ${TOKEN##* } = __b2c_${TOKEN##* };"
	    g_PROTOTYPE="$g_PROTOTYPE ${TOKEN})"
	elif [[ $TOKEN = +(*\[*\]*) ]]
	then
	    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE])"
	    if [[ -z ${DIM%%\]*} ]]
	    then
		print "\nERROR: cannot pass string array without dimension at line $g_COUNTER in file '$g_CURFILE'!"
		exit 1
	    fi
	    g_STRINGARGS="$g_STRINGARGS char *${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE] = { NULL };"
            g_STRINGARGS="$g_STRINGARGS for(__b2c__ctr=0; __b2c__ctr<${DIM%%\]*}+$g_OPTION_BASE; __b2c__ctr++){if(__b2c_${ARR%%\[*}[__b2c__ctr]!=NULL) ${ARR%%\[*}[__b2c__ctr] = strdup(__b2c_${ARR%%\[*}[__b2c__ctr]);}"
	    g_STRINGARRAYS="$g_STRINGARRAYS for(__b2c__ctr=0; __b2c__ctr<${DIM%%\]*}+$g_OPTION_BASE; __b2c__ctr++)if(${ARR%%\[*}[__b2c__ctr]!=NULL){free(${ARR%%\[*}[__b2c__ctr]);}"
	    g_PROTOTYPE="$g_PROTOTYPE char *__b2c_${TOKEN##* })"
	else
	    g_ORIGFUNCNAME="$g_ORIGFUNCNAME char *__b2c_${TOKEN##* })"
	    g_STRINGARGS="$g_STRINGARGS char* ${TOKEN##* } = strdup(__b2c_${TOKEN##* });"
	    g_LOCALSTRINGS="$g_LOCALSTRINGS ${TOKEN##* }"
	    g_PROTOTYPE="$g_PROTOTYPE ${TOKEN})"
	fi
    else
	if [[ -z ${TOKEN} || ${TOKEN} = `print ${1}` ]]
	then
	    TOKEN="void"
	fi
	if [[ $TOKEN = +(*\[*\]*\]*) ]]
	then
	    print "\nERROR: cannot pass multidimensional numeric array at line $g_COUNTER in file '$g_CURFILE'!"
	    exit 1
	elif [[ $TOKEN = +(*\[\]*) ]]
	then
	    g_ORIGFUNCNAME="$g_ORIGFUNCNAME ${TOKEN})"
	elif [[ $TOKEN = +(*\[*\]*) ]]
	then
            DIM=${TOKEN##*\[}; ARR=${TOKEN##* }
	    g_ORIGFUNCNAME="$g_ORIGFUNCNAME ${TOKEN%% *} __b2c_${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE])"
	    if [[ -z ${DIM%%\]*} ]]
	    then
		print "\nERROR: cannot pass numeric array without dimension at line $g_COUNTER in file '$g_CURFILE'!"
		exit 1
	    fi
	    g_STRINGARGS="$g_STRINGARGS ${TOKEN%% *} ${ARR%%\[*}[${DIM%%\]*}+$g_OPTION_BASE] = { 0 };"
            g_STRINGARGS="$g_STRINGARGS for(__b2c__ctr=0; __b2c__ctr<${DIM%%\]*}+$g_OPTION_BASE; __b2c__ctr++){ ${ARR%%\[*}[__b2c__ctr] = __b2c_${ARR%%\[*}[__b2c__ctr];}"
	elif [[ $TOKEN = +(*VAR *) ]]
	then
	    if [[ $g_PROTOTYPE = +(*,*) ]]
	    then
		print "\nERROR: variable argument list cannot be preceded by other arguments at line $g_COUNTER in file '$g_CURFILE'!"
		exit 1
	    fi
	    if [[ "${TOKEN}" != +(* SIZE *) ]]
	    then
		print "\nERROR: variable argument list lacks SIZE argument at line $g_COUNTER in file '$g_CURFILE'!"
		exit 1
	    fi
	    ARR=${TOKEN#* }; ARR=${ARR%%SIZE *}; SIZE=${TOKEN##* }
	    if [[ "${ARR}" != +(*${g_STRINGSIGN}*) ]]
	    then
		print "\nERROR: variable argument list is not string at line $g_COUNTER in file '$g_CURFILE'!"
		exit 1
	    fi
	    CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $g_HFILE | $GREP -E " $SIZE,| $SIZE;|,$SIZE,|,$SIZE;| $SIZE=| ${SIZE%%\[*}\[|,${SIZE%%\[*}\[" | grep -v " noparse "`
	    if [[ -z $CHECK ]]
	    then
		g_STRINGARGS="$g_STRINGARGS long ${SIZE};"
	    fi
	    g_STRINGARGS="$g_STRINGARGS long __b2c__var_$ARR = $g_OPTION_BASE; va_list __b2c__ap; char **${ARR} = NULL; char* __b2c__va = NULL; $ARR = (char **)realloc($ARR, (__b2c__var_$ARR+1) * sizeof(char*));"
	    g_STRINGARGS="$g_STRINGARGS va_start(__b2c__ap, __b2c__name); ${ARR}[__b2c__var_$ARR] = strdup(__b2c__name); while (${ARR}[__b2c__var_$ARR] != NULL) {__b2c__var_$ARR++; $ARR = (char **)realloc($ARR, (__b2c__var_$ARR+1) * sizeof(char*));"
	    g_STRINGARGS="$g_STRINGARGS __b2c__va = va_arg(__b2c__ap, char*); if(__b2c__va!=NULL) ${ARR}[__b2c__var_$ARR] = strdup(__b2c__va); else ${ARR}[__b2c__var_$ARR] = NULL; }"
	    g_STRINGARGS="$g_STRINGARGS va_end(__b2c__ap); ${SIZE} = __b2c__var_$ARR - $g_OPTION_BASE; if(__b2c__var_$ARR > 0) __b2c__var_$ARR--;"
	    g_PROTOTYPE="__${g_PROTOTYPE}"
	    g_ORIGFUNCNAME="${g_ORIGFUNCNAME}char *__b2c__name, ...)"
	    TOKEN="char*, ..."
	    g_STRINGARRAYS="$g_STRINGARRAYS if($ARR != NULL) {for(__b2c__ctr=$g_OPTION_BASE; __b2c__ctr<=__b2c__var_$ARR; __b2c__ctr++) if($ARR[__b2c__ctr]!=NULL){free($ARR[__b2c__ctr]);} free($ARR);}"
	else
	    g_ORIGFUNCNAME="$g_ORIGFUNCNAME ${TOKEN})"
	fi
	g_PROTOTYPE="$g_PROTOTYPE ${TOKEN})"
    fi

    # Get original function name
    if [[ "$g_ORIGFUNCNAME" = +(* \(*\)*) ]]
    then
	g_FUNCNAME=`print ${g_ORIGFUNCNAME%% *}`
    elif [[ "$g_ORIGFUNCNAME" = +(*\(*\)*) ]]
    then
	g_FUNCNAME=`print ${g_ORIGFUNCNAME%%\(*}`
    else
	g_FUNCNAME=`print $g_ORIGFUNCNAME`
    fi

    # Add macro in case of VAR argument
    if [[ $TOKEN = +(* ...*) ]]
    then
	print -r "#define ${g_FUNCNAME}(...) __${g_FUNCNAME}(\"${g_FUNCNAME}\", __VA_ARGS__, NULL)" >> $g_HFILE
	g_ORIGFUNCNAME="__${g_ORIGFUNCNAME}"
    fi

    # Make symbol known to parser
    g_IMPORTED="$g_FUNCNAME $g_IMPORTED"

    # Switch to header file
    g_COPY_CFILE=$g_CFILE
    g_CFILE=${g_CFILE%.*}.$g_FUNCNAME.tmp

    # Save CATCH routine
    g_ORIGCATCHGOTO="$g_CATCHGOTO"
    g_CATCHGOTO="__B2C__PROGRAM__EXIT"

    touch $g_CFILE
}

#-----------------------------------------------------------

function Handle_Endsub
{
    typeset STR

    # Put prototype to header file
    print -r "void ${g_PROTOTYPE}; /* noparse */" >> $g_HFILE
    g_PROTOTYPE=

    # Get original function name
    print -r "/* Created with KSH BaCon $g_VERSION - (c) Peter van Eerten - GPL v3 */" > ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    print -r "/* noparse $g_CURFILE BACON LINE $g_COUNTER */" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    if [[ "$g_ORIGFUNCNAME" = +(* \(*\)*) ]]
    then
	print -r "void ${g_ORIGFUNCNAME} {" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    elif [[ "$g_ORIGFUNCNAME" = +(*\(*\)*) ]]
    then
	print -r "void ${g_ORIGFUNCNAME} {" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    else
	print -r "void ${g_FUNCNAME}(void) {" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    fi

    # Finalize sub
    print -r "${g_STRINGARGS}" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    cat $g_CFILE >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h

    # Free strings variables if there are any
    for STR in $g_LOCALSTRINGS
    do
	print -r "if($STR != NULL) free(${STR});" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    done
    print -r "${g_STRINGARRAYS}" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    print -r "__B2C__PROGRAM__EXIT: ;" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h
    print -r "}" >> ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h

    # Include header file
    if [[ ${g_INCLUDE_FILES} != +(*${g_CURFILE%\.*}.$g_FUNCNAME.h*) ]]
    then
	g_INCLUDE_FILES="$g_INCLUDE_FILES ${g_CURFILE%\.*}.$g_FUNCNAME.h"
    fi

    # Add to total filelist
    g_TMP_FILES="$g_TMP_FILES ${g_TEMPDIR}/${g_CURFILE%.*}.$g_FUNCNAME.h"

    # Delete temp funcfile
    rm $g_CFILE

    # Restore mainfile
    g_CFILE=$g_COPY_CFILE

    # Restore CATCH routine
    g_CATCHGOTO="$g_ORIGCATCHGOTO"

    # Reset variables
    g_ORIGFUNCNAME=
    g_FUNCNAME=
    g_LOCALSTRINGS=
    g_STRINGARRAYS=
    g_STRINGARGS=
}

#-----------------------------------------------------------

function Handle_Deffn
{
    typeset SYM
	
    # Check if we have an argument at all
    if [[ "$1" = "DEF" ]]
    then
	print "\nERROR: empty DEF FN at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Translate to C macro
    SYM=${1#* }

    print -r "#define ${SYM%%=*} (${SYM#*=})" >> $g_HFILE

    # Make symbol known to parser
    g_IMPORTED="${SYM%%\(*} $g_IMPORTED"
}

#-----------------------------------------------------------

function Handle_Const
{
    # Check if we have an argument at all
    if [[ "$1" = "CONST" ]]
    then
	print "\nERROR: empty CONST at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    print -r "#define ${1%%=*} (${1#*=})" >> $g_HFILE
}

#-----------------------------------------------------------

function Handle_Seek
{
    typeset FILE OFFSET WHENCE

    # Check if we have an argument at all
    if [[ "$1" = "SEEK" ]]
    then
	print "\nERROR: empty SEEK at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if TO is available
    if [[ "$1" != +(* OFFSET *) ]]
    then
	print "\nERROR: Missing OFFSET in SEEK statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the variablename without surrounding spaces
    FILE=`print ${1%% OFFSET *}`;

    # Get filedescriptor
    OFFSET=`print ${1##* OFFSET }`

    WHENCE=

    # Check if WHENCE is available
    if [[ "$1" = +(* WHENCE *) ]]
    then
	WHENCE=${OFFSET##* WHENCE }
	OFFSET=${OFFSET%% WHENCE *}
    fi

    # Convert to C function
    case $WHENCE in
	+(START) )
	    print -r "fseek($FILE, $OFFSET, SEEK_SET);" >> $g_CFILE;;
	+(CURRENT) )
	    print -r "fseek($FILE, $OFFSET, SEEK_CUR);" >> $g_CFILE;;
	+(END) )
	    print -r "fseek($FILE, $OFFSET, SEEK_END);" >> $g_CFILE;;
	*)
	    print -r "fseek($FILE, $OFFSET, SEEK_SET);" >> $g_CFILE;;
    esac
}

#-----------------------------------------------------------

function Handle_Copy
{
    typeset FROM TO

    # Check if we have an argument at all
    if [[ "$1" = "COPY" ]]
    then
	print "\nERROR: empty COPY at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in COPY statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the filename and copyname
    FROM=`print ${1%% TO *}`
    TO=`print ${1##* TO }`

    # Translate to C function
    print -r "__b2c__inFile = fopen($FROM, \"r\"); __b2c__outFile = fopen($TO, \"w\"); __b2c__Byte = 0;" >> $g_CFILE
    print -r "if (__b2c__inFile != NULL && __b2c__outFile != NULL){while(__b2c__Byte!=EOF){" >> $g_CFILE
    print -r "__b2c__Byte=fgetc(__b2c__inFile); if(__b2c__Byte!=EOF){" >> $g_CFILE
    print -r "fputc(__b2c__Byte,__b2c__outFile); }}" >> $g_CFILE
    print -r "fclose(__b2c__inFile); fclose(__b2c__outFile);}" >> $g_CFILE
    print -r "else {if(!__b2c__trap){ERROR = 2; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Rename
{
    typeset FROM TO

    # Check if we have an argument at all
    if [[ "$1" = "RENAME" ]]
    then
	print "\nERROR: empty RENAME at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi
    
    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in RENAME statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the filename and copyname
    FROM=`print ${1%% TO *}`
    TO=`print ${1##* TO }`

    # Translate to C function
    print -r "if(rename($FROM, $TO) < 0) {if(!__b2c__trap){ERROR = 9; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Color
{
    typeset TO FROM BFG COL

    # Check if we have an argument at all
    if [[ "$1" = "COLOR" ]]
    then
	print "\nERROR: empty COLOR at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if we need to reset
    if [[ "$1" = +(*RESET*) ]]
    then
	print -r "fprintf(stdout,\"\033[0m\");" >> $g_CFILE
    elif [[ "$1" = +(*INTENSE*) ]]
    then
	print -r "fprintf(stdout,\"\033[1m\");" >> $g_CFILE
    elif [[ "$1" = +(*INVERSE*) ]]
    then
	print -r "fprintf(stdout,\"\033[7m\");" >> $g_CFILE
    elif [[ "$1" = +(*NORMAL*) ]]
    then
	print -r "fprintf(stdout,\"\033[22m\");" >> $g_CFILE
    # Check if TO is available
    elif [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in COLOR statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    else
	# Get the target and colorname
	FROM=`print ${1%% TO *}`
	case $FROM in
	    FG)
		BFG=3;;
	    BG)
		BFG=4;;
	    [01])
		((BFG=${FROM}+3));;
	    *)
		BFG=${FROM};;
	esac

	TO=`print ${1##* TO }`
	case $TO in
	    BLACK)
		COL=0;;
	    RED)
		COL=1;;
	    GREEN)
		COL=2;;
	    YELLOW)
		COL=3;;
	    BLUE)
		COL=4;;
	    MAGENTA)
		COL=5;;
	    CYAN)
		COL=6;;
	    WHITE)
		COL=7;;
	    *)
		COL=${TO};;
	esac

	# Now select color
	print -r "fprintf(stdout,\"\033[%ld%ldm\", (long)${BFG}, (long)${COL});" >> $g_CFILE
    fi
}

#-----------------------------------------------------------

function Handle_Gotoxy
{
    typeset X Y

    # Check if we have an argument at all
    if [[ "$1" = "GOTOXY" ]]
    then
	print "\nERROR: empty GOTOXY at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the target and colorname
    if [[ "$1" = +(*,*) ]]
    then
	X=`print ${1%%,*}`
	Y=`print ${1##*,}`
    else
	print "\nERROR: missing coordinate in GOTOXY at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Translate to C
    print -r "fprintf(stdout, \"\033[%ld;%ldH\",(long)(${Y}),(long)(${X}));fflush(stdout);" >> $g_CFILE
}

#-----------------------------------------------------------

function Handle_Split
{
    typeset SOURCE REST BY TO SIZE TARGET CHECK

    # Check if we have an argument at all
    if [[ "$1" = "SPLIT" ]]
    then
	print "\nERROR: empty SPLIT at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi
    
    # Check if BY is available
    if [[ "$1" != +(* BY *) ]]
    then
	print "\nERROR: Missing BY in SPLIT statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in SPLIT statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if SIZE is available
    if [[ "$1" != +(* SIZE *) ]]
    then
	print "\nERROR: Missing SIZE in SPLIT statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the source string
    SOURCE=`print ${1%% BY *}`
    REST=`print ${1##* BY }`

    BY=`print ${REST%% TO *}`
    REST=`print ${REST##* TO }`

    TO=`print ${REST%% SIZE *}`
    SIZE=`print ${REST##* SIZE }`

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Variable may not be array, these should be defined with DECLARE
    if [[ "$SIZE" != +(*\[*\]*) && "$SIZE" != +(*.*) ]]
    then
	# Declare variable if not done yet, assuming long
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $SIZE,| $SIZE;|,$SIZE,|,$SIZE;| $SIZE=| ${SIZE%%\[*}\[|,${SIZE%%\[*}\[" | grep -v " noparse "`
	if [[ -z $CHECK ]]
	then
	    print -r "long $SIZE;" >> $g_HFILE
	fi
    fi

    # Translate to C code
    if [[ -n $g_FUNCNAME ]]
    then
	if [[ $g_STRINGARGS != +(*\*\*$TO*) ]]
	then
	    g_STRINGARGS="$g_STRINGARGS char **$TO = NULL; int __b2c__split__$TO = $g_OPTION_BASE;" 
	fi
    else
	if [[ -z `grep "$TO = NULL;" $g_HFILE` ]]
	then
	    print -r "char **$TO = NULL; int __b2c__split__$TO = $g_OPTION_BASE;" >> $g_HFILE
	fi
    fi

    # If the split array was used before in a loop, clear it
    print -r "if($TO != NULL) {for(__b2c__ctr = $g_OPTION_BASE; __b2c__ctr <= __b2c__split__$TO; __b2c__ctr++) if($TO[__b2c__ctr]!=NULL)" >> $g_CFILE
    print -r "{free($TO[__b2c__ctr]);} free($TO); $TO = NULL;} __b2c__split__$TO = $g_OPTION_BASE;" >> $g_CFILE

    # Run the SPLIT code
    print -r "if ($SOURCE != NULL && strlen($SOURCE) > 0 && $BY != NULL && strlen($BY) > 0) {__b2c__split_tmp = strdup($SOURCE); __b2c__split_ptr = __b2c__split_tmp; while((__b2c__split = strstr(__b2c__split_tmp, $BY)) != NULL)" >> $g_CFILE
    print -r "{if(__b2c__split-__b2c__split_tmp >= 0) {$TO = (char **)realloc($TO, (__b2c__split__$TO + 1) * sizeof(char*)); if(__b2c__split-__b2c__split_tmp == 0){ $TO[__b2c__split__$TO] = calloc(1, sizeof(char)); if(__b2c__collapse == 0) __b2c__split__$TO++;" >> $g_CFILE
    print -r "else free($TO[__b2c__split__$TO]);} else $TO[__b2c__split__$TO++] = __b2c__strndup(__b2c__split_tmp, __b2c__split-__b2c__split_tmp);}" >> $g_CFILE
    print -r "__b2c__split_tmp = __b2c__split + strlen($BY);} if(strlen(__b2c__split_tmp) >= 0) {$TO = (char **)realloc($TO, (__b2c__split__$TO + 1) * sizeof(char*)); if(strlen(__b2c__split_tmp) == 0)" >> $g_CFILE
    print -r "{$TO[__b2c__split__$TO] = calloc(1, sizeof(char)); if (__b2c__collapse == 0) __b2c__split__$TO++; else free($TO[__b2c__split__$TO]);}" >> $g_CFILE
    print -r "else $TO[__b2c__split__$TO++] = strdup(__b2c__split_tmp);} free(__b2c__split_ptr);} $SIZE = __b2c__split__$TO - $g_OPTION_BASE; if(__b2c__split__$TO > 0) __b2c__split__$TO--;" >> $g_CFILE

    # Add declared array to array list if we are in a function
    if [[ -n $g_FUNCNAME &&  $g_STRINGARRAYS != +(*$TO\[*) ]]
    then
	g_STRINGARRAYS="$g_STRINGARRAYS if($TO != NULL) {for(__b2c__ctr=$g_OPTION_BASE; __b2c__ctr<=__b2c__split__$TO; __b2c__ctr++) if($TO[__b2c__ctr]!=NULL){free($TO[__b2c__ctr]);} free($TO);}"
    fi
}

#-----------------------------------------------------------

function Handle_Sort
{
    typeset STR CHECK DIM TARGET TYPE VAR DOWN

    # Check if we have an argument at all
    if [[ "$1" = "SORT" ]]
    then
	print "\nERROR: empty SORT at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    # Check on SIZE argument
    if [[ ${1} = +(* SIZE *) ]]
    then
	DIM=${1##* SIZE }
	VAR=${1%% SIZE *}
    else
	VAR=${1}
    fi

    # Check on DOWN argument
    if [[ ${1} = +(* DOWN*) ]]
    then
	DIM=${DIM%% DOWN}
	VAR=${VAR%% DOWN}
	DOWN="_down"
    else
	DOWN=
    fi

    # Declared before?
    if [[ "${VAR}" = +(*${g_STRINGSIGN}) ]]
    then
	STR=${VAR%${g_STRINGSIGN}*}
	CHECK=`$GREP -E "char \*${STR}${g_STRINGSIGN}\[" ${TARGET}`
    else
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " ${VAR}" | grep -v " noparse "`
    fi

    # Verify if the array was declared at SPLIT
    if [[ -z ${CHECK} ]]
    then
	CHECK=`$GREP -E "__b2c__split__${STR}${g_STRINGSIGN}" $TARGET`
	if [[ -z ${CHECK} ]]
	then
	    print "\nERROR: argument to SORT not an array at line $g_COUNTER in file '$g_CURFILE'!"
	    exit 1
	elif [[ -z ${DIM} ]]
	then
	    DIM="__b2c__split__${VAR}+1"
	fi
    elif [[ -z $DIM ]]
    then
	DIM=${CHECK##*\[}; DIM=${DIM%%\]*}
    fi

    # Check if we have a string
    if [[ "${VAR}" = +(*${g_STRINGSIGN}) ]]
    then
	print -r "qsort(&$VAR[$g_OPTION_BASE], ${DIM}-$g_OPTION_BASE, sizeof(char*), __b2c__sortstr$DOWN);" >> $g_CFILE
    # It is a value
    else
	TYPE=${CHECK% *}
	if [[ $TYPE = +(*double*) || $TYPE = +(*FLOATING*) ]]
	then
	    print -r "qsort(&$VAR[$g_OPTION_BASE], ${DIM}-$g_OPTION_BASE, sizeof(double), __b2c__sortnrd$DOWN);" >> $g_CFILE
	elif [[ $TYPE = +(*float*) ]]
	then
	    print -r "qsort(&$VAR[$g_OPTION_BASE], ${DIM}-$g_OPTION_BASE, sizeof(float), __b2c__sortnrf$DOWN);" >> $g_CFILE
	elif [[ $TYPE = +(*long*) ||  $TYPE = +(*NUMBER*) ]]
	then
	    print -r "qsort(&$VAR[$g_OPTION_BASE], ${DIM}-$g_OPTION_BASE, sizeof(long), __b2c__sortnrl$DOWN);" >> $g_CFILE
	else
	    print -r "qsort(&$VAR[$g_OPTION_BASE], ${DIM}-$g_OPTION_BASE, sizeof(int), __b2c__sortnri$DOWN);" >> $g_CFILE
	fi
    fi
}

#-----------------------------------------------------------

function Handle_Alias
{
    typeset ORG NEW

    # Check if we have an argument at all
    if [[ "$1" = "ALIAS" ]]
    then
	print "\nERROR: empty ALIAS at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: missing TO in ALIAS statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the source string
    ORG=`print -r ${1%% TO *} | tr -d "\042"`
    NEW=`print -r ${1##* TO } | tr -d "\042"`

    print -r "#define $NEW $ORG" >> $g_HFILE
    g_IMPORTED="$NEW $g_IMPORTED"
}

#-----------------------------------------------------------

function Handle_Lookup
{
    typeset SOURCE REST TO SIZE TARGET CHECK

    # Check if we have an argument at all
    if [[ "$1" = "LOOKUP" ]]
    then
	print "\nERROR: empty LOOKUP at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in LOOKUP statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if SIZE is available
    if [[ "$1" != +(* SIZE *) ]]
    then
	print "\nERROR: Missing SIZE in LOOKUP statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the source string
    SOURCE=`print ${1%% TO *}`
    REST=`print ${1##* TO }`

    TO=`print ${REST%% SIZE *}`
    SIZE=`print ${REST##* SIZE }`

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Variable may not be array, these should be defined with DECLARE
    if [[ "$SIZE" != +(*\[*\]*) && "$SIZE" != +(*.*) ]]
    then
	# Declare variable if not done yet, assuming long
	CHECK=`$GREP -E "DIR|FILE|int|long|float|double|char|void|STRING|NUMBER|FLOATING" $TARGET | $GREP -E " $SIZE,| $SIZE;|,$SIZE,|,$SIZE;| $SIZE=| ${SIZE%%\[*}\[|,${SIZE%%\[*}\[" | grep -v " noparse "`
	if [[ -z $CHECK ]]
	then
	    print -r "long $SIZE;" >> $g_HFILE
	fi
    fi

    # Translate to C code
    if [[ -n $g_FUNCNAME ]]
    then
	if [[ $g_STRINGARGS != +(*\*\*$TO*) ]]
	then
	    g_STRINGARGS="$g_STRINGARGS char **$TO = NULL; int __b2c__split__$TO = $g_OPTION_BASE;" 
	fi
    else
	if [[ -z `grep "$TO = NULL;" $g_HFILE` ]]
	then
	    print -r "char **$TO = NULL; int __b2c__split__$TO = $g_OPTION_BASE;" >> $g_HFILE
	fi
    fi

    # If the split array was used before in a loop, clear it
    print -r "if($TO != NULL) {for(__b2c__ctr=$g_OPTION_BASE; __b2c__ctr <= __b2c__split__$TO; __b2c__ctr++) if($TO[__b2c__ctr]!=NULL)" >> $g_CFILE
    print -r "{free($TO[__b2c__ctr]);} free($TO); $TO = NULL;} __b2c__split__$TO = $g_OPTION_BASE;" >> $g_CFILE

    # Run the LOOKUP code
    print -r "for(__b2c__ctr = $g_OPTION_BASE; __b2c__ctr < __b2c__${SOURCE}_idx + $g_OPTION_BASE; __b2c__ctr++)" >> $g_CFILE
    print -r "{$TO = (char **)realloc($TO, (__b2c__split__$TO + 1) * sizeof(char*));" >> $g_CFILE
    print -r "$TO[__b2c__split__$TO++] = strdup(__b2c__${SOURCE}[__b2c__ctr-$g_OPTION_BASE].key);} $SIZE = __b2c__split__$TO - $g_OPTION_BASE;if(__b2c__split__$TO > 0) __b2c__split__$TO--;" >> $g_CFILE

    # Add declared array to array list if we are in a function
    if [[ -n $g_FUNCNAME && $g_STRINGARRAYS != +(*$TO\[*) ]]
    then
	g_STRINGARRAYS="$g_STRINGARRAYS if($TO != NULL) {for(__b2c__ctr=$g_OPTION_BASE; __b2c__ctr <= __b2c__split__$TO; __b2c__ctr++) if($TO[__b2c__ctr]!=NULL){free($TO[__b2c__ctr]);} free($TO);}"
    fi
}

#-----------------------------------------------------------

function Handle_Relate
{
    typeset SOURCE TO TARGET CHECK STR

    # Check if we have an argument at all
    if [[ "$1" = "RELATE" ]]
    then
	print "\nERROR: empty RELATE at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Check if TO is available
    if [[ "$1" != +(* TO *) ]]
    then
	print "\nERROR: Missing TO in RELATE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Get the source string
    SOURCE=`print ${1%% TO *}`
    TO=`print ${1##* TO } | tr "," " "`

    # Determine target
    if [[ -n $g_FUNCNAME ]]
    then
	TARGET="$g_CFILE $g_HFILE"
    else
	TARGET=$g_HFILE
    fi

    touch $TARGET

    # Check if variable is declared as ASSOC
    CHECK=`$GREP -E "__b2c__${SOURCE}_type" $TARGET`
    if [[ -z $CHECK ]]
    then
	print "\nERROR: Variable '$SOURCE' not declared as ASSOC in RELATE statement at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Assign relations
    for STR in ${TO}
    do
	CHECK=`$GREP -E "__b2c__${STR}_type" $TARGET`
	if [[ -z $CHECK ]]
	then
	    print "\nERROR: Variable '$STR' not declared as ASSOC in RELATE statement at line $g_COUNTER in file '$g_CURFILE'!"
	    exit 1
	fi
	g_RELATE[${g_RELATE_CTR}]="$SOURCE ${STR}"
	((g_RELATE_CTR+=1))
    done
}

#-----------------------------------------------------------

function Handle_Data
{
    typeset LINE VAR LEN IN_STRING CHAR ESCAPED

    # Check if we have an argument at all
    if [[ "$1" = "DATA" ]]
    then
	print "\nERROR: empty DATA at line $g_COUNTER in file '$g_CURFILE'!"
	exit 1
    fi

    # Start miniparser to see if we need to print something, convert spaces
    LINE=`print -r "${1}" | tr " " "\001"`
    VAR=
    LEN=${#LINE}
    IN_STRING=0

    # Get the characters
    until [[ $LEN -eq 0 ]]
    do
	typeset -L1 CHAR="${LINE}"
	case $CHAR in
	    ",")
		if [[ $IN_STRING -eq 0 ]]
		then
		    # Check if var is string var
		    if [[ "${VAR}" = +(*${g_DQUOTESIGN}*) ]]
		    then
			print -r "${VAR}, " >> $STRINGARRAYFILE
		    else
			print -r "${VAR}, " >> $FLOATARRAYFILE
		    fi
		    typeset -L0 CHAR=""
		    ESCAPED=0
		    VAR=
		fi;;
	    "\\")
		ESCAPED=1;;
	    "\"")
		if [[ $ESCAPED -eq 0 ]]
		then
		    if [[ $IN_STRING -eq 0 ]]
		    then
			IN_STRING=1
		    else
			IN_STRING=0
		    fi
		fi
		ESCAPED=0;;
	    *)
		ESCAPED=0;;
	esac
	# Convert back to space
	if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	then
	    VAR="${VAR} "
	else
	    VAR="${VAR}${CHAR}"
	fi
	let LEN=${#LINE}-1
	typeset -R$LEN LINE="${LINE}"
    done

    # Write last element to file
    if [[ "${VAR}" = +(*${g_DQUOTESIGN}*) ]]
    then
	print -r "${VAR}, " >> $STRINGARRAYFILE
    else
	print -r "${VAR}, " >> $FLOATARRAYFILE
    fi
}

#-----------------------------------------------------------
#
# Simple parser to tokenize line.
#
# Each line should begin with a statement.
# The rest of the line may contain functions, these are
#   converted using C macros.
#
#-----------------------------------------------------------

function Parse_Line
{
    typeset FOUND SYM INC COPY_COUNTER COPY_CURFILE STATEMENT
    typeset LEN SEQ TOTAL EXP LINE TO_PARSE

    # Get statement without spaces
    STATEMENT=`print -r "${1%% *}"`

    # Check if enclosed IF/ELIF/ELSE needs to be closed
    if [[ $g_IF_PARSE -eq 1 ]]
    then
	if [[ "${STATEMENT}" != +(ELIF*) && "${STATEMENT}" != +(ELSE*) ]]
	then
	    print -r "}" >> $g_CFILE
	    g_IF_PARSE=0
	fi
    fi

    # In TRACE MODE show linenr and code
    if [[ $g_TRACE -eq 1 && ${1} != +(*FUNCTION *) && ${1} != +(*SUB *) ]]
    then
	print -r "if(__b2c__getch() == 27) exit(EXIT_SUCCESS); /* noparse */" >> $g_CFILE
	LINE=`print "${1}" | tr "\042" "\047"`
	print -r "fprintf(stderr, \"$g_CURFILE %d: ${LINE}\n\", $g_COUNTER); /* noparse */" >> $g_CFILE
    fi

    # See if we need to pass C code
    if [[ $g_USE_C -eq 1 ]]
    then
	if [[ "${STATEMENT}" = "END" || "${STATEMENT}" = "ENDUSEC" ]]
	then
	    let g_USE_C=0
	else
	    print -r "${1}" >>  $g_CFILE
	fi
    else
	case "${STATEMENT}" in
	    "USEC")
		let g_USE_C=1;;
	    "PRINT")
		Handle_Print "${1#* }";;
	    "INPUT")
		Handle_Input "${1#* }";;
	    "FOR")
                ((g_LOOPCTR+=1))
		Handle_For "${1#* }";;
	    "NEXT")
		print -r "}" >> $g_CFILE
                if [[ $g_LOOPCTR -gt 0 ]]
                then
                    ((g_LOOPCTR-=1))
                    if [[ $g_LOOPCTR -gt 0 ]]
                    then
                        print -r "if(__b2c__break_ctr) {__b2c__break_ctr--; if (!__b2c__break_ctr){if(__b2c__break_flag == 1) break; else continue;} else break; }" >> $g_CFILE
                    fi
                fi;;
	    "IF")
		g_IF_PARSE=0
		# Check if THEN is available
		if [[ "${1}" != +(* THEN*) ]]
		then
		    print "\nERROR: Missing THEN in IF statement at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    SYM="${1#* }"
		    # Translate function to C function
                    Parse_Equation "${SYM% THEN*}"
		    print -r "if(${g_EQUATION}){" >> $g_CFILE
		    if [[ ${SYM##* THEN } != +(*THEN*) ]]
		    then
			Tokenize "${SYM##* THEN }"
			g_IF_PARSE=1
		    fi
		fi;;
	    "ELIF")
		g_IF_PARSE=0
		# Check if THEN is available
		if [[ "${1}" != +(* THEN*) ]]
		then
		    print "\nERROR: Missing THEN in ELIF statement at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    SYM="${1#* }"
		    # Translate function to C function
                    Parse_Equation "${SYM% THEN*}"
		    print -r "} else if(${g_EQUATION}){" >> $g_CFILE
		    if [[ ${SYM##* THEN } != +(*THEN*) ]]
		    then
			Tokenize "${SYM##* THEN }"
			g_IF_PARSE=1
		    fi
		fi;;
	    "ELSE")
		g_IF_PARSE=0
		print -r "} else {" >> $g_CFILE
		if [[ ${1##*ELSE } != +(*ELSE*) ]]
		then
		    Tokenize "${1##*ELSE }"
		    g_IF_PARSE=1
		fi;;
	    "ENDIF")
		print -r "}" >> $g_CFILE;;
	    "WHILE")
                ((g_LOOPCTR+=1))
		Handle_While "${1#* }";;
	    "WEND")
		print -r "}" >> $g_CFILE
                if [[ $g_LOOPCTR -gt 0 ]]
                then
                    ((g_LOOPCTR-=1))
                    if [[ $g_LOOPCTR -gt 0 ]]
                    then
                        print -r "if(__b2c__break_ctr) {__b2c__break_ctr--; if (!__b2c__break_ctr){if(__b2c__break_flag == 1) break; else continue;} else break; }" >> $g_CFILE
                    fi
                fi;;
	    "BREAK")
                # Check argument
		if [[ "${1%% *}" != "${1#* }" && ${1#* } != "0" ]]
		then
                    print -r "__b2c__break_ctr = ${1#* }-1; __b2c__break_flag = 1;" >> $g_CFILE
                fi
		print -r "break;" >> $g_CFILE;;
            "CONTINUE")
                # Check argument
		if [[ "${1%% *}" != "${1#* }" && ${1#* } != "0" ]]
		then
                    print -r "__b2c__break_ctr = ${1#* }-1; __b2c__break_flag = 2;" >> $g_CFILE
                fi
                if [[ ${1#* } -gt 1 ]]
                then
		    print -r "break;" >> $g_CFILE
                else
		    print -r "continue;" >> $g_CFILE
                fi;;
	    "REPEAT")
                ((g_LOOPCTR+=1))
		print -r "do{" >> $g_CFILE;;
	    "UNTIL")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty UNTIL at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Convert to legal C code
                    Parse_Equation "${1#* }"
		    print -r "} while(!(${g_EQUATION}));" >> $g_CFILE
                    if [[ $g_LOOPCTR -gt 0 ]]
                    then
                        ((g_LOOPCTR-=1))
                        if [[ $g_LOOPCTR -gt 0 ]]
                        then
                            print -r "if(__b2c__break_ctr) {__b2c__break_ctr--; if (!__b2c__break_ctr){if(__b2c__break_flag == 1) break; else continue;} else break; }" >> $g_CFILE
                        fi
                    fi
		fi;;
	    "LET")
		Handle_Let "${1#* }";;
	    +(REM*) )
		;;
	    +(\'*) )
		;;
	    "SYSTEM")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty SYSTEM at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    print -r "SYSTEM (${1#* });" >> $g_CFILE
		fi;;
	    "SLEEP")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty SLEEP at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    print -r "usleep(${1#* }*1000);" >> $g_CFILE
		fi;;
	    "OPEN")
		Handle_Open "${1#* }";;
	    "CLOSE")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty CLOSE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    if [[ "${1}" = +(* FILE *) ]]
		    then
			print -r "fclose(${1##* });" >> $g_CFILE
		    elif [[ "${1}" = +(* DIRECTORY *) ]]
		    then
			print -r "closedir(${1##* });" >> $g_CFILE
		    elif [[ "${1}" = +(* MEMORY *) ]]
		    then
			print -r "${1##* } = NULL;" >> $g_CFILE
		    elif [[ "${1}" = +(* NETWORK *) || "${1}" = +(* SERVER *) ]]
		    then
			print -r "close(${1##* });" >> $g_CFILE
		    else
			print "\nERROR: erronuous CLOSE argument at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    fi
		fi;;
	    "REWIND")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty REWIND at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    print -r "rewind(${1#* });" >> $g_CFILE
		fi;;
	    "MEMREWIND")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty MEMREWIND at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    print -r "${1#* } = (char*)__b2c_mem_${1#* };" >> $g_CFILE
		fi;;
	    "SEEK")
		Handle_Seek "${1#* }";;
	    "READLN")
		Handle_Readln "${1#* }";;
	    "WRITELN")
		Handle_Writeln "${1#* }";;
	    "GETBYTE")
		Handle_Getbyte "${1#* }";;
	    "PUTBYTE")
		Handle_Putbyte "${1#* }";;
	    "GETFILE")
		Handle_Getfile "${1#* }";;
	    "GETLINE")
		Handle_Getline "${1#* }";;
	    "PUTLINE")
		Handle_Putline "${1#* }";;
	    "END")
		if [[ "${1#* }" = +(*IF*) ]]
		then
		    print -r "}" >> $g_CFILE
		elif [[ "${1#* }" = +(*RECORD*) ]]
		then
		    if [[ -n $g_FUNCNAME ]]
		    then
			print -r "};" >> $g_CFILE
			print -r "struct $g_RECORDNAME $g_RECORDVAR = { } ;" >> $g_CFILE
		    else
			print -r "};" >> $g_HFILE
			print -r "struct $g_RECORDNAME $g_RECORDVAR = { } ;" >> $g_HFILE
		    fi
		    g_RECORDNAME=
		    g_RECORDVAR=
		    # Restore function name if GLOBAL was used
		    if [[ -n $g_RECORDCACHE ]]
		    then
			g_FUNCNAME=$g_RECORDCACHE
			g_RECORDCACHE=
		    fi
		elif [[ "${1#* }" = +(*FUNCTION*) ]]
		then
		    Handle_Endfunction
		elif [[ "${1#* }" = +(*SUB*) ]]
		then
		    Handle_Endsub
		elif [[ "${1#* }" = +(*WITH*) ]]
		then
		    g_WITHVAR=
		elif [[ "${1#* }" = +(*SELECT*) ]]
		then
		    if [[ $g_SELECTVAR_CTR -eq 0 ]]
		    then
			print "\nERROR: invalid END SELECT at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    else
			print -r "}" >> $g_CFILE
			g_SELECTVAR[$g_SELECTVAR_CTR]=
			g_IN_CASE[$g_SELECTVAR_CTR]=
			g_CASE_FALL=
			((g_SELECTVAR_CTR-=1))
		    fi
		elif [[ "${1#* }" != "END" ]]
		then
		    print -r "exit(${1#* });" >> $g_CFILE
		else
		    print -r "exit(EXIT_SUCCESS);" >> $g_CFILE
		fi;;
	    "SUB")
		Handle_SubFunc "${1#* }";;
	    "ENDSUB")
		Handle_Endsub;;
	    "ENDWITH")
		g_WITHVAR=;;
	    "ENDSELECT")
		if [[ $g_SELECTVAR_CTR -eq 0 ]]
		then
		    print "\nERROR: invalid END SELECT at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    print -r "}" >> $g_CFILE
		    g_SELECTVAR[$g_SELECTVAR_CTR]=
		    g_IN_CASE[$g_SELECTVAR_CTR]=
		    g_CASE_FALL=
		    ((g_SELECTVAR_CTR-=1))
		fi;;
	    "CALL")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty CALL at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    SYM=`print -r "${1#* }"`
		    if [[ "$SYM" = +(* TO *) ]]
		    then
			if [[ "${SYM##*TO }" = +(*${g_STRINGSIGN}) ]]
			then
			    print -r "${SYM##*TO } = realloc(${SYM##*TO }, (strlen(${SYM%% TO*})+1)*sizeof(char));" >> $g_CFILE
			    print -r -n "strcpy(${SYM##*TO }," >> $g_CFILE
			else
			    print -r -n "${SYM##*TO } = " >> $g_CFILE
			fi
			if [[ "${SYM%% TO*}" = +(*\(*\)*) ]]
			then
			    print -r -n "${SYM%% TO*}" >> $g_CFILE
			else
			    print -r -n "${SYM%% TO*}()" >> $g_CFILE
			fi
			if [[ "${SYM##*TO }" = +(*${g_STRINGSIGN}) ]]
			then
			    print -r ");" >> $g_CFILE
			else
			    print -r ";" >> $g_CFILE
			fi
		    else
			if [[ "$SYM" = +(*\(*\)*) ]]
			then
			    print -r "$SYM;" >> $g_CFILE
			else
			    print -r "$SYM();" >> $g_CFILE
			fi
		    fi
		fi;;
	    "FUNCTION")
		Handle_SubFunc "${1#* }";;
	    "ENDFUNCTION")
		Handle_Endfunction;;
	    "RETURN")
		Handle_Return "${1#* }";;
	    "IMPORT")
		Handle_Import "${1#* }";;
	    "DECLARE")
		Handle_Declare "${1#* }";;
	    "GLOBAL")
		Handle_Declare "${1#* }";;
	    "LOCAL")
		Handle_Local "${1#* }";;
	    "DATA")
		Handle_Data "${1#* }";;
	    "RESTORE")
		print -r "if(__b2c__floatarray_ptr > 0) __b2c__floatarray_ptr = 0;" >> $g_CFILE
		print -r "if(__b2c__stringarray_ptr > 0) __b2c__stringarray_ptr = 0;" >> $g_CFILE;;
	    "READ")
		Handle_Read "${1#* }";;
	    "PUSH")
		Handle_Push "${1#* }";;
	    "PULL")
		Handle_Pull "${1#* }";;
	    "SEED")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty SEED at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    print -r "srand((unsigned int)${1#* });" >> $g_CFILE
		fi;;
	    "DEF")
		Handle_Deffn "${1#* }";;
	    "CONST")
		Handle_Const "${1#* }";;
	    "INCLUDE")
		# Get rid of doublequotes if they are there
		INC=`print ${1#* } | tr -d "\042"`
		# Check argument
		if [[ ! -f ${INC%%,*} || "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: missing file '${INC%%,*}' for INCLUDE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Clear current terminal line
		    print -n "\033[2K"
		    TO_PARSE=0
		    # See if there are arguments
		    if [[ ${INC} = +(*,*) ]]
		    then
			EXP=`print ${INC#*,} | tr "," " "`
			INC=${INC%%,*}
		    else
			TO_PARSE=2
		    fi
		    # Start walking through program
		    COPY_COUNTER=$g_COUNTER
		    g_COUNTER=1
		    # Assign new file
		    COPY_CURFILE=$g_CURFILE
		    # Get rid of absolute path
		    g_CURFILE=${INC##*/}
		    while read -r LINE
		    do
			print -n "\rConverting '${INC}'... $g_COUNTER"
			# See if we need to enable flag
			for SYM in ${EXP}
			do
			    if [[ $TO_PARSE -eq 0 && "${LINE#* }" = +(${SYM%${g_STRINGSIGN}*}*) && "${LINE}" = +(*SUB*|*FUNCTION*) || "${LINE}" = +(*INCLUDE) ]]
			    then
				TO_PARSE=1
				break
			    fi
			done
			# Line is not empty?
			if [[ -n "$LINE" && $TO_PARSE -gt 0 ]]
			then
			    if [[ "$LINE" = +(* \\) && "$LINE" != +(REM*) && "$LINE" != +(${g_SQUOTESIGN}*) ]]
			    then
				let LEN="${#LINE}"-2
				typeset -L$LEN SEQ="${LINE}"
				TOTAL=$TOTAL$SEQ
			    else
				print -r "/* noparse $INC BACON LINE $g_COUNTER */" >> $g_HFILE
				print -r "/* noparse $INC BACON LINE $g_COUNTER */" >> $g_CFILE
				TOTAL="${TOTAL}${LINE}"
				if [[ "${TOTAL}" != +(REM*) && "${TOTAL}" != +(${g_SQUOTESIGN}*) ]]
				then
				    Tokenize "${TOTAL}"
				fi
				TOTAL=
			    fi
			fi
			# See if we need to stop parsing
			if [[ $TO_PARSE -eq 1 && "${LINE}" = +(*END*) && "${LINE}" = +(*SUB*|*FUNCTION*) ]]
			then
			    TO_PARSE=0
			fi
			# Increase line number
			((g_COUNTER+=1))
		    done < $INC
		    # Restore original counter
		    g_COUNTER=$COPY_COUNTER
		    # Restore original file
		    g_CURFILE=$COPY_CURFILE
		fi;;
	    "POKE")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty POKE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    SYM=${1#* }
		    print -r "if (!__b2c__trap){if(__b2c__memory__check((char*)${SYM%%,*})) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} }" >> $g_CFILE
		    print -r "*(${g_OPTION_MEMTYPE}*)(${SYM%%,*}) = (${g_OPTION_MEMTYPE})${SYM#*,};" >> $g_CFILE
		fi;;
	    "RESIZE")
	    	# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty RESIZE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Resolve this with C macro because of casting to (char)
		    SYM=${1#* }
		    print -r "${SYM%%,*}=(long)RESIZE(${SYM});" >> $g_CFILE
		fi;;
	    "COPY")
		Handle_Copy "${1#* }";;
	    "DELETE")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty DELETE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Translate to C function
		    if [[ "${1#* }" = +(*FILE*) ]]
		    then
			print -r "if (unlink(${1#*FILE })==-1){if(!__b2c__trap){ERROR = 7;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
		    elif [[ "${1#* }" = +(*DIRECTORY*) ]]
		    then
			 print -r "if (rmdir(${1#*DIRECTORY }) == -1){if(!__b2c__trap){ERROR = 20;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
		    else
			print "\nERROR: erronuous argument for DELETE at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    fi
		fi;;
	    "RENAME")
		Handle_Rename "${1#* }";;
	    "MAKEDIR")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty MAKEDIR at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Translate to C function
		    print -r "if (__b2c__makedir(${1#* }) != 0){if(!__b2c__trap){ERROR = 21;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
		fi;;
	    "CHANGEDIR")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty CHANGEDIR at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Translate to C function
		    print -r "if (chdir(${1#* }) == -1){if(!__b2c__trap) {ERROR = 22;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
		fi;;
	    "FREE")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty FREE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Translate to C function
		    if [[ ${1#* } = +(*\(*\)*) ]]
		    then
			EXP=${1#* }
			if [[ $EXP = +(*${g_STRINGSIGN}*) ]]
			then
			    print -r "if(__b2c__${EXP%%\(*}_exist(${1#*\(} != NULL) { free(__b2c__${EXP%%\(*}_exist(${1#*\(}->value); __b2c__${EXP%%\(*}_exist(${1#*\(}->value = NULL; __b2c__${EXP%%\(*}__del(${1#*\(};}" >> $g_CFILE
			else
			    print -r "if(__b2c__${EXP%%\(*}_exist(${1#*\(} != NULL) {__b2c__${EXP%%\(*}_exist(${1#*\(}->value = 0; __b2c__${EXP%%\(*}__del(${1#*\(};}" >> $g_CFILE
			fi
		    else
			print -r "if(!__b2c__trap){if(__b2c__memory__check((char *)${1#* }))" >> $g_CFILE
			print -r "{ERROR=1; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} } free((void*)${1#* });" >> $g_CFILE
		    fi
		fi;;
	    "GOTO")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty GOTO at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Translate to C label
		    print -r "goto ${1#* };" >> $g_CFILE
		fi;;
	    "GOSUB")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty GOSUB at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Translate to C label
		    print -r "__b2c__gosub_buffer_ptr++; if (__b2c__gosub_buffer_ptr >= $g_MAX_RBUFFERS) {ERROR=31; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;}" >> $g_CFILE
		    print -r "if(!setjmp(__b2c__gosub_buffer[__b2c__gosub_buffer_ptr])) goto ${1#* };" >> $g_CFILE
		    print -r "__b2c__gosub_buffer_ptr--; if(__b2c__gosub_buffer_ptr < -1) __b2c__gosub_buffer_ptr = -1;" >> $g_CFILE
		fi;;
	    "LABEL")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty LABEL at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Translate to C label
		    print -r "${1#* }:" >> $g_CFILE
		    print -r ";" >> $g_CFILE
		fi;;
	    "TRAP")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty TRAP at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    if [[ "${1#* }" = "SYSTEM" ]]
		    then
			print -r "/* Error trapping by OS */" >> $g_CFILE
			print -r "__b2c__trap = 1;" >> $g_CFILE
			print -r "signal(SIGILL, __b2c__catch_signal);" >> $g_CFILE
			print -r "signal(SIGABRT, __b2c__catch_signal);" >> $g_CFILE
			print -r "signal(SIGFPE, __b2c__catch_signal);" >> $g_CFILE
			print -r "signal(SIGSEGV, __b2c__catch_signal);" >> $g_CFILE
		    elif [[ "${1#* }" = "LOCAL" ]]
		    then
			print -r "/* Error trapping by BaCon */" >> $g_CFILE
			print -r "__b2c__trap = 0;" >> $g_CFILE
			print -r "signal(SIGILL, SIG_DFL);" >> $g_CFILE
			print -r "signal(SIGABRT, SIG_DFL);" >> $g_CFILE
			print -r "signal(SIGFPE, SIG_DFL);" >> $g_CFILE
			print -r "signal(SIGSEGV, SIG_DFL);" >> $g_CFILE
		    else
			print "\nERROR: invalid argument for TRAP at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    fi
		fi;;
	    "CATCH")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty CATCH at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		elif [[ "${1#* }" = +(*GOTO*) ]]
		then
		    print -r "__b2c__catch_set = 1;" >> $g_CFILE
		    g_CATCHGOTO="${1##* GOTO }"
		elif [[ "${1#* }" = +(*RESET*) ]]
		then
		    print -r "__b2c__catch_set = 0;" >> $g_CFILE
		    g_CATCHGOTO="__B2C__PROGRAM__EXIT"
		else
		    print "\nERROR: CATCH without GOTO or RESET at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		fi;;
	    "RESUME")
		print -r "longjmp(__b2c__jump, 1);" >> $g_CFILE;;
	    "CLEAR")
		print -r "fprintf(stdout,\"\033[2J\"); fprintf(stdout,\"\033[0;0f\");fflush(stdout);" >> $g_CFILE;;
	    "COLOR")
		Handle_Color "${1#* }";;
	    "GOTOXY")
		Handle_Gotoxy "${1#* }";;
	    "RECEIVE")
		Handle_Receive "${1#* }";;
	    "SEND")
		Handle_Send "${1#* }";;
	    "RECORD")
	    	# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty RECORD at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		elif [[ -n $g_RECORDNAME ]]
		then
		    print "\nERROR: cannot define a record within a record!"
		    exit 1
		else
		    # Translate to C typedef struct
		    if [[ -n $g_FUNCNAME ]]
		    then
			g_RECORDNAME="RECORD_${g_FUNCNAME}_${g_COUNTER}"
			print -r "struct $g_RECORDNAME{" >> $g_CFILE
		    else
			g_RECORDNAME="RECORD_${g_COUNTER}"
			print -r "struct $g_RECORDNAME{" >> $g_HFILE
		    fi
		    g_RECORDVAR=${1#* }
		fi;;
	    "WITH")
	    	# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty WITH at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		elif [[ -n $g_RECORDNAME ]]
		then
		    print "\nERROR: cannot define a WITH within a WITH!"
		    exit 1
		else
		    g_WITHVAR=${1#* }
		fi;;
	    "SPLIT")
		Handle_Split "${1#* }";;
	    "SELECT")
	    	# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty SELECT at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    ((g_SELECTVAR_CTR+=1))
		    g_SELECTVAR[$g_SELECTVAR_CTR]=${1#* }
		    g_IN_CASE[$g_SELECTVAR_CTR]=
		    g_CASE_FALL=
		fi;;
	    "CASE")
	    	# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty CASE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    if [[ -n ${g_IN_CASE[$g_SELECTVAR_CTR]} ]]
		    then
			if [[ ${g_SELECTVAR[$g_SELECTVAR_CTR]%%\(*} = +(*${g_STRINGSIGN}*) ]]
			then
			    # Get expression without ;
			    if [[ -z ${1##*;} ]]
			    then
				let LEN="${#1}"-1; typeset -L$LEN EXP="${1}"
				g_CASE_FALL="|| !strcmp(${g_SELECTVAR[$g_SELECTVAR_CTR]}, ${EXP#* }) ${g_CASE_FALL}"
			    else
				print -r "} else if (!strcmp(${g_SELECTVAR[$g_SELECTVAR_CTR]}, ${1#* }) ${g_CASE_FALL}){" >> $g_CFILE
				g_CASE_FALL=
			    fi
			else
			    # Get expression without ;
			    if [[ -z ${1##*;} ]]
			    then
				let LEN="${#1}"-1; typeset -L$LEN EXP="${1}"
				g_CASE_FALL="|| ${g_SELECTVAR[$g_SELECTVAR_CTR]} == (${EXP#* }) ${g_CASE_FALL}"
			    else
				print -r "} else if (${g_SELECTVAR[$g_SELECTVAR_CTR]} == (${1#* }) ${g_CASE_FALL}){" >> $g_CFILE
				g_CASE_FALL=
			    fi
			fi
		    else
			if [[ ${g_SELECTVAR[$g_SELECTVAR_CTR]%%\(*} = +(*${g_STRINGSIGN}*) ]]
			then
			    # Get expression without ;
			    if [[ -z ${1##*;} ]]
			    then
				let LEN="${#1}"-1; typeset -L$LEN EXP="${1}"
				g_CASE_FALL="|| !strcmp(${g_SELECTVAR[$g_SELECTVAR_CTR]}, ${EXP#* }) ${g_CASE_FALL}"
			    else
				print -r "if (!strcmp(${g_SELECTVAR[$g_SELECTVAR_CTR]}, ${1#* }) ${g_CASE_FALL}){" >> $g_CFILE
				g_IN_CASE[$g_SELECTVAR_CTR]=1
				g_CASE_FALL=
			    fi
			else
			    # Get expression without ;
			    if [[ -z ${1##*;} ]]
			    then
				let LEN="${#1}"-1; typeset -L$LEN EXP="${1}"
				g_CASE_FALL="|| ${g_SELECTVAR[$g_SELECTVAR_CTR]} == (${EXP#* }) ${g_CASE_FALL}"
			    else
				print -r "if (${g_SELECTVAR[$g_SELECTVAR_CTR]} == (${1#* }) ${g_CASE_FALL}){" >> $g_CFILE
				g_IN_CASE[$g_SELECTVAR_CTR]=1
				g_CASE_FALL=
			    fi
			fi
		    fi
		fi;;
	    "DEFAULT")
		if [[ -n ${g_IN_CASE[$g_SELECTVAR_CTR]} ]]
		then
		    print -r "} else {" >> $g_CFILE
		else
		    print "\nERROR: cannot use DEFAULT without previous CASE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		fi
		g_IN_CASE[$g_SELECTVAR_CTR]=
		g_CASE_FALL=;;
	    "SETENVIRON")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty SETENVIRON at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    # Resolve this with C macro
		    print -r "SETENVIRON(${1#* });" >> $g_CFILE
		fi;;
	    "SORT")
		Handle_Sort "${1#* }";;
	    "STOP")
		print -r "kill(getpid(), SIGSTOP);" >> $g_CFILE
		;;
	    "TRACE")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty TRACE at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    if [[ "${1#* }" = +(*ON*) ]]
		    then
			g_TRACE=1
		    elif [[ "${1#* }" = +(*OFF*) ]]
		    then
			g_TRACE=0
		    fi
		fi;;
	    "OPTION")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty OPTION at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    if [[ "${1#* }" = +(*BASE*) ]]
		    then
			if [[ "${1##*BASE }" = +([0123456789]) ]]
			then
			    g_OPTION_BASE=${1##*BASE }
			else
			    print "\nERROR: invalid argument to OPTION BASE at line $g_COUNTER in file '$g_CURFILE'!"
			    exit 1
			fi
		    elif [[ "${1#* }" = +(*COMPARE*) ]]
		    then
                    	if [[ "${1##*COMPARE }" = +([01]|TRUE|FALSE) ]]
			then
			    print -r "__b2c__option_compare = ${1##*COMPARE };" >> $g_CFILE
			else
			    print "\nERROR: invalid argument to OPTION COMPARE at line $g_COUNTER in file '$g_CURFILE'!"
			    exit 1
			fi
		    elif [[ "${1#* }" = +(*SOCKET*) ]]
		    then
			if [[ "${1##*SOCKET }" = +([0123456789]) ]]
			then
			    g_OPTION_SOCKET=${1##*SOCKET }
			else
			    print "\nERROR: invalid argument to OPTION SOCKET at line $g_COUNTER in file '$g_CURFILE'!"
			    exit 1
			fi
                    elif [[ "${1#* }" = +(*MEMSTREAM*) ]]
		    then
			if [[ "${1##*MEMSTREAM }" = +([01]|TRUE|FALSE) ]]
			then
			    print -r "__b2c__option_memstream = ${1##*MEMSTREAM };" >> $g_CFILE
			else
			    print "\nERROR: invalid argument to OPTION MEMSTREAM at line $g_COUNTER in file '$g_CURFILE'!"
			    exit 1
			fi
                    elif [[ "${1#* }" = +(*MEMTYPE*) ]]
		    then
                        case "${1##*MEMTYPE }" in
                            *short*)
                                print -r "__b2c__memtype = 2;" >> $g_CFILE
				g_OPTION_MEMTYPE="short"
				;;
                            *int*)
                                print -r "__b2c__memtype = 3;" >> $g_CFILE
				g_OPTION_MEMTYPE="int"
				;;
                            *long*|*NUMBER*)
                                print -r "__b2c__memtype = 4;" >> $g_CFILE
				g_OPTION_MEMTYPE="long"
				;;
                            *float*)
                                print -r "__b2c__memtype = 5;" >> $g_CFILE
				g_OPTION_MEMTYPE="float"
				;;
                            *double*|*FLOATING*)
                                print -r "__b2c__memtype = 6;" >> $g_CFILE
				g_OPTION_MEMTYPE="double"
				;;
                            *void*|*char\**|*STRING*)
                                print -r "__b2c__memtype = 7;" >> $g_CFILE
				g_OPTION_MEMTYPE="char*"
				;;
                            *char*)
                                print -r "__b2c__memtype = 1;" >> $g_CFILE
				g_OPTION_MEMTYPE="char"
				;;
			    *)
				print "\nERROR: invalid argument to OPTION MEMTYPE at line $g_COUNTER in file '$g_CURFILE'!"
				exit 1
				;;
                        esac
                    elif [[ "${1#* }" = +(*COLLAPSE*) ]]
		    then
			if [[ "${1##*COLLAPSE }" = +([01]|TRUE|FALSE) ]]
			then
			    print -r "__b2c__collapse = ${1##*COLLAPSE };" >> $g_CFILE
			else
			    print "\nERROR: invalid argument to OPTION COLLAPSE at line $g_COUNTER in file '$g_CURFILE'!"
			    exit 1
			fi
                    elif [[ "${1#* }" = +(*INTERNATIONAL*) ]]
		    then
			if [[ "${1##*INTERNATIONAL }" = +([01]|TRUE|FALSE) ]]
			then
			    print -r "#include <libintl.h>" >> $g_HFILE
			    print -r "#include <locale.h>" >> $g_HFILE
			    print -r "setlocale(LC_ALL, \"\");" >> $g_CFILE
			    print -r "if(bindtextdomain(\"${g_SOURCEFILE%.*}\",\"/usr/share/locale\")==NULL){if(!__b2c__trap){ERROR = 6;if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
			    print -r "if(textdomain(\"${g_SOURCEFILE%.*}\")==NULL){if(!__b2c__trap){ERROR = 6; if(!__b2c__catch_set){fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} if(!setjmp(__b2c__jump)) goto $g_CATCHGOTO;} }" >> $g_CFILE
			else
			    print "\nERROR: invalid argument to OPTION INTERNATIONAL at line $g_COUNTER in file '$g_CURFILE'!"
			    exit 1
			fi
                    elif [[ "${1#* }" = +(*NETWORK*) ]]
		    then
                        case "${1##*NETWORK }" in
                            *TCP*)
                                g_NETWORKTYPE="TCP"
                                g_SOCKTYPE="SOCK_STREAM"
                                ;;
                            *UDP*)
                                g_NETWORKTYPE="UDP"
                                g_SOCKTYPE="SOCK_DGRAM"
                                ;;
                            *BROADCAST*)
                                g_NETWORKTYPE="BROADCAST"
                                g_SOCKTYPE="SOCK_DGRAM"
                                ;;
                            *MULTICAST*)
                                g_NETWORKTYPE="MULTICAST"
                                g_SOCKTYPE="SOCK_DGRAM"
				if [[ "${1##*MULTICAST }" = +([0123456789]) ]]
				then
				    g_MULTICAST_TTL="${1##*MULTICAST }"
				fi
                                ;;
                            *)
			        print "\nERROR: invalid argument to OPTION SOCKET at line $g_COUNTER in file '$g_CURFILE'!"
			        exit 1
                                ;;
			esac
		    else
			print "\nERROR: argument to OPTION at line $g_COUNTER in file '$g_CURFILE' not recognized!"
			exit 1
		    fi
		fi;;
	    "PROTO")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty PROTO at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    SYM=`print ${1#* } | tr -d "\042"`
		    # Check if ALIAS is there
		    if [[ $SYM = +(* ALIAS *) ]]
		    then
			print -r "#define ${SYM##* ALIAS } ${SYM%% ALIAS *}" >> $g_HFILE
			g_IMPORTED="${SYM##* ALIAS } $g_IMPORTED"
			g_IMPORTED="${SYM%% ALIAS *} $g_IMPORTED"
		    else
			g_IMPORTED="`print -r ${SYM} | tr ',' ' '` $g_IMPORTED"
		    fi
		fi;;
	    "INCR")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty INC at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    EXP=${1#* }
		    if [[ ${EXP} = +(*,*) ]]
		    then
			SYM="(${EXP#*,})"
			EXP=${EXP%%,*}
		    else
			SYM="1" >> $g_CFILE
		    fi
		    # Check if there is associative array assignment
		    if [[ "${EXP}" = +(*\(*\)) ]]
		    then
			INC=${EXP#*\(}
			print -r "if(__b2c__${EXP%%\(*}_exist(${INC} == NULL) __b2c__${EXP%%\(*}__add(${INC};" >> $g_CFILE
			print -r "__b2c__${EXP%%\(*}_exist(${INC}->value = ${EXP} + ${SYM};" >> $g_CFILE
			# Check for relations
			Relate_Recurse "${EXP%%\(*}" "${INC}" "${SYM}" "-1"
		    else
			print -r "${EXP} = ${EXP} + ${SYM};" >> $g_CFILE
		    fi
		fi;;
	    "DECR")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty DEC at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    EXP=${1#* }
		    if [[ ${EXP} = +(*,*) ]]
		    then
			SYM="(${EXP#*,})"
			EXP=${EXP%%,*}
		    else
			SYM="1" >> $g_CFILE
		    fi
		    # Check if there is associative array assignment
		    if [[ "${EXP}" = +(*\(*\)) ]]
		    then
			INC=${EXP#*\(}
			print -r "if(__b2c__${EXP%%\(*}_exist(${INC} == NULL) __b2c__${EXP%%\(*}__add(${INC};" >> $g_CFILE
			print -r "__b2c__${EXP%%\(*}_exist(${INC}->value = ${EXP} - ${SYM};" >> $g_CFILE
			# Check for relations
			Relate_Recurse "${EXP%%\(*}" "${INC}" "${SYM}" "-1"
		    else
			print -r "${EXP} = ${EXP} - ${SYM};" >> $g_CFILE
		    fi
		fi;;
	    "ALARM")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty ALARM at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    EXP=${1#* }
		    if [[ ${EXP} = +(*,*) ]]
		    then
			print -r "signal(SIGALRM, (void*)${EXP%,*});" >> $g_CFILE
			print -r "alarm(${EXP#*,});" >> $g_CFILE
		    else
			print "\nERROR: missing argument in ALARM at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    fi
		fi;;
	    "CURSOR")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty CURSOR at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    if [[ "${1#* }" = +(*OFF*) ]]
		    then
			print -r "fprintf(stdout,\"\033[?25l\"); fflush(stdout);" >> $g_CFILE
		    elif [[ "${1#* }" = +(*ON*) ]]
		    then
			print -r "fprintf(stdout,\"\033[?25h\"); fflush(stdout);" >> $g_CFILE
		    fi
		fi;;
	    "ALIAS")
		Handle_Alias "${1#* }";;
	    "LOOKUP")
		Handle_Lookup "${1#* }";;
	    "RELATE")
		Handle_Relate "${1#* }";;
	    "TEXTDOMAIN")
		# Check argument
		if [[ "${1%% *}" = "${1#* }" ]]
		then
		    print "\nERROR: empty TEXTDOMAIN at line $g_COUNTER in file '$g_CURFILE'!"
		    exit 1
		else
		    EXP=${1#* }
		    if [[ ${EXP} = +(*,*) ]]
		    then
			print -r "bindtextdomain(${EXP});" >> $g_CFILE
			print -r "textdomain(${EXP%,*});" >> $g_CFILE
		    else
			print "\nERROR: missing argument in TEXTDOMAIN at line $g_COUNTER in file '$g_CURFILE'!"
			exit 1
		    fi
		fi;;
	    *)
		# Check on imported symbols first
		FOUND=0
		for SYM in $g_IMPORTED
		do
		    if [[ "$SYM" = ${1%%\(*} || "$SYM" = ${1%% *} ]]
		    then
			FOUND=1
			if [[ "$1" != +(*\(*\)*) ]]
			then
			    print -r "$SYM();" >> $g_CFILE
			else
			    print -r "$SYM(${1#*\(};" >> $g_CFILE
			fi
		    fi
		done
		# Not an imported symbol? Check if assignment
		if [[ $FOUND -eq 0 ]]
		then
		    Handle_Let "$1"
		fi;;
	esac
    fi
}

#-----------------------------------------------------------

function Tokenize
{
    typeset CHAR IS_ESCAPED IS_STRING IS_STATEMENT TOKEN DATA LEN

    IS_ESCAPED=0
    IS_STRING=0
    IS_STATEMENT=""
    TOKEN=

    # Initialize miniparser, convert spaces
    DATA=`print -r "${1}" | tr " " "\001"`
    LEN=${#DATA}

    until [[ $LEN -eq 0 ]]
    do
	typeset -L5 CHAR="${DATA}"
	if [[ "${CHAR}" = "INTL$" ]]
        then
	    if [[ $IS_STRING -eq 0 ]]
	    then
                let LEN=${#DATA}-5
		typeset -R$LEN DATA="${DATA}"
		TOKEN="${TOKEN}gettext"
            fi
	elif [[ "${CHAR}" = "NNTL$" ]]
        then
	    if [[ $IS_STRING -eq 0 ]]
	    then
                let LEN=${#DATA}-5
		typeset -R$LEN DATA="${DATA}"
		TOKEN="${TOKEN}ngettext"
            fi
        fi
	typeset -L1 CHAR="${DATA}"
	case $CHAR in
	    ":")
		if [[ $IS_STRING -eq 0 ]]
		then
		    Parse_Line "${TOKEN}"
		    typeset -L0 CHAR=""
		    TOKEN=
		    IS_STATEMENT=""
		fi;;
	    "$")
		if [[ $IS_STRING -eq 0 || ${1} = +(*IMPORT*FROM*TYPE*) ]]
		then
		    TOKEN="${TOKEN}${g_STRINGSIGN}"
		    typeset -L0 CHAR=""
		    IS_ESCAPED=0
		fi;;
	    "\\")
		if [[ $IS_ESCAPED -eq 0 ]]
		then
		    IS_ESCAPED=1
		else
		    IS_ESCAPED=0
		fi;;
	    "\"")
		if [[ $IS_ESCAPED -eq 0 ]]
		then
		    if [[ $IS_STRING -eq 0 ]]
		    then
			IS_STRING=1
		    else
			IS_STRING=0
		    fi
		fi
		IS_ESCAPED=0;;
	    [A-Za-z=])
		if [[ $IS_STRING -eq 0 ]]
		then
		    IS_STATEMENT=" "
		fi
		IS_ESCAPED=0;;
	    *)
		IS_ESCAPED=0;;
	esac
	# Convert back to space
	if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	then
	    TOKEN="${TOKEN}${IS_STATEMENT}"
	else
	    TOKEN="${TOKEN}${CHAR}"
	fi
	let LEN=${#DATA}-1
	typeset -R$LEN DATA="${DATA}"
    done
    Parse_Line "${TOKEN}"
}

#-----------------------------------------------------------

function Parse_Chunk
{
    typeset CHAR IS_ESCAPED IS_STRING TOKEN DATA LEN TERM EQ IS_EQUATION

    IS_ESCAPED=0
    IS_STRING=0
    IS_EQUATION=0
    TOKEN=
    EQ="!"

    # Initialize miniparser, convert spaces
    DATA=`print -r "${1}" | tr " " "\001"`
    LEN=${#DATA}

    until [[ $LEN -eq 0 ]]
    do
	typeset -L1 CHAR="${DATA}"
	case $CHAR in
	    "=")
		if [[ $IS_STRING -eq 0 ]]
		then
                    if [[ "${1%%\(*}" = +(*${g_STRINGSIGN}*) || "${1%%\(*}" = +(*${g_DQUOTESIGN}*) ]]
                    then
                        TERM="${TOKEN}"
                        TOKEN=
                    elif [[ $IS_EQUATION -eq 0 ]]
                    then
		        TOKEN="${TOKEN}=="
                    else
		        TOKEN="${TOKEN}="
                        IS_EQUATION=0
                    fi
		    IS_ESCAPED=0
                else
		    TOKEN="${TOKEN}="
		fi;;
	    "!")
		if [[ $IS_STRING -eq 0 ]]
		then
                    if [[ "${1%%\(*}" = +(*${g_STRINGSIGN}*) || "${1%%\(*}" = +(*${g_DQUOTESIGN}*) ]]
                    then
                        EQ=""
                    elif [[ $IS_EQUATION -eq 0 ]]
                    then
                        TOKEN="${TOKEN}!="
		        IS_ESCAPED=0
                        let LEN=${#DATA}-1
	                typeset -R$LEN DATA="${DATA}"
                    else
                        TOKEN="${TOKEN}!"
                        IS_EQUATION=0
                    fi
                else
                    TOKEN="${TOKEN}!"
		fi;;
            "<")
                IS_EQUATION=1
                TOKEN="${TOKEN}<";;
            ">")
                IS_EQUATION=1
                TOKEN="${TOKEN}>";;
            "#")
                IS_EQUATION=1
                TOKEN="${TOKEN}#";;
	    "\\")
		if [[ $IS_ESCAPED -eq 0 ]]
		then
		    IS_ESCAPED=1
		else
		    IS_ESCAPED=0
		fi
                TOKEN="${TOKEN}\\";;
	    "\"")
		if [[ $IS_ESCAPED -eq 0 ]]
		then
		    if [[ $IS_STRING -eq 0 ]]
		    then
			IS_STRING=1
		    else
			IS_STRING=0
		    fi
		fi
		IS_ESCAPED=0
                TOKEN="${TOKEN}\"";;
	    *)
                # Convert back to space
	        if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	        then
	            TOKEN="${TOKEN} "
                else
	            TOKEN="${TOKEN}${CHAR}"
	        fi
		IS_ESCAPED=0;;
	esac
	let LEN=${#DATA}-1
	typeset -R$LEN DATA="${DATA}"
    done

    if [[ "${1%%\(*}" = +(*${g_STRINGSIGN}*) || "${1%%\(*}" = +(*${g_DQUOTESIGN}*) ]]
    then
        TOKEN="((__b2c__option_compare == 0) ? ${EQ}strcmp(${TERM}, $TOKEN) : ${EQ}strcasecmp(${TERM}, $TOKEN))"
    fi

    g_EQUATION="${g_EQUATION} ${TOKEN} ${2}"
}

#-----------------------------------------------------------

function Parse_Equation
{
    typeset CHAR IS_ESCAPED IS_STRING TOKEN DATA LEN
    typeset AND OR

    g_EQUATION=
    IS_ESCAPED=0
    IS_STRING=0
    TOKEN=

    AND=`print " AND " | tr " " "\001"`
    OR=`print " OR " | tr " " "\001"`

    # Initialize miniparser, convert spaces
    DATA=`print -r "${1}" | tr " " "\001"`
    LEN=${#DATA}

    until [[ $LEN -eq 0 ]]
    do
	typeset -L5 CHAR="${DATA}"
	if [[ "${CHAR}" = "${AND}" ]]
        then
	    if [[ $IS_STRING -eq 0 ]]
	    then
		Parse_Chunk "${TOKEN}" " AND "
                let LEN=${#DATA}-4
	        typeset -R$LEN DATA="${DATA}"
		TOKEN=
		typeset -L0 CHAR=""
            fi
        fi
	typeset -L4 CHAR="${DATA}"
	if [[ "${CHAR}" = "${OR}" ]]
        then
	    if [[ $IS_STRING -eq 0 ]]
	    then
		Parse_Chunk "${TOKEN}" " OR "
                let LEN=${#DATA}-3
	        typeset -R$LEN DATA="${DATA}"
		TOKEN=
		typeset -L0 CHAR=""
            fi
        fi
	typeset -L1 CHAR="${DATA}"
	case $CHAR in
	    "\\")
		if [[ $IS_ESCAPED -eq 0 ]]
		then
		    IS_ESCAPED=1
		else
		    IS_ESCAPED=0
		fi;;
	    "\"")
		if [[ $IS_ESCAPED -eq 0 ]]
		then
		    if [[ $IS_STRING -eq 0 ]]
		    then
			IS_STRING=1
		    else
			IS_STRING=0
		    fi
		fi
		IS_ESCAPED=0;;
	    *)
		IS_ESCAPED=0;;
	esac
	# Convert back to space
	if [[ "${CHAR}" = "${g_PARSEVAR}" ]]
	then
	    TOKEN="${TOKEN} "
        else
	    TOKEN="${TOKEN}${CHAR}"
	fi
	let LEN=${#DATA}-1
	typeset -R$LEN DATA="${DATA}"
    done
    Parse_Chunk "${TOKEN}"
}

#-----------------------------------------------------------
#
# Main program
#
#-----------------------------------------------------------

# Default BACON settings
let g_MAX_DIGITS=32

# Maximum of internal buffers needed for string processing
let g_MAX_BUFFERS=32

# This is the size for static buffers like fgets, read etc.
let g_BUFFER_SIZE=512

# Maximum RETURN buffers
let g_MAX_RBUFFERS=32

let g_NO_COMPILE=0
let g_TMP_PRESERVE=0
let g_USE_C=0
let g_MAX_BACKLOG=4
let g_CPP=0
let g_XGETTEXT=0

g_TEMPDIR=.
g_CCNAME=pcc
g_CCFLAGS="-+ -B -D_POSIX_SOURCE -D_SUSV2_SOURCE -D_BSD_EXTENSION -D_C99_SNPRINTF_EXTENSION -D_RESEARCH_SOURCE -D_PLAN9_SOURCE -D_REGEXP_EXTENSION -D_LIMITS_EXTENSION -D_NET_EXTENSION -I/sys/include/ape -I/$objtype/include/ape"
g_INCFILES=
g_INCLUDE_FILES=
let g_TRACE=0
let g_OPTION_BASE=0
let g_OPTION_SOCKET=5
g_OPTION_MEMTYPE="char"
let g_IF_PARSE=0

# Some global declarations
g_CURFILE=
g_FUNCNAME=
g_FUNCTYPE=
g_PROTOTYPE=
g_TMP_FILES=
g_LOCALSTRINGS=
g_STRINGARRAYS=
g_STRINGARGS=
g_BINEXT=
g_RECORDCACHE=
let g_LOOPCTR=0
g_ERRORTXT=
g_EQUATION=

# Always create a final label
g_CATCHGOTO="__B2C__PROGRAM__EXIT"

# Records
g_RECORDNAME=
g_RECORDVAR=
g_WITHVAR=

# Socket defaults
g_SOCKTYPE="SOCK_STREAM"
g_NETWORKTYPE="TCP"
g_MULTICAST_TTL=1

# Select/Case
set -A g_SELECTVAR
set -A g_IN_CASE
g_SELECTVAR_CTR=0

# Relate
set -A g_RELATE
g_RELATE_CTR=0

# Get arguments
while getopts ":c:d:i:l:o:xnjfpv" OPT
do
    case $OPT in
	c) g_CCNAME=$OPTARG;;
	d) if [[ ! -d $OPTARG ]]
	   then
		mkdir -p $OPTARG
	   fi
	   g_TEMPDIR=$OPTARG;;
	i) if [[ ! -f $OPTARG && ! -f "/sys/include/ape/$OPTARG" ]]
	   then
		print "ERROR: included C header file from -i option not found!"
		exit 1
	   fi
	   if [[ ! -f "/sys/include/ape/$OPTARG" ]]
	   then
		g_INCFILES="$g_INCFILES ${OPTARG}"
	   else
		g_INCFILES="$g_INCFILES <${OPTARG}>"
	   fi;;
	l) g_LDFLAGS="$g_LDFLAGS -l$OPTARG";;
	o) g_CCFLAGS="$g_CCFLAGS $OPTARG";;
	n) g_NO_COMPILE=1;;
	j) g_CPP=1;;
	f) g_CCFLAGS="$g_CCFLAGS -shared -rdynamic"
	   if [[ `uname -a` = +(*x86_64*) ]]
	   then
		g_CCFLAGS="$g_CCFLAGS -fPIC"
	   fi
	   g_BINEXT=".so";; 
	p) g_TMP_PRESERVE=1;;
	x) g_XGETTEXT=1;;
	v) print
	   print "BaCon version $g_VERSION - KSH - (c) Peter van Eerten - GPL v3."
	   print
	   exit 0;; 
	\?|h) print
	    print "USAGE: bacon [options] program[.bac]"
	    print
	    print "OPTIONS:"
	    print
	    print " -c <compiler>\tCompiler to use (default: $g_CCNAME)"
	    print " -l <flags>\tPass libraries to linker"
	    print " -o <options>\tPass compiler options"
	    print " -i <include>\tAdd include file to C code"
	    print " -d <tmpdir>\tTemporary directory (default: $g_TEMPDIR)"
	    print " -x \t\tExtract gettext strings"
	    print " -f \t\tCreate Shared Object"
	    print " -n \t\tDo not compile, only convert"
	    print " -j \t\tInvoke C Preprocessor"
	    print " -p \t\tPreserve temporary files"
	    print " -v \t\tShow version"
	    print " -h \t\tShow help"
	    print
	    exit 0;;
    esac
done

shift $(($OPTIND-1))

# Check if a filename was entered, if so get it
if [[ $# -eq 0 ]]
then
    print "ERROR: no filename? Run with '-h' to see usage."
    exit 1
elif [[ "$1" = +(http://*) ]]
then
    print -n "Fetching file... "

    # Remove http part
    g_SOURCEFILE="${1#*http://}"

    # Get header to see if file exists, and if so, get length
    HEAD=`(print "set crlf on"; print "open ${g_SOURCEFILE%%/*} 80"; sleep 1;
    print "HEAD /${1##*/} HTTP/1.1"; print "Host: ${g_SOURCEFILE%%/*}"; print;
    sleep 1; print "quit";) | telnet 2>/dev/null`

    LEN=`print -r ${HEAD#*Content-Length: }`

    # No file found on server
    if [[ "${LEN%% *}" = "telnet>" || "${HEAD}" != +(*Content-Length*) ]]
    then
        print "ERROR: file not found! Check URL and try again."
        exit 1
    fi

    # Get the actual contents of the file
    typeset -R${LEN%% *} DOWNLOAD=`(print "set crlf on"; print "open ${g_SOURCEFILE%%/*} 80"; sleep 1;
    print "GET /${1##*/} HTTP/1.1"; print "Host: ${g_SOURCEFILE%%/*}"; print;
    sleep 1; print "quit";) | telnet 2>/dev/null`

    # Set the final filename and save
    g_SOURCEFILE="${1##*/}"
    print -r "${DOWNLOAD}" > $g_SOURCEFILE
    
    # Check resulting filesize with HTTP header
    FILELEN=`wc -c $g_SOURCEFILE`
    let FILELEN=${FILELEN%% *}-1
    if [[ ${FILELEN} -ne ${LEN%% *} ]]
    then
        print "ERROR: file could not be downloaded. Try again later."
        exit 1
    fi
    print "done."

elif [[ "$@" != +(*.bac) ]]
then
    g_SOURCEFILE="$@.bac"
else
    g_SOURCEFILE="$@"
fi

# Check if file exists
if [[ ! -f $g_SOURCEFILE ]]
then
    print "ERROR: file not found!"
    exit 1
fi

# Change the working directory
if [[ -d ${g_SOURCEFILE%/*} ]]
then
    cd ${g_SOURCEFILE%/*}
fi

# Now create the global filenames where to write to
g_CFILE=$g_TEMPDIR/${g_SOURCEFILE##*/}.c
g_HFILE=$g_TEMPDIR/${g_SOURCEFILE##*/}.h
STRINGARRAYFILE=$g_TEMPDIR/${g_SOURCEFILE##*/}.string.h
FLOATARRAYFILE=$g_TEMPDIR/${g_SOURCEFILE##*/}.float.h

# Check to overwrite
if [[ -f $g_CFILE || -f $g_HFILE ]]
then
    rm -f $g_CFILE
    rm -f $g_HFILE
    rm -f $STRINGARRAYFILE
    rm -f $FLOATARRAYFILE
fi

# Add to total file list
g_TMP_FILES="$g_CFILE $g_HFILE $STRINGARRAYFILE $FLOATARRAYFILE"

# Create basic C file
print -r "/* Created with KSH BaCon $g_VERSION - (c) Peter van Eerten - GPL v3 */" > $g_CFILE
print -r "/* Modified KSH BaCon $g_VERSION to run on Plan9/APE sh - Jens Staal */" > $g_CFILE
print -r "#include \"${g_SOURCEFILE##*/}.h\"" >> $g_CFILE
print -r "int main(int argc, const char **argv)" >> $g_CFILE
print -r "{" >> $g_CFILE
print -r "/* Default is: system traps signals */" >> $g_CFILE
print -r "signal(SIGILL, __b2c__catch_signal);" >> $g_CFILE
print -r "signal(SIGABRT, __b2c__catch_signal);" >> $g_CFILE
print -r "signal(SIGFPE, __b2c__catch_signal);" >> $g_CFILE
print -r "signal(SIGSEGV, __b2c__catch_signal);" >> $g_CFILE

# Put arguments into reserved variable ARGUMENT
print -r "/* Setup the reserved variable 'ARGUMENT' */" >> $g_CFILE
print -r "for(__b2c__counter=0; __b2c__counter < argc; __b2c__counter++)" >> $g_CFILE
print -r "{__b2c__arglen += strlen(argv[__b2c__counter]) + 1;} __b2c__arglen++;" >> $g_CFILE
print -r "ARGUMENT${g_STRINGSIGN} = (char*)calloc(__b2c__arglen, sizeof(char));" >> $g_CFILE
print -r "for(__b2c__counter=0; __b2c__counter < argc; __b2c__counter++)" >> $g_CFILE
print -r "{strcat(ARGUMENT${g_STRINGSIGN}, argv[__b2c__counter]); if(__b2c__counter != argc - 1) strcat(ARGUMENT${g_STRINGSIGN}, \" \");}" >> $g_CFILE
print -r "/* By default seed random generator */" >> $g_CFILE
print -r "srand((unsigned int)time(NULL));" >> $g_CFILE
print -r "/* Initialize internal stackpointer */" >> $g_CFILE
print -r "__b2c__typestack = (int*)calloc(1, sizeof(int));" >> $g_CFILE
print -r "__b2c__stringstack = (char**)realloc(__b2c__stringstack, sizeof(char*)); __b2c__stringstack[0] = calloc(1, sizeof(char));" >> $g_CFILE
print -r "/* Rest of the program */" >> $g_CFILE

# Create basic H file, functions are converted using macros
print -r "/* Created with KSH BaCon $g_VERSION - (c) Peter van Eerten - GPL v3 */" > $g_HFILE
print -r "/* Modified KSH BaCon $g_VERSION to run on Plan9/APE sh - Jens Staal */" > $g_HFILE
print >> $g_HFILE
print -r "#include <stdio.h>" >> $g_HFILE
print -r "#include <stdlib.h>" >> $g_HFILE
print -r "#include <stdarg.h>" >> $g_HFILE
print -r "#include <sys/time.h>" >> $g_HFILE
print -r "#include <sys/stat.h>" >> $g_HFILE
print -r "#include <sys/types.h>" >> $g_HFILE
print -r "#include <sys/wait.h>" >> $g_HFILE
print -r "#include <sys/socket.h>" >> $g_HFILE
print -r "#include <sys/utsname.h>" >> $g_HFILE
print -r "#include <dirent.h>" >> $g_HFILE
print -r "#include <setjmp.h>" >> $g_HFILE
print -r "#include <netdb.h>" >> $g_HFILE

#
#bsd.h added to get strdup on Plan9
    print -r "#include <bsd.h>" >> $g_HFILE
#netinet/in.h also exists for APE, before only for BSD.
    print -r "#include <netinet/in.h>" >> $g_HFILE
# S_ISSOCK is missing from APE
	print -r "#define S_ISSOCK(x) 0" >> $g_HFILE
# inet_aton is missing in APE, we have inet_ntoa
	print -r "#define inet_aton(x, y) 0" >> $g_HFILE
# the standard reply at the moment is thus that an IP adress is invalid.

print -r "#include <arpa/inet.h>" >> $g_HFILE
print -r "#include <signal.h>" >> $g_HFILE
print -r "static jmp_buf __b2c__jump;" >> $g_HFILE
print -r "static int __b2c__trap = 1;" >> $g_HFILE
print -r "static int __b2c__catch_set = 0;" >> $g_HFILE
print -r "static int ERROR = 0;" >> $g_HFILE
print -r "static int __b2c__option_compare = 0;" >> $g_HFILE
print -r "static int __b2c__option_memstream = 0;" >> $g_HFILE
print -r "static int __b2c__memtype = 1;" >> $g_HFILE
print -r "static int __b2c__collapse = 0;" >> $g_HFILE
print -r "int __b2c__break_ctr = 0;" >> $g_HFILE
print -r "int __b2c__break_flag = 0;" >> $g_HFILE
print -r "int RETVAL = 0;" >> $g_HFILE
print -r "char __b2c__chop_default[] = \"\r\n\t \";" >> $g_HFILE
print -r "char VERSION${g_STRINGSIGN}[] = \"$g_VERSION\";" >> $g_HFILE
print >> $g_HFILE
# Add user include files
print -r "/* User include files */" >> $g_HFILE
for i in $g_INCFILES
do
    if [[ "$i" = +(*<*) ]]
    then
	print -r "#include $i" >> $g_HFILE
    else
	print -r "#include \"$i\"" >> $g_HFILE
    fi
done
print -r "/* READ/DATA include files */" >> $g_HFILE
print -r "int __b2c__stringarray_ptr = 0;" >> $g_HFILE
print -r "#include \"${g_SOURCEFILE##*/}.string.h\"" >> $g_HFILE
print -r "int __b2c__floatarray_ptr = 0;" >> $g_HFILE
print -r "#include \"${g_SOURCEFILE##*/}.float.h\"" >> $g_HFILE
print -r "int __b2c__ctr;" >> $g_HFILE
print >> $g_HFILE
print -r "/* Math functions */" >> $g_HFILE
print -r "extern double round(double __b2c__x);" >> $g_HFILE
print -r "extern long int lrint(double __b2c__x);" >> $g_HFILE
print -r "#include <math.h>" >> $g_HFILE
print -r "#define SQR(__b2c__x) sqrt((double)__b2c__x)" >> $g_HFILE
print -r "#define POW(__b2c__x, __b2c__y) pow((double)__b2c__x, (double)__b2c__y)" >> $g_HFILE
print -r "#define SIN(__b2c__x) sin(__b2c__x)" >> $g_HFILE
print -r "#define COS(__b2c__x) cos(__b2c__x)" >> $g_HFILE
print -r "#define TAN(__b2c__x) tan(__b2c__x)" >> $g_HFILE
print -r "#define ATN(__b2c__x) atan(__b2c__x)" >> $g_HFILE
print -r "#define LOG(__b2c__x) log(__b2c__x)" >> $g_HFILE
print -r "#define EXP(__b2c__x) exp(__b2c__x)" >> $g_HFILE
print -r "#define SGN(__b2c__x) (__b2c__x == 0 ? 0 : (__b2c__x < 0 ? -1 : 1))" >> $g_HFILE
print -r "#define ROUND(__b2c__x) lrint(__b2c__x)" >> $g_HFILE
print -r "#define INT(__b2c__x) lrint(__b2c__x)" >> $g_HFILE
print -r "#define MOD(__b2c__x, __b2c__y) ((long)(__b2c__x) % (long)(__b2c__y))" >> $g_HFILE
print -r "#define EVEN(__b2c__x) (((long)(__b2c__x) % 2 == 0) ? 1 : 0)" >> $g_HFILE
print -r "#define ODD(__b2c__x) (((long)(__b2c__x) % 2 != 0) ? 1 : 0)" >> $g_HFILE
print -r "#define FLOOR(__b2c__x) (long)floor(__b2c__x)" >> $g_HFILE
print -r "#define ABS(__b2c__x) (long)abs(__b2c__x)" >> $g_HFILE
print -r "#define RND random()" >> $g_HFILE
print -r "#define MAXRANDOM RAND_MAX" >> $g_HFILE
print -r "#define RANDOM(__b2c__x) ((__b2c__x != 0) ? random()/(MAXRANDOM/__b2c__x) : 0)" >> $g_HFILE
print >> $g_HFILE
print -r "/* Other functions */" >> $g_HFILE
print -r "#define VAL(__b2c__x) ((__b2c__x != NULL) ? atof(__b2c__x) : 0)" >> $g_HFILE
print >> $g_HFILE
print -r "/* Unix functions */" >> $g_HFILE
print -r "#include <unistd.h>" >> $g_HFILE
print -r "#define SYSTEM(__b2c__x) do {if (__b2c__x != NULL) {RETVAL = system(__b2c__x); if(WIFEXITED(RETVAL)) RETVAL = WEXITSTATUS(RETVAL);} else RETVAL=0;} while(0)" >> $g_HFILE
print >> $g_HFILE
print -r "/* String functions */" >> $g_HFILE
print -r "#include <string.h>" >> $g_HFILE
print -r "char *__b2c__strndup(const char *__b2c__s, size_t __b2c__n){size_t __b2c__avail;" >> $g_HFILE
print -r "char *__b2c__p; if (!__b2c__s) return 0; __b2c__avail = strlen(__b2c__s) + 1;" >> $g_HFILE
print -r "if (__b2c__avail > __b2c__n + 1) __b2c__avail = __b2c__n + 1; __b2c__p = malloc(__b2c__avail);" >> $g_HFILE
print -r "memcpy(__b2c__p, __b2c__s, __b2c__avail); __b2c__p[__b2c__avail - 1] = '\0'; return __b2c__p;}" >> $g_HFILE
print -r "char __b2c__input__buffer[$g_BUFFER_SIZE];" >> $g_HFILE
print -r "char* __b2c__sbuffer[$g_MAX_BUFFERS] = { NULL };" >> $g_HFILE
print -r "int __b2c__sbuffer_ptr = 0;" >> $g_HFILE
print -r "char* __b2c__rbuffer[$g_MAX_RBUFFERS] = { NULL };" >> $g_HFILE
print -r "int __b2c__rbuffer_ptr = 0;" >> $g_HFILE
print -r "static jmp_buf __b2c__gosub_buffer[$g_MAX_RBUFFERS] = { 0 };" >> $g_HFILE
print -r "int __b2c__gosub_buffer_ptr = -1;" >> $g_HFILE
print -r "/* Temporary pointer to perform assignments */" >> $g_HFILE
print -r "char *__b2c__assign = NULL;" >> $g_HFILE
print -r "char *__b2c__split = NULL; char *__b2c__split_tmp = NULL; char *__b2c__split_ptr = NULL;" >> $g_HFILE
print -r "char *ERR${g_STRINGSIGN}(int);" >> $g_HFILE
print -r "/* Functions for sort */" >> $g_HFILE
print -r "int __b2c__sortnrd(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(double*)__b2c__a==*(double*)__b2c__b) return 0; else if (*(double*)__b2c__a < *(double*)__b2c__b) return -1; else return 1;}" >> $g_HFILE
print -r "int __b2c__sortnrd_down(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(double*)__b2c__a==*(double*)__b2c__b) return 0; else if (*(double*)__b2c__a < *(double*)__b2c__b) return 1; else return -1;}" >> $g_HFILE
print -r "int __b2c__sortnrf(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(float*)__b2c__a==*(float*)__b2c__b) return 0; else if (*(float*)__b2c__a < *(float*)__b2c__b) return -1; else return 1;}" >> $g_HFILE
print -r "int __b2c__sortnrf_down(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(float*)__b2c__a==*(float*)__b2c__b) return 0; else if (*(float*)__b2c__a < *(float*)__b2c__b) return 1; else return -1;}" >> $g_HFILE
print -r "int __b2c__sortnrl(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(long*)__b2c__a==*(long*)__b2c__b) return 0; else if (*(long*)__b2c__a < *(long*)__b2c__b) return -1; else return 1;}" >> $g_HFILE
print -r "int __b2c__sortnrl_down(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(long*)__b2c__a==*(long*)__b2c__b) return 0; else if (*(long*)__b2c__a < *(long*)__b2c__b) return 1; else return -1;}" >> $g_HFILE
print -r "int __b2c__sortnri(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(int*)__b2c__a==*(int*)__b2c__b) return 0; else if (*(int*)__b2c__a < *(int*)__b2c__b) return -1; else return 1;}" >> $g_HFILE
print -r "int __b2c__sortnri_down(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{if (*(int*)__b2c__a==*(int*)__b2c__b) return 0; else if (*(int*)__b2c__a < *(int*)__b2c__b) return 1; else return -1;}" >> $g_HFILE
print -r "int __b2c__sortstr(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{return strcmp(*(char **) __b2c__a, *(char **) __b2c__b);}" >> $g_HFILE
print -r "int __b2c__sortstr_down(const void *__b2c__a, const void *__b2c__b)" >> $g_HFILE
print -r "{return strcmp(*(char **) __b2c__b, *(char **) __b2c__a);}" >> $g_HFILE
print -r "/* Actual functions */" >> $g_HFILE
print -r "char* __b2c__curdir(void){__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_BUFFER_SIZE*sizeof(char));" >> $g_HFILE
print -r "return (getcwd(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_BUFFER_SIZE));}" >> $g_HFILE
print -r "#define CURDIR${g_STRINGSIGN} __b2c__curdir()" >> $g_HFILE
print -r "char* __b2c__reverse(char *__b2c__s){int __b2c__i; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__s)+2)*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, strlen(__b2c__s)+1);" >> $g_HFILE
print -r "for(__b2c__i=0;__b2c__i<strlen(__b2c__s);__b2c__i++){__b2c__sbuffer[__b2c__sbuffer_ptr][__b2c__i]=__b2c__s[strlen(__b2c__s)-1-__b2c__i];}" >> $g_HFILE
print -r "return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define REVERSE${g_STRINGSIGN}(x) ((x != NULL) ? __b2c__reverse(x) : \"null\")" >> $g_HFILE
print -r "char* __b2c__str(double d){__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, $g_MAX_DIGITS);" >> $g_HFILE
print -r "if(floor(d) == d) snprintf(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%ld\", (long)d); else snprintf(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%.10g\", d);" >> $g_HFILE
print -r "return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define STR${g_STRINGSIGN}(x) __b2c__str(x)" >> $g_HFILE
print -r "char* __b2c__concat(char *__b2c__first, ...){char *__b2c__tmp; va_list __b2c__ap; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "if(__b2c__first != NULL) { __b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__first)+1)*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, (strlen(__b2c__first)+1)*sizeof(char)); strcpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__first);}" >> $g_HFILE
print -r "else {__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], 2*sizeof(char)); strcpy(__b2c__sbuffer[__b2c__sbuffer_ptr], \"\");} va_start(__b2c__ap, __b2c__first);" >> $g_HFILE
print -r "while((__b2c__tmp = va_arg(__b2c__ap, char *)) != NULL) {__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__tmp)+strlen(__b2c__sbuffer[__b2c__sbuffer_ptr])+1)*sizeof(char));" >> $g_HFILE
print -r "strcat(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__tmp);} va_end(__b2c__ap); return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define CONCAT${g_STRINGSIGN}(...) __b2c__concat(__VA_ARGS__, (char*)NULL)" >> $g_HFILE
print -r "char* __b2c__left(char *__b2c__src, long __b2c__n){if(__b2c__src == NULL || __b2c__n > strlen(__b2c__src) || __b2c__n < 0) return(__b2c__src);" >> $g_HFILE
print -r "__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__src)+1)*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, (strlen(__b2c__src)+1)*sizeof(char)); strncpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__src, (__b2c__n));" >> $g_HFILE
print -r "return (__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define LEFT${g_STRINGSIGN}(__b2c__x, __b2c__y) __b2c__left(__b2c__x, __b2c__y)" >> $g_HFILE
print -r "char* __b2c__right(char *__b2c__src, long __b2c__n){if(__b2c__src == NULL || __b2c__n > strlen(__b2c__src) || __b2c__n < 0) return(__b2c__src);" >> $g_HFILE
print -r "__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__src)+1)*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, (strlen(__b2c__src)+1)*sizeof(char)); strcpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__src+ strlen(__b2c__src)- __b2c__n);" >> $g_HFILE
print -r "return (__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define RIGHT${g_STRINGSIGN}(__b2c__x, __b2c__y) __b2c__right(__b2c__x, __b2c__y)" >> $g_HFILE
print -r "char* __b2c__mid(char *__b2c__src, ...){ va_list __b2c__ap; long __b2c__start, __b2c__end; if(__b2c__src == NULL || strlen(__b2c__src) == 0) return(\"\");" >> $g_HFILE
print -r "__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__src)+1)*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, (strlen(__b2c__src)+1)*sizeof(char)); va_start(__b2c__ap, __b2c__src);" >> $g_HFILE
print -r "__b2c__start = va_arg(__b2c__ap, long); if(__b2c__start < 1) return(__b2c__src); if(__b2c__start > strlen(__b2c__src)) return(\"\"); __b2c__end = va_arg(__b2c__ap, long); if((__b2c__end) < 0 || (__b2c__end) > strlen (__b2c__src)) __b2c__end = strlen(__b2c__src)-__b2c__start+1;" >> $g_HFILE
print -r "strncpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__src+(long)(__b2c__start)-1, (__b2c__end)); va_end(__b2c__ap); return (__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define MID${g_STRINGSIGN}(__b2c__string, ...) __b2c__mid(__b2c__string, __VA_ARGS__, -1)" >> $g_HFILE
print -r "long __b2c__instr(char *__b2c__first, ...){char *__b2c__tmp; char *__b2c__res; int __b2c__pos; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "va_list __b2c__ap; if(__b2c__first == NULL) return (0); __b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__first)+1)*sizeof(char));" >> $g_HFILE
print -r "strcpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__first); va_start(__b2c__ap, __b2c__first);" >> $g_HFILE
print -r "__b2c__tmp = va_arg(__b2c__ap, char *); if(__b2c__tmp == NULL || strlen(__b2c__tmp) == 0) return (0);__b2c__pos = va_arg(__b2c__ap, int);" >> $g_HFILE
print -r "if(__b2c__pos <= 0) __b2c__pos = 1; va_end(__b2c__ap); __b2c__res = strstr(__b2c__sbuffer[__b2c__sbuffer_ptr] + __b2c__pos - 1, __b2c__tmp);" >> $g_HFILE
print -r "if(__b2c__res == NULL) return (0); return (__b2c__res - __b2c__sbuffer[__b2c__sbuffer_ptr] + 1);}" >> $g_HFILE
print -r "#define INSTR(...) __b2c__instr(__VA_ARGS__, -1)" >> $g_HFILE
print -r "long __b2c__instrrev(char *__b2c__first, ...){char *__b2c__tmp; char *__b2c__res = NULL; int __b2c__pos; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "va_list __b2c__ap; if(__b2c__first == NULL) return (0); __b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__first)+1)*sizeof(char));" >> $g_HFILE
print -r "strcpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__first); va_start(__b2c__ap, __b2c__first);" >> $g_HFILE
print -r "__b2c__tmp = va_arg(__b2c__ap, char *); if(__b2c__tmp == NULL || strlen(__b2c__tmp) == 0) return (0);__b2c__pos = va_arg(__b2c__ap, int);" >> $g_HFILE
print -r "if(__b2c__pos <= 0) __b2c__pos = 1; va_end(__b2c__ap); while(__b2c__res == NULL && __b2c__pos <= strlen(__b2c__sbuffer[__b2c__sbuffer_ptr])) {" >> $g_HFILE
print -r "__b2c__res = strstr(__b2c__sbuffer[__b2c__sbuffer_ptr] + strlen(__b2c__sbuffer[__b2c__sbuffer_ptr]) - __b2c__pos, __b2c__tmp); __b2c__pos+=1;}" >> $g_HFILE
print -r "if(__b2c__res == NULL) return (0); return (__b2c__res - __b2c__sbuffer[__b2c__sbuffer_ptr] + 1);}" >> $g_HFILE
print -r "#define INSTRREV(...) __b2c__instrrev(__VA_ARGS__, -1)" >> $g_HFILE
print -r "char* __b2c__spc(int __b2c__x){__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__x*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, __b2c__x*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 32, __b2c__x); return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define SPC${g_STRINGSIGN}(x) ((x > -1) ? __b2c__spc(x) : \"\")" >> $g_HFILE
print -r "char* __b2c__tab(int __b2c__x){__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__x*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, __b2c__x*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 9, __b2c__x); return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define TAB${g_STRINGSIGN}(x) ((x > -1) ? __b2c__tab(x) : \"\")" >> $g_HFILE
print -r "char* __b2c__fill(unsigned long __b2c__x, unsigned char __b2c__y){__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__x*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, __b2c__x*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__y, __b2c__x); return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define FILL${g_STRINGSIGN}(x, y) ((y > -1 && y < 256) ? __b2c__fill(x, y) : \"\")" >> $g_HFILE
print -r "char* __b2c__chop(char *__b2c__src, ...){char *__b2c__tmp, *__b2c__str; int __b2c__i, __b2c__loc = 0; va_list __b2c__ap; if(strlen(__b2c__src) == 0) return(__b2c__src);" >> $g_HFILE
print -r "va_start (__b2c__ap, __b2c__src); __b2c__str = va_arg (__b2c__ap, char*); if(__b2c__str == 0) __b2c__str = (char*)__b2c__chop_default; else __b2c__loc = va_arg (__b2c__ap, int); va_end (__b2c__ap);" >> $g_HFILE
print -r "if(__b2c__loc == 0 || __b2c__loc == 1) {while (*__b2c__src != '\0') {for(__b2c__i = 0; __b2c__i < strlen(__b2c__str); __b2c__i++) {if (*__b2c__src == *(__b2c__str+__b2c__i)) {__b2c__src++; break; } }" >> $g_HFILE
print -r "if(__b2c__i == strlen(__b2c__str)) break;} if (*__b2c__src == '\0') return(\"\");} __b2c__tmp = __b2c__src + strlen(__b2c__src) - 1;" >> $g_HFILE
print -r "if(__b2c__loc == 0 || __b2c__loc == 2) {while (__b2c__tmp >= __b2c__src && *__b2c__tmp != '\0') {for(__b2c__i = 0; __b2c__i < strlen(__b2c__str); __b2c__i++) {if (*__b2c__tmp == *(__b2c__str+__b2c__i))" >> $g_HFILE
print -r "{__b2c__tmp--; break; } } if(__b2c__i == strlen(__b2c__str)) break;} } __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__src)+1)*sizeof(char));" >> $g_HFILE
print -r "for(__b2c__i = 0; __b2c__i <= __b2c__tmp - __b2c__src; __b2c__i++) __b2c__sbuffer[__b2c__sbuffer_ptr][__b2c__i]=__b2c__src[__b2c__i];" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr][__b2c__i] = '\0'; return (__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define CHOP${g_STRINGSIGN}(...) __b2c__chop(__VA_ARGS__, 0)" >> $g_HFILE
print -r "char* __b2c__replace(char* __b2c__x, char* __b2c__y, char* __b2c__z){" >> $g_HFILE
print -r "char *__b2c__tmp, *__b2c__buf, *__b2c__haystack, *__b2c__dup = NULL; __b2c__sbuffer_ptr++;" >> $g_HFILE
print -r "if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0; __b2c__haystack = strdup(__b2c__x); __b2c__dup = __b2c__haystack;" >> $g_HFILE
print -r "__b2c__buf = calloc(1, sizeof(char)); while((__b2c__tmp = strstr(__b2c__haystack, __b2c__y)) != NULL) {*__b2c__tmp = '\0';" >> $g_HFILE
print -r "__b2c__buf = realloc(__b2c__buf, (strlen(__b2c__buf) + strlen(__b2c__haystack) + strlen(__b2c__z) + 1)*sizeof(char));" >> $g_HFILE
print -r "strcat(__b2c__buf, __b2c__haystack);strcat(__b2c__buf, __b2c__z);__b2c__haystack = __b2c__tmp+strlen(__b2c__y);}" >> $g_HFILE
print -r "__b2c__buf = realloc(__b2c__buf, (strlen(__b2c__buf) + strlen(__b2c__haystack) + 1)*sizeof(char));strcat(__b2c__buf, __b2c__haystack);" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], (strlen(__b2c__buf)+1)*sizeof(char));" >> $g_HFILE
print -r "strcpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__buf);free(__b2c__buf);free(__b2c__dup);return (__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define REPLACE${g_STRINGSIGN}(x, y, z)((x!=NULL && y!=NULL && z!= NULL) ? __b2c__replace(x, y, z) : 0)" >> $g_HFILE
print -r "#define LEN(x) ((x != NULL) ? strlen(x) : 0)" >> $g_HFILE
print -r "#define EQUAL(__b2c__x, __b2c__y) ((__b2c__x != NULL && __b2c__y != NULL && __b2c__option_compare == 0) ? !strcmp(__b2c__x, __b2c__y) : ((__b2c__x != NULL && __b2c__y != NULL && __b2c__option_compare == 1) ? !strcasecmp(__b2c__x, __b2c__y) : 0) )" >> $g_HFILE
print -r "char * __b2c__getenv(char *__b2c__env){static char * __b2c__tmp; __b2c__tmp = getenv(__b2c__env); if (__b2c__tmp == NULL)" >> $g_HFILE
print -r "{return \"\";} return __b2c__tmp;}" >> $g_HFILE
print -r "#define GETENVIRON${g_STRINGSIGN}(x) ((x != NULL) ? __b2c__getenv(x) : \"null\")" >> $g_HFILE
print -r "#define SETENVIRON(x, y) if(x != NULL && y != NULL) setenv(x, y, 1)" >> $g_HFILE
print >> $g_HFILE
print -r "/* CHAR functions */" >> $g_HFILE
print -r "#include <ctype.h>" >> $g_HFILE
#provides isxdigit ... error imreq
print -r "char* __b2c__ucase(char *__b2c__s){int __b2c__i; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], strlen(__b2c__s)*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, strlen(__b2c__s)*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "for(__b2c__i=0; __b2c__i < strlen(__b2c__s); __b2c__i++){__b2c__sbuffer[__b2c__sbuffer_ptr][__b2c__i]=toupper(__b2c__s[__b2c__i]);}" >> $g_HFILE
print -r "return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define UCASE${g_STRINGSIGN}(x) ((x != NULL) ? __b2c__ucase(x) : \"null\")" >> $g_HFILE
print -r "char* __b2c__lcase(char *__b2c__s){int __b2c__i; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], strlen(__b2c__s)*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, strlen(__b2c__s)*sizeof(char)+1*sizeof(char));" >> $g_HFILE
print -r "for(__b2c__i=0; __b2c__i < strlen(__b2c__s); __b2c__i++){__b2c__sbuffer[__b2c__sbuffer_ptr][__b2c__i]=tolower(__b2c__s[__b2c__i]);}" >> $g_HFILE
print -r "return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define LCASE${g_STRINGSIGN}(x) ((x != NULL) ? __b2c__lcase(x) : \"null\")" >> $g_HFILE
print >> $g_HFILE
print -r "/* I/O functions */" >> $g_HFILE
print -r "FILE *__b2c__inFile; FILE *__b2c__outFile; int __b2c__Byte; struct dirent *__b2c__dir;" >> $g_HFILE
print -r "char* __b2c__dec2hex(int __b2c__i){__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS);" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, $g_MAX_DIGITS);" >> $g_HFILE
print -r "snprintf(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%X\", __b2c__i); return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "long __b2c__hex2dec(char *__b2c__h){unsigned int __b2c__i; if(sscanf(__b2c__h, \"%X\", &__b2c__i) == EOF && !__b2c__trap){ERROR = 5;" >> $g_HFILE
print -r "fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} return(long)(__b2c__i);}" >> $g_HFILE
print -r "unsigned char __b2c__char2asc(char *__b2c__c){return (unsigned char)*__b2c__c;}" >> $g_HFILE
print -r "char* __b2c__asc2char(int __b2c__i){__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], 2*sizeof(char));" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, 2*sizeof(char)); snprintf(__b2c__sbuffer[__b2c__sbuffer_ptr], 2, \"%c\", __b2c__i);" >> $g_HFILE
print -r "return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "/* Function FILEEXISTS contributed by Armando Rivera */ " >> $g_HFILE
print -r "long __b2c__fileexists(const char *__b2c__x) {struct stat __b2c__buf; if (stat(__b2c__x, &__b2c__buf) != -1) return 1; return 0;}" >> $g_HFILE
print -r "#define FILEEXISTS(x) __b2c__fileexists(x)" >> $g_HFILE
print -r "long __b2c__filelen(const char *__b2c__x) {struct stat __b2c__buf; if(stat(__b2c__x, &__b2c__buf) < 0 && !__b2c__trap){ERROR = 24; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}" >> $g_HFILE
print -r "if(__b2c__x == NULL || stat(__b2c__x, &__b2c__buf) < 0) return -1; else return(long)(__b2c__buf.st_size);}" >> $g_HFILE
print -r "#define FILELEN(x) __b2c__filelen(x)" >> $g_HFILE
print -r "long __b2c__filetype(const char *__b2c__x) {long __b2c_fs = 0; struct stat __b2c__buf; if(__b2c__x == NULL) return 0; if(lstat(__b2c__x, &__b2c__buf) < 0 && !__b2c__trap)" >> $g_HFILE
print -r "{ERROR = 24; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}" >> $g_HFILE
print -r "if (S_ISREG(__b2c__buf.st_mode)) __b2c_fs = 1; if (S_ISDIR(__b2c__buf.st_mode)) __b2c_fs = 2;" >> $g_HFILE
print -r "if (S_ISCHR(__b2c__buf.st_mode)) __b2c_fs = 3; if (S_ISBLK(__b2c__buf.st_mode)) __b2c_fs = 4; if (S_ISFIFO(__b2c__buf.st_mode)) __b2c_fs = 5;" >> $g_HFILE
print -r "if (S_ISLNK(__b2c__buf.st_mode)) __b2c_fs = 6; if (S_ISSOCK(__b2c__buf.st_mode)) __b2c_fs = 7; return __b2c_fs;}" >> $g_HFILE
print -r "#define FILETYPE(x) __b2c__filetype(x)" >> $g_HFILE
print -r "long __b2c__search(FILE* __b2c__x, char* __b2c__y){long __b2c__off, __b2c__pos; char* __b2c__ptr; size_t __b2c__tot;" >> $g_HFILE
print -r "if(__b2c__x == NULL && !__b2c__trap){ERROR = 2; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}" >> $g_HFILE
print -r "if(__b2c__y == NULL && !__b2c__trap){ERROR = 25; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}" >> $g_HFILE
print -r "__b2c__pos = ftell(__b2c__x); __b2c__ptr = (char*)malloc((strlen(__b2c__y)+1)*sizeof(char)); __b2c__off = 0; do {" >> $g_HFILE
print -r "fseek(__b2c__x, __b2c__off, SEEK_SET);memset(__b2c__ptr, 0, sizeof(char)*(strlen(__b2c__y)+1));" >> $g_HFILE
print -r "__b2c__tot = fread(__b2c__ptr, sizeof(char), strlen(__b2c__y), __b2c__x);__b2c__off+=1;" >> $g_HFILE
print -r "} while(!feof(__b2c__x) && strncmp(__b2c__ptr, __b2c__y, strlen(__b2c__y)));" >> $g_HFILE
print -r "if(strncmp(__b2c__ptr, __b2c__y, strlen(__b2c__y))) __b2c__off = 0; fseek(__b2c__x, __b2c__pos, SEEK_SET); free(__b2c__ptr); return (--__b2c__off);}" >> $g_HFILE
print -r "#define SEARCH(x, y) __b2c__search(x, y)" >> $g_HFILE
print -r "char *__b2c__exec(char *__b2c__x, ...){int __b2c__r, __b2c__len, __b2c__i, __b2c__page; int __b2c__wpipe[2], __b2c__rpipe[2]; char *__b2c__str, *__b2c__ans = NULL; va_list __b2c__ap;" >> $g_HFILE
print -r "va_start(__b2c__ap, __b2c__x); __b2c__str = va_arg (__b2c__ap, char*); va_end(__b2c__ap); if (pipe (__b2c__rpipe) < 0 || pipe (__b2c__wpipe) < 0){if(!__b2c__trap) {ERROR=29;fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}}" >> $g_HFILE
print -r "if ((__b2c__r = fork ()) < 0){if(!__b2c__trap) {ERROR=29;fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}} else if (__b2c__r == 0){" >> $g_HFILE
print -r "close(__b2c__wpipe[1]);close (__b2c__rpipe[0]);dup2 (__b2c__wpipe[0], STDIN_FILENO);close (__b2c__wpipe[0]);dup2 (__b2c__rpipe[1], STDOUT_FILENO);close (__b2c__rpipe[1]); __b2c__r = system (__b2c__x); if(WIFEXITED(__b2c__r)) RETVAL = WEXITSTATUS(__b2c__r); else RETVAL=0; exit(RETVAL);}" >> $g_HFILE
print -r "else{close (__b2c__wpipe[0]);close (__b2c__rpipe[1]); __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_BUFFER_SIZE*sizeof(char) + 1);__b2c__ans = (char *) malloc ($g_BUFFER_SIZE * sizeof (char)); __b2c__len = 0;__b2c__page = 0;" >> $g_HFILE
print -r "if(__b2c__str!=NULL) __b2c__i = write(__b2c__wpipe[1], __b2c__str, strlen(__b2c__str)+1); wait(&RETVAL); RETVAL = WEXITSTATUS(RETVAL); do{__b2c__i = read (__b2c__rpipe[0], __b2c__ans, $g_BUFFER_SIZE);if (__b2c__i == -1 && !__b2c__trap){ERROR=30;fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}" >> $g_HFILE
print -r "if (__b2c__i == 0)break;if (__b2c__len + __b2c__i > $g_BUFFER_SIZE * __b2c__page + 1){__b2c__page++;__b2c__sbuffer[__b2c__sbuffer_ptr] = realloc (__b2c__sbuffer[__b2c__sbuffer_ptr], $g_BUFFER_SIZE * __b2c__page + 1);" >> $g_HFILE
print -r "if (__b2c__sbuffer[__b2c__sbuffer_ptr] == NULL && !__b2c__trap){ERROR=6; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } memcpy (__b2c__sbuffer[__b2c__sbuffer_ptr] + __b2c__len, __b2c__ans, __b2c__i);" >> $g_HFILE
print -r " __b2c__len += __b2c__i;} while (__b2c__i > 0); __b2c__sbuffer[__b2c__sbuffer_ptr][__b2c__len] = '\0';close (__b2c__wpipe[1]);" >> $g_HFILE
print -r "close (__b2c__rpipe[0]);free (__b2c__ans);} return (__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define EXEC${g_STRINGSIGN}(...) __b2c__exec(__VA_ARGS__, (char*)NULL)" >> $g_HFILE
print -r "#define ENDFILE(x) feof(x)" >> $g_HFILE
print -r "#define TELL(x) ftell(x)" >> $g_HFILE
print -r "#define HEX${g_STRINGSIGN}(x) __b2c__dec2hex(x)" >> $g_HFILE
print -r "#define DEC(x) __b2c__hex2dec(x)" >> $g_HFILE
print -r "#define ASC(x) __b2c__char2asc(x)" >> $g_HFILE
print -r "#define CHR${g_STRINGSIGN}(__b2c__x) __b2c__asc2char(__b2c__x)" >> $g_HFILE
print -r "#define MEMTELL(x) (long)x" >> $g_HFILE
print >> $g_HFILE
print -r "#include <errno.h>" >> $g_HFILE
print >> $g_HFILE
print -r "/* GETKEY */" >> $g_HFILE
print -r "#include <termios.h>" >> $g_HFILE
print -r "long __b2c__getch(){long __b2c__ch; struct termios __b2c__oldt, __b2c__newt; tcgetattr(STDIN_FILENO, &__b2c__oldt);" >> $g_HFILE
print -r "__b2c__newt = __b2c__oldt; __b2c__newt.c_lflag &= ~(ICANON | ECHO); __b2c__newt.c_cc[VMIN]=1; __b2c__newt.c_cc[VTIME]=0; tcsetattr(STDIN_FILENO, TCSANOW, &__b2c__newt);" >> $g_HFILE
print -r "__b2c__ch = getchar(); tcsetattr(STDIN_FILENO, TCSANOW, &__b2c__oldt); return __b2c__ch;} " >> $g_HFILE
print -r "#define GETKEY __b2c__getch()" >> $g_HFILE
print -r "long __b2c__getxy(int __b2c__type){char __b2c__asw[$g_BUFFER_SIZE]; struct termios __b2c__old, __b2c__new; int __b2c__len, __b2c__x, __b2c__y; ssize_t __b2c__tot;" >> $g_HFILE
print -r "tcgetattr(STDIN_FILENO, &__b2c__old); __b2c__new = __b2c__old;__b2c__new.c_lflag &= ~(ICANON | ECHO); tcsetattr(STDIN_FILENO, TCSANOW, &__b2c__new);" >> $g_HFILE
print -r "__b2c__tot = write(STDOUT_FILENO, \"\033[6n\", strlen(\"\033[6n\")); __b2c__len = read(STDIN_FILENO, __b2c__asw, $g_BUFFER_SIZE);__b2c__asw[__b2c__len] = '\0'; " >> $g_HFILE
print -r "tcsetattr(STDIN_FILENO, TCSANOW, &__b2c__old); sscanf(__b2c__asw, \"\033[%d;%dR\", &__b2c__y, &__b2c__x); if (!__b2c__type) return(long)__b2c__x; return(long)__b2c__y;}" >> $g_HFILE
print -r "#define GETX __b2c__getxy(0)" >> $g_HFILE
print -r "#define GETY __b2c__getxy(1)" >> $g_HFILE
print -r "long __b2c__screen(int __b2c__type){long __b2c__x; fprintf(stdout,\"\033[s\"); fprintf(stdout,\"\033[?25l\"); fprintf(stdout,\"\033[999;999H\"); fflush(stdout);" >> $g_HFILE
print -r "__b2c__x = __b2c__getxy(__b2c__type); fprintf(stdout,\"\033[u\"); fprintf(stdout,\"\033[?25h\"); fflush(stdout); return(__b2c__x); }" >> $g_HFILE
print -r "#define COLUMNS __b2c__screen(0)" >> $g_HFILE
print -r "#define ROWS __b2c__screen(1)" >> $g_HFILE
print >> $g_HFILE
print -r "/* Constants, logical stuff */" >> $g_HFILE
print -r "#define PI 3.14159265" >> $g_HFILE
print -r "#define NOT(__b2c__x) (!(__b2c__x))" >> $g_HFILE
print -r "#define AND &&" >> $g_HFILE
print -r "#define OR ||" >> $g_HFILE
print -r "#define EQ ==" >> $g_HFILE
print -r "#define IS ==" >> $g_HFILE
print -r "#define NE !=" >> $g_HFILE
print -r "#define ISNOT !=" >> $g_HFILE
print -r "#define TRUE 1" >> $g_HFILE
print -r "#define FALSE 0" >> $g_HFILE
print -r "#define NL${g_STRINGSIGN} \"\n\"" >> $g_HFILE
print -r "#define STRING char*" >> $g_HFILE
print -r "#define NUMBER long" >> $g_HFILE
print -r "#define FLOATING double" >> $g_HFILE
print -r "#define ISTRUE(__b2c__x) (__b2c__x!=0)" >> $g_HFILE
print -r "#define ISFALSE(__b2c__x) (__b2c__x==0)" >> $g_HFILE
print -r "#define SIZEOF(__b2c__x) sizeof(__b2c__x)" >> $g_HFILE
print >> $g_HFILE
print -r "/* Date and time */" >> $g_HFILE
print -r "#include <time.h>" >> $g_HFILE
print -r "#define NOW (long)time(NULL)" >> $g_HFILE
print -r "long __b2c__time(time_t __b2c__now, int __b2c__which){struct tm *ts; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS);" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, $g_MAX_DIGITS); ts = localtime(&__b2c__now); switch(__b2c__which) { case 1: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%d\", ts); break;" >> $g_HFILE
print -r "case 2: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%m\", ts); break; case 3: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%Y\", ts); break;" >> $g_HFILE
print -r "case 4: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%H\", ts); break; case 5: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%M\", ts); break;" >> $g_HFILE
print -r "case 6: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%S\", ts); break; case 7: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%W\", ts); break;}" >> $g_HFILE
print -r "return(atol(__b2c__sbuffer[__b2c__sbuffer_ptr]));}" >> $g_HFILE
print -r "#define DAY(x) __b2c__time(x, 1)" >> $g_HFILE
print -r "#define MONTH(x) __b2c__time(x, 2)" >> $g_HFILE
print -r "#define YEAR(x) __b2c__time(x, 3)" >> $g_HFILE
print -r "#define HOUR(x) __b2c__time(x, 4)" >> $g_HFILE
print -r "#define MINUTE(x) __b2c__time(x, 5)" >> $g_HFILE
print -r "#define SECOND(x) __b2c__time(x, 6)" >> $g_HFILE
print -r "#define WEEK(x) __b2c__time(x, 7)" >> $g_HFILE
print -r "char * __b2c__datename(time_t __b2c__now, int __b2c__which){struct tm *ts; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS);" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, $g_MAX_DIGITS); ts = localtime(&__b2c__now); switch(__b2c__which){case 1: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%A\", ts); break;" >> $g_HFILE
print -r "case 2: strftime(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_MAX_DIGITS, \"%B\", ts); break;} return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define WEEKDAY${g_STRINGSIGN}(x) __b2c__datename(x, 1)" >> $g_HFILE
print -r "#define MONTH${g_STRINGSIGN}(x) __b2c__datename(x, 2)" >> $g_HFILE
print -r "unsigned long __b2c__epoch(int __b2c__year, int __b2c__month, int __b2c__day, int __b2c__hour, int __b2c__minute, int __b2c__second){" >> $g_HFILE
print -r "struct tm tm; time_t __b2c__t; tm.tm_year = __b2c__year - 1900; tm.tm_mon = __b2c__month - 1; tm.tm_mday = __b2c__day;" >> $g_HFILE
print -r "tm.tm_hour = __b2c__hour; tm.tm_min = __b2c__minute; tm.tm_sec = __b2c__second;" >> $g_HFILE
print -r "tm.tm_isdst = -1; __b2c__t = mktime(&tm); if (__b2c__t == -1) return (0); return(long) __b2c__t; }" >> $g_HFILE
print -r "#define TIMEVALUE(x,y,z,a,b,c) __b2c__epoch(x,y,z,a,b,c)" >> $g_HFILE
print -r "char* __b2c__os(void){struct utsname __b2c__buf; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_BUFFER_SIZE);" >> $g_HFILE
print -r "memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, $g_BUFFER_SIZE); if(uname(&__b2c__buf) < 0 && !__b2c__trap) {ERROR = 26; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}" >> $g_HFILE
print -r "strcpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__buf.sysname); strcat(__b2c__sbuffer[__b2c__sbuffer_ptr], \" \");" >> $g_HFILE
print -r "strcat(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__buf.machine); return(__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define OS${g_STRINGSIGN} __b2c__os()" >> $g_HFILE
print >> $g_HFILE
print -r "/* Peek and Poke */" >> $g_HFILE
print -r "struct stat __b2c__sb;" >>  $g_HFILE
print -r "int __b2c__memory__check(void* __b2c__x) {if (stat(__b2c__x, &__b2c__sb) == -1 && errno == EFAULT) return(1); else return(0); }" >> $g_HFILE
print -r "long __b2c__malloc(long __b2c__x) {void *__b2c__mem; if(__b2c__x==0) return(0); switch(__b2c__memtype) {case 1: __b2c__mem = calloc(__b2c__x+__b2c__option_memstream, sizeof(char)); break;" >> $g_HFILE
print -r "case 2: __b2c__mem = calloc(__b2c__x+__b2c__option_memstream, sizeof(short)); break; case 3: __b2c__mem = calloc(__b2c__x+__b2c__option_memstream, sizeof(int)); break;" >> $g_HFILE
print -r "case 4: __b2c__mem = calloc(__b2c__x+__b2c__option_memstream, sizeof(long)); break; case 5: __b2c__mem = calloc(__b2c__x+__b2c__option_memstream, sizeof(float)); break;" >> $g_HFILE
print -r "case 6: __b2c__mem = calloc(__b2c__x+__b2c__option_memstream, sizeof(double)); break; case 7: __b2c__mem = calloc(__b2c__x+__b2c__option_memstream, sizeof(char)); break;}" >> $g_HFILE
print -r "if(__b2c__mem == NULL && !__b2c__trap) {ERROR = 6; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} return(long)__b2c__mem;}" >> $g_HFILE
print -r "#define MEMORY(__b2c__x) __b2c__malloc(__b2c__x)" >> $g_HFILE
print -r "void *__b2c__realloc(void* __b2c__x, long __b2c__y) {if(__b2c__x == NULL) return (NULL); if(!__b2c__trap) {if(__b2c__memory__check((char*)__b2c__x))" >> $g_HFILE
print -r "{ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } switch(__b2c__memtype) {case 1: __b2c__x = realloc((void*)__b2c__x, sizeof(char)*(__b2c__y+1)); break;" >> $g_HFILE
print -r "case 2: __b2c__x = realloc((void*)__b2c__x, sizeof(short)*(__b2c__y+1)); break; case 3: __b2c__x = realloc((void*)__b2c__x, sizeof(int)*(__b2c__y+1)); break;" >> $g_HFILE
print -r "case 4: __b2c__x = realloc((void*)__b2c__x, sizeof(long)*(__b2c__y+1)); break; case 5: __b2c__x = realloc((void*)__b2c__x, sizeof(float)*(__b2c__y+1)); break;" >> $g_HFILE
print -r "case 6: __b2c__x = realloc((void*)__b2c__x, sizeof(double)*(__b2c__y+1)); break; case 7: __b2c__x = realloc((void*)__b2c__x, sizeof(char)*(__b2c__y+1)); break;}" >> $g_HFILE
print -r "if(__b2c__x == NULL && !__b2c__trap) {ERROR = 6; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} return (__b2c__x);}" >> $g_HFILE
print -r "#define RESIZE(__b2c__x, __b2c__y) __b2c__realloc((void*)__b2c__x, __b2c__y)" >> $g_HFILE
print -r "char __b2c__peek(char* __b2c__x) {if(!__b2c__trap) {if(__b2c__memory__check((char*) __b2c__x)) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } return((char)*__b2c__x);}" >> $g_HFILE
print -r "short __b2c__peeks(short* __b2c__x) {if(!__b2c__trap) {if(__b2c__memory__check((short*) __b2c__x)) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } return((short)*__b2c__x);}" >> $g_HFILE
print -r "int __b2c__peeki(int* __b2c__x) {if(!__b2c__trap) {if(__b2c__memory__check((int*) __b2c__x)) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } return((int)*__b2c__x);}" >> $g_HFILE
print -r "long __b2c__peekl(long* __b2c__x) {if(!__b2c__trap) {if(__b2c__memory__check((long*) __b2c__x)) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } return((long)*__b2c__x);}" >> $g_HFILE
print -r "float __b2c__peekf(float* __b2c__x) {if(!__b2c__trap) {if(__b2c__memory__check((float*) __b2c__x)) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } return((float)*__b2c__x);}" >> $g_HFILE
print -r "double __b2c__peekd(double* __b2c__x) {if(!__b2c__trap) {if(__b2c__memory__check((double*) __b2c__x)) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } return((double)*__b2c__x);}" >> $g_HFILE
print -r "char __b2c__peekv(char* __b2c__x) {if(!__b2c__trap) {if(__b2c__memory__check((char*) __b2c__x)) {ERROR=1; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);} } return((char)*__b2c__x);}" >> $g_HFILE
print -r "#define PEEK(__b2c__x) (__b2c__memtype==1 ? (unsigned char)__b2c__peek((char*)__b2c__x) : (__b2c__memtype==2 ? (unsigned short)__b2c__peeks((short*)__b2c__x) : (__b2c__memtype==3 ? (unsigned int)__b2c__peeki((int*)__b2c__x) : \\" >> $g_HFILE
print -r "(__b2c__memtype==4 ? (unsigned long)__b2c__peekl((long*)__b2c__x) : ( __b2c__memtype==5 ? (float)__b2c__peekf((float*)__b2c__x) : (__b2c__memtype==6 ? (double)__b2c__peekd((double*)__b2c__x) : (unsigned char)__b2c__peekv((char*)__b2c__x) ))))))" >> $g_HFILE
print -r "#define ADDRESS(__b2c__x) (long)(&__b2c__x)" >> $g_HFILE
print -r "#define FP(__b2c__x) (void*)(&__b2c__x)" >> $g_HFILE
print >> $g_HFILE
print -r "/* Network variables and functions */" >> $g_HFILE
print -r "struct timeval __b2c__to; struct hostent *__b2c__he;  char *__b2c__host; char *__b2c__port; int __b2c__yes = 1; char __b2c__ttl = 1; struct sockaddr_in __b2c__addr; /* struct ip_mreq __b2c__imreq; */" >> $g_HFILE
print -r "int __b2c__result; char __b2c__data_client[$g_BUFFER_SIZE] = { 0 }; char __b2c__data_server[$g_BUFFER_SIZE] = { 0 }; int __b2c__handle;" >> $g_HFILE
print -r "long __b2c__netpeek(int __b2c__fd, int __b2c__usec){fd_set __b2c__rfds; struct timeval __b2c__tv; long __b2c__retval; struct termios __b2c__oldt, __b2c__newt;" >> $g_HFILE
print -r "if(__b2c__fd == STDIN_FILENO){tcgetattr(STDIN_FILENO, &__b2c__oldt); __b2c__newt = __b2c__oldt; __b2c__newt.c_lflag &= ~(ICANON | ECHO); __b2c__newt.c_cc[VMIN]=1; __b2c__newt.c_cc[VTIME]=0; tcsetattr(STDIN_FILENO, TCSANOW, &__b2c__newt);}" >> $g_HFILE
print -r "FD_ZERO(&__b2c__rfds); FD_SET(__b2c__fd, &__b2c__rfds);__b2c__tv.tv_usec = (__b2c__usec%1000)*1000; __b2c__tv.tv_sec = __b2c__usec/1000;" >> $g_HFILE
print -r "__b2c__retval = select(__b2c__fd + 1, &__b2c__rfds, NULL, NULL, &__b2c__tv); if (__b2c__retval == -1 && !__b2c__trap) {ERROR = 16; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR);}" >> $g_HFILE
print -r "if(__b2c__fd == STDIN_FILENO){if(__b2c__retval) if(read(__b2c__fd, &__b2c__retval, 1)==0) __b2c__retval=0; tcsetattr(STDIN_FILENO, TCSANOW, &__b2c__oldt);} return(__b2c__retval);}" >> $g_HFILE
print -r "#define WAIT(x, y) __b2c__netpeek(x, y)" >> $g_HFILE
print -r "char* __b2c__nethost(char* __b2c__host) {int __b2c__y; int __b2c__flag = 0; struct in_addr __b2c__address; __b2c__sbuffer_ptr++; if(__b2c__sbuffer_ptr >= $g_MAX_BUFFERS) __b2c__sbuffer_ptr=0;" >> $g_HFILE
print -r "__b2c__sbuffer[__b2c__sbuffer_ptr] = (char*)realloc(__b2c__sbuffer[__b2c__sbuffer_ptr], $g_BUFFER_SIZE); memset(__b2c__sbuffer[__b2c__sbuffer_ptr], 0, $g_BUFFER_SIZE);" >> $g_HFILE
print -r "for(__b2c__y=0; __b2c__y < strlen(__b2c__host); __b2c__y++) {if(isalpha(*(__b2c__host+__b2c__y))) {__b2c__flag = 1; break;}} if(__b2c__flag) __b2c__he = gethostbyname(__b2c__host); " >> $g_HFILE
print -r "else {if(inet_aton(__b2c__host, &__b2c__address)) __b2c__he = gethostbyaddr((void*)&__b2c__address, sizeof(struct in_addr), AF_INET); } if (__b2c__he == NULL || __b2c__he->h_addr == NULL || __b2c__he->h_name == NULL)" >> $g_HFILE
print -r "{if(!__b2c__trap){ERROR = 11; fprintf(stderr, \"%s\n\", ERR${g_STRINGSIGN}(ERROR)); exit(ERROR); } else strncpy(__b2c__sbuffer[__b2c__sbuffer_ptr], \"Host not found\", $g_BUFFER_SIZE-1); } else {if(__b2c__flag) {__b2c__addr.sin_addr = *((struct in_addr *)__b2c__he->h_addr);" >> $g_HFILE
print -r "strncpy(__b2c__sbuffer[__b2c__sbuffer_ptr], inet_ntoa(__b2c__addr.sin_addr), $g_BUFFER_SIZE-1);} else strncpy(__b2c__sbuffer[__b2c__sbuffer_ptr], __b2c__he->h_name, $g_BUFFER_SIZE-1);} return (__b2c__sbuffer[__b2c__sbuffer_ptr]);}" >> $g_HFILE
print -r "#define HOST${g_STRINGSIGN}(__b2c__x) __b2c__nethost(__b2c__x)" >> $g_HFILE
print >> $g_HFILE
print -r "/* Regex */" >> $g_HFILE
print -r "#include <regex.h>" >> $g_HFILE
print -r "long __b2c__regex(char* __b2c__x, char* __b2c__y){regex_t __b2c__reg; int __b2c__reti; char __b2c__buf[100]; __b2c__reti = regcomp(&__b2c__reg, __b2c__y, REG_EXTENDED|REG_NOSUB);" >> $g_HFILE
print -r "if(!__b2c__trap && __b2c__reti){ERROR=27; fprintf(stderr, \"%s: \", ERR${g_STRINGSIGN}(ERROR)); regerror(__b2c__reti, &__b2c__reg, __b2c__buf, sizeof(__b2c__buf)); fprintf(stderr, \"%s\n\", __b2c__buf);" >> $g_HFILE
print -r "exit(ERROR);} __b2c__reti = regexec(&__b2c__reg, __b2c__x, 0, NULL, 0);" >> $g_HFILE
print -r "regfree(&__b2c__reg); if( !__b2c__reti ) return (1); else return (0);}" >> $g_HFILE
print -r "#define REGEX(x, y) __b2c__regex(x, y)" >> $g_HFILE
print >> $g_HFILE
print -r "/* Declare reserved variable 'ARGUMENT' */" >> $g_HFILE
print -r "int __b2c__counter;" >> $g_HFILE
print -r "int __b2c__arglen = 0;" >> $g_HFILE
print -r "char *ARGUMENT${g_STRINGSIGN};" >> $g_HFILE
print >> $g_HFILE
print -r "/* Initialize stack arrays and pointer */" >> $g_HFILE
print -r "char **__b2c__stringstack = NULL; double *__b2c__doublestack = NULL;" >> $g_HFILE
print -r "long *__b2c__longstack = NULL; int *__b2c__typestack = NULL;" >> $g_HFILE
print -r "int __b2c__stackptr = 0;" >> $g_HFILE
# Signal function
print -r "/* Signal trapping activated with TRAP */" >> $g_HFILE
print -r "void __b2c__catch_signal(int sig){" >> $g_HFILE
print -r "switch (sig) {case SIGABRT: fprintf(stderr, \"ERROR: signal ABORT received - internal error. Try to compile the program with TRAP LOCAL to find the cause.\n\"); break;" >> $g_HFILE
print -r "case SIGFPE: fprintf(stderr, \"ERROR: signal for FPE received - division by zero? Examine the calculations in the program.\n\"); break;" >> $g_HFILE
print -r "case SIGSEGV: fprintf(stderr, \"ERROR: signal for SEGMENTATION FAULT received - memory invalid or array out of bounds? Try to compile the program with TRAP LOCAL to find the cause.\n\"); break;" >> $g_HFILE
print -r "case SIGILL: fprintf(stderr, \"ERROR: signal for ILLEGAL INSTRUCTION received - executing the program on other hardware? Try to recompile the program from scratch.\n\"); break;} exit(sig);}" >> $g_HFILE
# Makedir function
print -r "int __b2c__makedir(char* __b2c__in){char *__b2c__i, *__b2c__dir; if(__b2c__in == NULL || strlen(__b2c__in)==0) return 0; if(*__b2c__in != '/'){__b2c__dir = (char*)malloc((strlen(__b2c__in)+2)*sizeof(char));" >> $g_HFILE
print -r "strncpy(__b2c__dir, \"./\", 2); __b2c__dir = strcat(__b2c__dir, __b2c__in);} else __b2c__dir = strdup(__b2c__in); __b2c__i = __b2c__dir; do { __b2c__i++; while(*__b2c__i != '/' && *__b2c__i != '\0') __b2c__i++;" >> $g_HFILE
print -r "if(*__b2c__i == '/') {*__b2c__i = '\0'; mkdir(__b2c__dir, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH); *__b2c__i = '/';} else if (*__b2c__i == '\0') mkdir(__b2c__dir, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH);" >> $g_HFILE
print -r "if(errno != EEXIST && errno != 0) {free(__b2c__dir); return errno;} } while (*__b2c__i != '\0'); free(__b2c__dir); return 0;}" >> $g_HFILE
# Add error function
print >> $g_HFILE
print -r "/* Initialize error function */" >> $g_HFILE
print -r "char *ERR${g_STRINGSIGN}(int __b2c__nr){static char __b2c__warn[$g_BUFFER_SIZE] = { 0 }; const char* __b2c__err;" >> $g_HFILE
print -r "switch(__b2c__nr){" >> $g_HFILE
print -r "case 0: strcpy(__b2c__warn,\"Success\"); break;" >> $g_HFILE
print -r "case 1: strcpy(__b2c__warn,\"Trying to access illegal memory: \"); strncat(__b2c__warn,strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 2: strcpy(__b2c__warn,\"Error opening file: \"); strncat(__b2c__warn,strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 3: strcpy(__b2c__warn, \"Symbol not found in library \"); __b2c__err = NULL; if(__b2c__err!=NULL) strncat(__b2c__warn, __b2c__err, $g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 4: strcpy(__b2c__warn, \"Wrong hexvalue: \"); strncat(__b2c__warn, strerror(errno), $g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 5: strcpy(__b2c__warn, \"Unable to claim memory.\"); break;" >> $g_HFILE
print -r "case 6: strcpy(__b2c__warn, \"Unable to delete file: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 7: strcpy(__b2c__warn, \"Could not open directory: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 8: strcpy(__b2c__warn, \"Unable to rename file: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 9: strcpy(__b2c__warn, \"NETWORK argument should contain colon with port number\"); break;" >> $g_HFILE
print -r "case 10: strcpy(__b2c__warn, \"Could not resolve hostname!\"); break;" >> $g_HFILE
print -r "case 11: strcpy(__b2c__warn, \"Socket error: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 12: strcpy(__b2c__warn, \"Unable to open address: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 13: strcpy(__b2c__warn, \"Error reading from socket: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 14: strcpy(__b2c__warn, \"Error sending to socket: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 15: strcpy(__b2c__warn, \"Error checking socket: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 16: strcpy(__b2c__warn, \"Unable to bind the specified socket address: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 17: strcpy(__b2c__warn, \"Unable to listen to socket address: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 18: strcpy(__b2c__warn, \"Cannot accept incoming connection: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 19: strcpy(__b2c__warn, \"Unable to remove directory: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 20: strcpy(__b2c__warn, \"Unable to create directory: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 21: strcpy(__b2c__warn, \"Unable to change to directory: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 22: strcpy(__b2c__warn, \"GETENVIRON argument does not exist as environment variable\"); break;" >> $g_HFILE
print -r "case 23: strcpy(__b2c__warn, \"Unable to stat file: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 24: strcpy(__b2c__warn, \"Search contains illegal string\"); break;" >> $g_HFILE
print -r "case 25: strcpy(__b2c__warn, \"Cannot return OS name: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 26: strcpy(__b2c__warn, \"Illegal regex expression\"); break;" >> $g_HFILE
print -r "case 27: strcpy(__b2c__warn, \"Unable to create bidirectional pipes: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 28: strcpy(__b2c__warn, \"Unable to fork process: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 29: strcpy(__b2c__warn, \"Cannot read from pipe: \"); strncat(__b2c__warn, strerror(errno),$g_BUFFER_SIZE-48); break;" >> $g_HFILE
print -r "case 30: strcpy(__b2c__warn, \"Gosub nesting too deep!\"); break;" >> $g_HFILE
print -r "}; ERROR = 0; return(__b2c__warn);}" >> $g_HFILE
print >> $g_HFILE
print -r "/* User program definitions */" >> $g_HFILE

# Initialize the arrayfiles for DATA statement
print -r "char *__b2c__stringarray[] = {" > $STRINGARRAYFILE
print -r "double __b2c__floatarray[] = {" > $FLOATARRAYFILE

# There are no imported symbols yet
g_IMPORTED=

# Check if the C Preprocessor needs to run
if [[ $g_CPP -eq 1 ]]
then
    if [[ -n `which cpp 2>/dev/null` ]]
    then
	cpp -P -w $g_SOURCEFILE $g_SOURCEFILE.cpp
	FEED=${g_SOURCEFILE}.cpp
	g_TMP_FILES="$g_TMP_FILES ${g_SOURCEFILE}.cpp"
    else
	print "ERROR: the C Preprocessor 'cpp' not found on this system! Exiting..."
	exit 1
    fi
else
    FEED=${g_SOURCEFILE}
fi
g_CURFILE=${g_SOURCEFILE##*/}

# Initialize
LEN=
TOTAL=
SEQ=
g_COUNTER=1

# Start walking through program
while read -r LINE
do
    print -n "\rConverting '${FEED}'... $g_COUNTER   "
    # Line is not empty?
    if [[ -n "$LINE" ]]
    then
	if [[ "$LINE" = +(* \\) && "$LINE" != +(REM*) && "$LINE" != +(${g_SQUOTESIGN}*) ]]
	then
	    let LEN="${#LINE}"-2
	    typeset -L$LEN SEQ="${LINE}"
	    TOTAL=$TOTAL$SEQ
	else
	    print -r "/* noparse $FEED BACON LINE $g_COUNTER */" >> $g_HFILE
	    print -r "/* noparse $FEED BACON LINE $g_COUNTER */" >> $g_CFILE
	    TOTAL="${TOTAL}${LINE}"
	    if [[ "${TOTAL}" != +(REM*) && "${TOTAL}" != +(${g_SQUOTESIGN}*) ]]
	    then
		Tokenize "${TOTAL}"
	    fi
	    TOTAL=
	fi
    fi
    ((g_COUNTER+=1))
done < $FEED

# Check if enclosed IF/ELIF/ELSE needs to be closed
if [[ $g_IF_PARSE -eq 1 ]]
then
    print -r "}" >> $g_CFILE
fi

# Finalize main C-file
print -r "__B2C__PROGRAM__EXIT:" >> $g_CFILE
print -r "return 0;" >> $g_CFILE
print -r "}" >> $g_CFILE

# Finalize STRING ARRAY file for DATA
print -r " \"\" };" >> $STRINGARRAYFILE

# Finalize FLOAT ARRAY file for DATA
print -r " 0.0};" >> $FLOATARRAYFILE

# Include functions and subs
for i in $g_INCLUDE_FILES
do
    print "#include \"${i}\"" >> $g_HFILE
done

print "\rConverting '${FEED}'... done.  "

# Indentation only when files are preserved
if [[ $g_TMP_PRESERVE -eq 1 ]]
then
    if [[ -n `which indent 2>/dev/null` ]]
    then
	print -n "Applying indentation... "
	for i in $g_TMP_FILES
	do
	    if [[ $i != +(*.cpp) ]]
	    then
		    indent $i
		    rm $i~
	    fi
	done
	print "done."
    else
	print "WARNING: 'indent' not found on this system!"
	print "Generated source code cannot be beautified."
    fi
fi

# Check if we need to run xgettext
if [[ ${g_XGETTEXT} -eq 1 ]]
then
    if [[ -n `which xgettext 2>/dev/null` ]]
    then
	print -n "Executing xgettext... "
	xgettext -d ${g_SOURCEFILE%.*} -s -o ${g_SOURCEFILE%.*}.pot $g_TMP_FILES
	if [[ ! -f "${g_SOURCEFILE%.*}.pot" ]]
	then
	    print "WARNING: catalog file not created!"
	else
	    print "done."
	fi
    else
	print "WARNING: 'xgettext' not found on this system!"
    fi
fi

# Start compilation
if [[ $g_NO_COMPILE -eq 0 ]]
then
    print -n "Compiling '${FEED}'... "

    $g_CCNAME $g_CCFLAGS -o ${g_SOURCEFILE%.*}$g_BINEXT $g_CFILE $g_LDFLAGS > $g_TEMPDIR/${g_SOURCEFILE##*/}.log 2>&1

    g_TMP_FILES="$g_TMP_FILES $g_TEMPDIR/${g_SOURCEFILE##*/}.log"

    if [[ -z `cat $g_TEMPDIR/${g_SOURCEFILE##*/}.log` ]]
    then
	print "done."
	print "Program '${g_SOURCEFILE%.*}$g_BINEXT' ready."
    else
	# Only print first error
	print "Compiler emits messages!"
	while read -r g_ERROR
	do
	    if [[ $g_ERROR != +(*-----*) && ( ${g_ERROR} != +(*from *) || ${g_ERROR} = +(*error:*from*) ) && ${g_ERROR} = +(*[0-9]*) && ${g_ERROR} = +(*: error:*) ]]
	    then
		g_ERRORTXT="Cause:\n\t${g_ERROR##*error:}"
		g_FILE_LINE=${g_ERROR%%error:*}
		break
	    elif [[ $g_ERROR != +(*-----*) && ( {g_ERROR} != +(*from *) || ${g_ERROR} = +(*error:*from*) ) && ${g_ERROR} = +(*[0-9]*) && ${g_ERROR} = +(*: Error:*) ]]
	    then
		g_ERRORTXT="Cause:\n\t${g_ERROR##*:}"
		g_FILE_LINE=${g_ERROR##*Error: }
		break
	    elif [[ $g_ERROR != +(*-----*) && ( ${g_ERROR} != +(*from *) || ${g_ERROR} = +(*warning:*from*) ) && ${g_ERROR} = +(*[0-9]*) && ${g_ERROR} = +(*: warning:*) ]]
	    then
		g_ERRORTXT="Cause:\n\t${g_ERROR##*warning:}"
		g_FILE_LINE=${g_ERROR%%warning:*}
		break
	    elif [[ $g_ERROR != +(*-----*) && ( ${g_ERROR} != +(*from *) || ${g_ERROR} = +(*error:*from*) ) && ${g_ERROR} = +(*[0-9]:*) ]]
	    then
		g_ERRORTXT="Cause:\n\t${g_ERROR##*:}"
		g_FILE_LINE=${g_ERROR%:*}
		break
	    fi
	done < $g_TEMPDIR/${g_SOURCEFILE##*/}.log

	# Restore $-symbol if there is any
	if [[ ${g_ERRORTXT} = +(*${g_STRINGSIGN}*) ]]
	then
	    POS=${#g_ERRORTXT}
	    until [[ $POS -eq 0 ]]
	    do
		typeset -R$POS SUBSTR="${g_ERRORTXT}"
		if [[ $SUBSTR = +($g_STRINGSIGN*) ]]
		then
		    ((LEN=${#g_ERRORTXT}-$POS))
		    typeset -L$LEN SUBSTR1="${g_ERRORTXT}"
		    ((LEN=$POS-${#g_STRINGSIGN}))
		    typeset -R$LEN SUBSTR2="${g_ERRORTXT}"
		    g_ERRORTXT="${SUBSTR1}\$${SUBSTR2}"
		    break
		fi
		((POS-=1))
	    done		
	fi

	# Get the file where the error is
	g_FILE=${g_FILE_LINE%%:*}
	# Tru64Unix helper
	g_FILE=${g_FILE%%,*}

	# Non-gcc or parse problem (file does not exist)
	if [[ -z $g_ERROR || $g_CCFLAGS = +(*Wall*) || ! -f $g_FILE ]]
	then
	    print
	    cat $g_TEMPDIR/${g_SOURCEFILE##*/}.log
	    print
	else
	    # Get the erroneous line
	    if [[ ${g_FILE_LINE} = +(*line*) ]]
	    then
		g_LINE=${g_FILE_LINE#*line}
	    else
		g_LINE=${g_FILE_LINE#*:}
	    fi
	    # Initiate error file name and error line in C code
	    g_FEED=${g_FILE_LINE%%:*}
	    g_CURLINE=${g_LINE%%:*}
	    # Remove everything behind last colon
	    g_LINE=${g_LINE%%:*}
	    g_COUNTER=1
	    while read -r LINE
	    do
		if [[ $LINE = +(*BACON LINE*) && $LINE = +(*noparse*) ]]
		then
		    g_CURLINE=${LINE##*BACON LINE }
		    g_FEED=${LINE##*noparse }
		    g_FEED=${g_FEED%% BACON LINE*}
		fi
		if [[ ${g_COUNTER} -eq ${g_LINE} ]]
		then
		    COUNTER=1
		    while read -r LINE
		    do
			if [[ $COUNTER -eq ${g_CURLINE%% *} ]]
			then
			    print "\nProblem:\n\t file '$g_FEED' line $COUNTER: ${LINE}"
			    print "$g_ERRORTXT\n"
			    break
			fi
			((COUNTER+=1))
		    done < $g_FEED
		    break
		fi
		((g_COUNTER+=1))
	    done < ${g_FILE}
	fi
	# Preserve temp files
	g_TMP_PRESERVE=1
    fi
fi

# Cleanup
if [[ $g_TMP_PRESERVE -eq 0 ]]
then
    for i in $g_TMP_FILES
    do
	rm $i
    done
elif [[ $g_CPP -eq 1 ]]
then
    mv ${g_SOURCEFILE}.cpp $g_TEMPDIR/${g_SOURCEFILE##*/}.cpp
fi

exit 0
